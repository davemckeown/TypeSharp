//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5 C:\\DEVGIT\\typesharp\\TypeScript.g 2013-03-28 12:17:28

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5")]
[System.CLSCompliant(false)]
public partial class TypeScriptParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "CharacterEscapeSequence", "Comment", "DecimalDigit", "DecimalLiteral", "DoubleStringCharacter", "EscapeCharacter", "EscapeSequence", "ExponentPart", "HexDigit", "HexEscapeSequence", "HexIntegerLiteral", "Identifier", "IdentifierPart", "IdentifierStart", "LT", "LineComment", "NonEscapeCharacter", "NumericLiteral", "SingleEscapeCharacter", "SingleStringCharacter", "StringLiteral", "UnicodeCombiningMark", "UnicodeConnectorPunctuation", "UnicodeDigit", "UnicodeEscapeSequence", "UnicodeLetter", "WhiteSpace", "'!'", "'!='", "'!=='", "'%'", "'%='", "'&&'", "'&'", "'&='", "'('", "')'", "'*'", "'*='", "'+'", "'++'", "'+='", "','", "'-'", "'--'", "'-='", "'.'", "'/'", "'/='", "':'", "';'", "'<'", "'<<'", "'<<='", "'<='", "'='", "'=='", "'==='", "'>'", "'>='", "'>>'", "'>>='", "'>>>'", "'>>>='", "'?'", "'['", "']'", "'^'", "'^='", "'break'", "'case'", "'catch'", "'continue'", "'default'", "'delete'", "'do'", "'else'", "'false'", "'finally'", "'for'", "'function'", "'if'", "'in'", "'instanceof'", "'new'", "'null'", "'return'", "'switch'", "'this'", "'throw'", "'true'", "'try'", "'typeof'", "'var'", "'void'", "'while'", "'with'", "'{'", "'|'", "'|='", "'||'", "'}'", "'~'"
	};
	public const int EOF=-1;
	public const int T__31=31;
	public const int T__32=32;
	public const int T__33=33;
	public const int T__34=34;
	public const int T__35=35;
	public const int T__36=36;
	public const int T__37=37;
	public const int T__38=38;
	public const int T__39=39;
	public const int T__40=40;
	public const int T__41=41;
	public const int T__42=42;
	public const int T__43=43;
	public const int T__44=44;
	public const int T__45=45;
	public const int T__46=46;
	public const int T__47=47;
	public const int T__48=48;
	public const int T__49=49;
	public const int T__50=50;
	public const int T__51=51;
	public const int T__52=52;
	public const int T__53=53;
	public const int T__54=54;
	public const int T__55=55;
	public const int T__56=56;
	public const int T__57=57;
	public const int T__58=58;
	public const int T__59=59;
	public const int T__60=60;
	public const int T__61=61;
	public const int T__62=62;
	public const int T__63=63;
	public const int T__64=64;
	public const int T__65=65;
	public const int T__66=66;
	public const int T__67=67;
	public const int T__68=68;
	public const int T__69=69;
	public const int T__70=70;
	public const int T__71=71;
	public const int T__72=72;
	public const int T__73=73;
	public const int T__74=74;
	public const int T__75=75;
	public const int T__76=76;
	public const int T__77=77;
	public const int T__78=78;
	public const int T__79=79;
	public const int T__80=80;
	public const int T__81=81;
	public const int T__82=82;
	public const int T__83=83;
	public const int T__84=84;
	public const int T__85=85;
	public const int T__86=86;
	public const int T__87=87;
	public const int T__88=88;
	public const int T__89=89;
	public const int T__90=90;
	public const int T__91=91;
	public const int T__92=92;
	public const int T__93=93;
	public const int T__94=94;
	public const int T__95=95;
	public const int T__96=96;
	public const int T__97=97;
	public const int T__98=98;
	public const int T__99=99;
	public const int T__100=100;
	public const int T__101=101;
	public const int T__102=102;
	public const int T__103=103;
	public const int T__104=104;
	public const int T__105=105;
	public const int T__106=106;
	public const int CharacterEscapeSequence=4;
	public const int Comment=5;
	public const int DecimalDigit=6;
	public const int DecimalLiteral=7;
	public const int DoubleStringCharacter=8;
	public const int EscapeCharacter=9;
	public const int EscapeSequence=10;
	public const int ExponentPart=11;
	public const int HexDigit=12;
	public const int HexEscapeSequence=13;
	public const int HexIntegerLiteral=14;
	public const int Identifier=15;
	public const int IdentifierPart=16;
	public const int IdentifierStart=17;
	public const int LT=18;
	public const int LineComment=19;
	public const int NonEscapeCharacter=20;
	public const int NumericLiteral=21;
	public const int SingleEscapeCharacter=22;
	public const int SingleStringCharacter=23;
	public const int StringLiteral=24;
	public const int UnicodeCombiningMark=25;
	public const int UnicodeConnectorPunctuation=26;
	public const int UnicodeDigit=27;
	public const int UnicodeEscapeSequence=28;
	public const int UnicodeLetter=29;
	public const int WhiteSpace=30;

	public TypeScriptParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public TypeScriptParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		this.state.ruleMemo = new System.Collections.Generic.Dictionary<int, int>[380+1];


		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return TypeScriptParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\DEVGIT\\typesharp\\TypeScript.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();
	// $ANTLR start "program"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:16:1: program : ( LT !)* sourceElements ( LT !)* EOF !;
	[GrammarRule("program")]
	private AstParserRuleReturnScope<object, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int program_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT1 = default(IToken);
		IToken LT3 = default(IToken);
		IToken EOF4 = default(IToken);
		AstParserRuleReturnScope<object, IToken> sourceElements2 = default(AstParserRuleReturnScope<object, IToken>);

		object LT1_tree = default(object);
		object LT3_tree = default(object);
		object EOF4_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(16, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 1)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:17:2: ( ( LT !)* sourceElements ( LT !)* EOF !)
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:17:4: ( LT !)* sourceElements ( LT !)* EOF !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(17, 6);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:17:6: ( LT !)*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if ((LA1_1==LT))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:17:6: LT !
					{
					DebugLocation(17, 6);
					LT1=(IToken)Match(input,LT,Follow._LT_in_program43); if (state.failed) return retval;

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(17, 9);
			PushFollow(Follow._sourceElements_in_program47);
			sourceElements2=sourceElements();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, sourceElements2.Tree);
			DebugLocation(17, 26);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:17:26: ( LT !)*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if ((LA2_1==LT))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:17:26: LT !
					{
					DebugLocation(17, 26);
					LT3=(IToken)Match(input,LT,Follow._LT_in_program49); if (state.failed) return retval;

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(17, 32);
			EOF4=(IToken)Match(input,EOF,Follow._EOF_in_program53); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
			if (state.backtracking > 0) { Memoize(input, 1, program_StartIndex); }

		}
		DebugLocation(18, 1);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_sourceElements();
	partial void LeaveRule_sourceElements();
	// $ANTLR start "sourceElements"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:20:1: sourceElements : sourceElement ( ( LT !)* sourceElement )* ;
	[GrammarRule("sourceElements")]
	private AstParserRuleReturnScope<object, IToken> sourceElements()
	{
		EnterRule_sourceElements();
		EnterRule("sourceElements", 2);
		TraceIn("sourceElements", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int sourceElements_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT6 = default(IToken);
		AstParserRuleReturnScope<object, IToken> sourceElement5 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> sourceElement7 = default(AstParserRuleReturnScope<object, IToken>);

		object LT6_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "sourceElements");
		DebugLocation(20, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 2)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:21:2: ( sourceElement ( ( LT !)* sourceElement )* )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:21:4: sourceElement ( ( LT !)* sourceElement )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(21, 4);
			PushFollow(Follow._sourceElement_in_sourceElements66);
			sourceElement5=sourceElement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, sourceElement5.Tree);
			DebugLocation(21, 18);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:21:18: ( ( LT !)* sourceElement )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				try
				{
					alt4 = dfa4.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:21:19: ( LT !)* sourceElement
					{
					DebugLocation(21, 21);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:21:21: ( LT !)*
					try { DebugEnterSubRule(3);
					while (true)
					{
						int alt3=2;
						try { DebugEnterDecision(3, false);
						int LA3_1 = input.LA(1);

						if ((LA3_1==LT))
						{
							alt3 = 1;
						}


						} finally { DebugExitDecision(3); }
						switch ( alt3 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:21:21: LT !
							{
							DebugLocation(21, 21);
							LT6=(IToken)Match(input,LT,Follow._LT_in_sourceElements69); if (state.failed) return retval;

							}
							break;

						default:
							goto loop3;
						}
					}

					loop3:
						;

					} finally { DebugExitSubRule(3); }

					DebugLocation(21, 24);
					PushFollow(Follow._sourceElement_in_sourceElements73);
					sourceElement7=sourceElement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, sourceElement7.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("sourceElements", 2);
			LeaveRule("sourceElements", 2);
			LeaveRule_sourceElements();
			if (state.backtracking > 0) { Memoize(input, 2, sourceElements_StartIndex); }

		}
		DebugLocation(22, 1);
		} finally { DebugExitRule(GrammarFileName, "sourceElements"); }
		return retval;

	}
	// $ANTLR end "sourceElements"

	partial void EnterRule_sourceElement();
	partial void LeaveRule_sourceElement();
	// $ANTLR start "sourceElement"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:24:1: sourceElement : ( functionDeclaration | statement );
	[GrammarRule("sourceElement")]
	private AstParserRuleReturnScope<object, IToken> sourceElement()
	{
		EnterRule_sourceElement();
		EnterRule("sourceElement", 3);
		TraceIn("sourceElement", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int sourceElement_StartIndex = input.Index;

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> functionDeclaration8 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement9 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "sourceElement");
		DebugLocation(24, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 3)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:25:2: ( functionDeclaration | statement )
			int alt5=2;
			try { DebugEnterDecision(5, false);
			int LA5_1 = input.LA(1);

			if ((LA5_1==84))
			{
				int LA5_2 = input.LA(2);

				if ((EvaluatePredicate(synpred5_TypeScript_fragment)))
				{
					alt5 = 1;
				}
				else if ((true))
				{
					alt5 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 5, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA5_1==Identifier||LA5_1==NumericLiteral||LA5_1==StringLiteral||LA5_1==31||LA5_1==39||(LA5_1>=43 && LA5_1<=44)||(LA5_1>=47 && LA5_1<=48)||LA5_1==54||LA5_1==69||LA5_1==73||LA5_1==76||(LA5_1>=78 && LA5_1<=79)||LA5_1==81||LA5_1==83||LA5_1==85||(LA5_1>=88 && LA5_1<=101)||LA5_1==106))
			{
				alt5 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 5, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:25:4: functionDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(25, 4);
				PushFollow(Follow._functionDeclaration_in_sourceElement87);
				functionDeclaration8=functionDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, functionDeclaration8.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:26:4: statement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(26, 4);
				PushFollow(Follow._statement_in_sourceElement92);
				statement9=statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, statement9.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("sourceElement", 3);
			LeaveRule("sourceElement", 3);
			LeaveRule_sourceElement();
			if (state.backtracking > 0) { Memoize(input, 3, sourceElement_StartIndex); }

		}
		DebugLocation(27, 1);
		} finally { DebugExitRule(GrammarFileName, "sourceElement"); }
		return retval;

	}
	// $ANTLR end "sourceElement"

	partial void EnterRule_functionDeclaration();
	partial void LeaveRule_functionDeclaration();
	// $ANTLR start "functionDeclaration"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:30:1: functionDeclaration : 'function' ( LT !)* Identifier ( LT !)* formalParameterList ( LT !)* functionBody ;
	[GrammarRule("functionDeclaration")]
	private AstParserRuleReturnScope<object, IToken> functionDeclaration()
	{
		EnterRule_functionDeclaration();
		EnterRule("functionDeclaration", 4);
		TraceIn("functionDeclaration", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int functionDeclaration_StartIndex = input.Index;

		object root_0 = default(object);

		IToken string_literal10 = default(IToken);
		IToken LT11 = default(IToken);
		IToken Identifier12 = default(IToken);
		IToken LT13 = default(IToken);
		IToken LT15 = default(IToken);
		AstParserRuleReturnScope<object, IToken> formalParameterList14 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> functionBody16 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal10_tree = default(object);
		object LT11_tree = default(object);
		object Identifier12_tree = default(object);
		object LT13_tree = default(object);
		object LT15_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "functionDeclaration");
		DebugLocation(30, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 4)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:31:2: ( 'function' ( LT !)* Identifier ( LT !)* formalParameterList ( LT !)* functionBody )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:31:4: 'function' ( LT !)* Identifier ( LT !)* formalParameterList ( LT !)* functionBody
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(31, 4);
			string_literal10=(IToken)Match(input,84,Follow._84_in_functionDeclaration105); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal10_tree = (object)adaptor.Create(string_literal10);
			adaptor.AddChild(root_0, string_literal10_tree);
			}
			DebugLocation(31, 17);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:31:17: ( LT !)*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if ((LA6_1==LT))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:31:17: LT !
					{
					DebugLocation(31, 17);
					LT11=(IToken)Match(input,LT,Follow._LT_in_functionDeclaration107); if (state.failed) return retval;

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }

			DebugLocation(31, 20);
			Identifier12=(IToken)Match(input,Identifier,Follow._Identifier_in_functionDeclaration111); if (state.failed) return retval;
			if (state.backtracking == 0) {
			Identifier12_tree = (object)adaptor.Create(Identifier12);
			adaptor.AddChild(root_0, Identifier12_tree);
			}
			DebugLocation(31, 33);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:31:33: ( LT !)*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_1 = input.LA(1);

				if ((LA7_1==LT))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:31:33: LT !
					{
					DebugLocation(31, 33);
					LT13=(IToken)Match(input,LT,Follow._LT_in_functionDeclaration113); if (state.failed) return retval;

					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }

			DebugLocation(31, 36);
			PushFollow(Follow._formalParameterList_in_functionDeclaration117);
			formalParameterList14=formalParameterList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, formalParameterList14.Tree);
			DebugLocation(31, 58);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:31:58: ( LT !)*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_1 = input.LA(1);

				if ((LA8_1==LT))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:31:58: LT !
					{
					DebugLocation(31, 58);
					LT15=(IToken)Match(input,LT,Follow._LT_in_functionDeclaration119); if (state.failed) return retval;

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }

			DebugLocation(31, 61);
			PushFollow(Follow._functionBody_in_functionDeclaration123);
			functionBody16=functionBody();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, functionBody16.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("functionDeclaration", 4);
			LeaveRule("functionDeclaration", 4);
			LeaveRule_functionDeclaration();
			if (state.backtracking > 0) { Memoize(input, 4, functionDeclaration_StartIndex); }

		}
		DebugLocation(32, 1);
		} finally { DebugExitRule(GrammarFileName, "functionDeclaration"); }
		return retval;

	}
	// $ANTLR end "functionDeclaration"

	partial void EnterRule_functionExpression();
	partial void LeaveRule_functionExpression();
	// $ANTLR start "functionExpression"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:34:1: functionExpression : 'function' ( LT !)* ( Identifier )? ( LT !)* formalParameterList ( LT !)* functionBody ;
	[GrammarRule("functionExpression")]
	private AstParserRuleReturnScope<object, IToken> functionExpression()
	{
		EnterRule_functionExpression();
		EnterRule("functionExpression", 5);
		TraceIn("functionExpression", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int functionExpression_StartIndex = input.Index;

		object root_0 = default(object);

		IToken string_literal17 = default(IToken);
		IToken LT18 = default(IToken);
		IToken Identifier19 = default(IToken);
		IToken LT20 = default(IToken);
		IToken LT22 = default(IToken);
		AstParserRuleReturnScope<object, IToken> formalParameterList21 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> functionBody23 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal17_tree = default(object);
		object LT18_tree = default(object);
		object Identifier19_tree = default(object);
		object LT20_tree = default(object);
		object LT22_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "functionExpression");
		DebugLocation(34, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 5)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:35:2: ( 'function' ( LT !)* ( Identifier )? ( LT !)* formalParameterList ( LT !)* functionBody )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:35:4: 'function' ( LT !)* ( Identifier )? ( LT !)* formalParameterList ( LT !)* functionBody
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(35, 4);
			string_literal17=(IToken)Match(input,84,Follow._84_in_functionExpression135); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal17_tree = (object)adaptor.Create(string_literal17);
			adaptor.AddChild(root_0, string_literal17_tree);
			}
			DebugLocation(35, 17);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:35:17: ( LT !)*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_1 = input.LA(1);

				if ((LA9_1==LT))
				{
					int LA9_2 = input.LA(2);

					if ((EvaluatePredicate(synpred9_TypeScript_fragment)))
					{
						alt9 = 1;
					}


				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:35:17: LT !
					{
					DebugLocation(35, 17);
					LT18=(IToken)Match(input,LT,Follow._LT_in_functionExpression137); if (state.failed) return retval;

					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }

			DebugLocation(35, 20);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:35:20: ( Identifier )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_1 = input.LA(1);

			if ((LA10_1==Identifier))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:35:20: Identifier
				{
				DebugLocation(35, 20);
				Identifier19=(IToken)Match(input,Identifier,Follow._Identifier_in_functionExpression141); if (state.failed) return retval;
				if (state.backtracking == 0) {
				Identifier19_tree = (object)adaptor.Create(Identifier19);
				adaptor.AddChild(root_0, Identifier19_tree);
				}

				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(35, 34);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:35:34: ( LT !)*
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_1 = input.LA(1);

				if ((LA11_1==LT))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch ( alt11 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:35:34: LT !
					{
					DebugLocation(35, 34);
					LT20=(IToken)Match(input,LT,Follow._LT_in_functionExpression144); if (state.failed) return retval;

					}
					break;

				default:
					goto loop11;
				}
			}

			loop11:
				;

			} finally { DebugExitSubRule(11); }

			DebugLocation(35, 37);
			PushFollow(Follow._formalParameterList_in_functionExpression148);
			formalParameterList21=formalParameterList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, formalParameterList21.Tree);
			DebugLocation(35, 59);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:35:59: ( LT !)*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, false);
				int LA12_1 = input.LA(1);

				if ((LA12_1==LT))
				{
					alt12 = 1;
				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:35:59: LT !
					{
					DebugLocation(35, 59);
					LT22=(IToken)Match(input,LT,Follow._LT_in_functionExpression150); if (state.failed) return retval;

					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }

			DebugLocation(35, 62);
			PushFollow(Follow._functionBody_in_functionExpression154);
			functionBody23=functionBody();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, functionBody23.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("functionExpression", 5);
			LeaveRule("functionExpression", 5);
			LeaveRule_functionExpression();
			if (state.backtracking > 0) { Memoize(input, 5, functionExpression_StartIndex); }

		}
		DebugLocation(36, 1);
		} finally { DebugExitRule(GrammarFileName, "functionExpression"); }
		return retval;

	}
	// $ANTLR end "functionExpression"

	partial void EnterRule_formalParameterList();
	partial void LeaveRule_formalParameterList();
	// $ANTLR start "formalParameterList"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:38:1: formalParameterList : '(' ( ( LT !)* Identifier ( ( LT !)* ',' ( LT !)* Identifier )* )? ( LT !)* ')' ;
	[GrammarRule("formalParameterList")]
	private AstParserRuleReturnScope<object, IToken> formalParameterList()
	{
		EnterRule_formalParameterList();
		EnterRule("formalParameterList", 6);
		TraceIn("formalParameterList", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int formalParameterList_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal24 = default(IToken);
		IToken LT25 = default(IToken);
		IToken Identifier26 = default(IToken);
		IToken LT27 = default(IToken);
		IToken char_literal28 = default(IToken);
		IToken LT29 = default(IToken);
		IToken Identifier30 = default(IToken);
		IToken LT31 = default(IToken);
		IToken char_literal32 = default(IToken);

		object char_literal24_tree = default(object);
		object LT25_tree = default(object);
		object Identifier26_tree = default(object);
		object LT27_tree = default(object);
		object char_literal28_tree = default(object);
		object LT29_tree = default(object);
		object Identifier30_tree = default(object);
		object LT31_tree = default(object);
		object char_literal32_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "formalParameterList");
		DebugLocation(38, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 6)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:39:2: ( '(' ( ( LT !)* Identifier ( ( LT !)* ',' ( LT !)* Identifier )* )? ( LT !)* ')' )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:39:4: '(' ( ( LT !)* Identifier ( ( LT !)* ',' ( LT !)* Identifier )* )? ( LT !)* ')'
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(39, 4);
			char_literal24=(IToken)Match(input,39,Follow._39_in_formalParameterList166); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal24_tree = (object)adaptor.Create(char_literal24);
			adaptor.AddChild(root_0, char_literal24_tree);
			}
			DebugLocation(39, 8);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:39:8: ( ( LT !)* Identifier ( ( LT !)* ',' ( LT !)* Identifier )* )?
			int alt17=2;
			try { DebugEnterSubRule(17);
			try { DebugEnterDecision(17, false);
			try
			{
				alt17 = dfa17.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:39:9: ( LT !)* Identifier ( ( LT !)* ',' ( LT !)* Identifier )*
				{
				DebugLocation(39, 11);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:39:11: ( LT !)*
				try { DebugEnterSubRule(13);
				while (true)
				{
					int alt13=2;
					try { DebugEnterDecision(13, false);
					int LA13_1 = input.LA(1);

					if ((LA13_1==LT))
					{
						alt13 = 1;
					}


					} finally { DebugExitDecision(13); }
					switch ( alt13 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:39:11: LT !
						{
						DebugLocation(39, 11);
						LT25=(IToken)Match(input,LT,Follow._LT_in_formalParameterList169); if (state.failed) return retval;

						}
						break;

					default:
						goto loop13;
					}
				}

				loop13:
					;

				} finally { DebugExitSubRule(13); }

				DebugLocation(39, 14);
				Identifier26=(IToken)Match(input,Identifier,Follow._Identifier_in_formalParameterList173); if (state.failed) return retval;
				if (state.backtracking == 0) {
				Identifier26_tree = (object)adaptor.Create(Identifier26);
				adaptor.AddChild(root_0, Identifier26_tree);
				}
				DebugLocation(39, 25);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:39:25: ( ( LT !)* ',' ( LT !)* Identifier )*
				try { DebugEnterSubRule(16);
				while (true)
				{
					int alt16=2;
					try { DebugEnterDecision(16, false);
					try
					{
						alt16 = dfa16.Predict(input);
					}
					catch (NoViableAltException nvae)
					{
						DebugRecognitionException(nvae);
						throw;
					}
					} finally { DebugExitDecision(16); }
					switch ( alt16 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:39:26: ( LT !)* ',' ( LT !)* Identifier
						{
						DebugLocation(39, 28);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:39:28: ( LT !)*
						try { DebugEnterSubRule(14);
						while (true)
						{
							int alt14=2;
							try { DebugEnterDecision(14, false);
							int LA14_1 = input.LA(1);

							if ((LA14_1==LT))
							{
								alt14 = 1;
							}


							} finally { DebugExitDecision(14); }
							switch ( alt14 )
							{
							case 1:
								DebugEnterAlt(1);
								// C:\\DEVGIT\\typesharp\\TypeScript.g:39:28: LT !
								{
								DebugLocation(39, 28);
								LT27=(IToken)Match(input,LT,Follow._LT_in_formalParameterList176); if (state.failed) return retval;

								}
								break;

							default:
								goto loop14;
							}
						}

						loop14:
							;

						} finally { DebugExitSubRule(14); }

						DebugLocation(39, 31);
						char_literal28=(IToken)Match(input,46,Follow._46_in_formalParameterList180); if (state.failed) return retval;
						if (state.backtracking == 0) {
						char_literal28_tree = (object)adaptor.Create(char_literal28);
						adaptor.AddChild(root_0, char_literal28_tree);
						}
						DebugLocation(39, 37);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:39:37: ( LT !)*
						try { DebugEnterSubRule(15);
						while (true)
						{
							int alt15=2;
							try { DebugEnterDecision(15, false);
							int LA15_1 = input.LA(1);

							if ((LA15_1==LT))
							{
								alt15 = 1;
							}


							} finally { DebugExitDecision(15); }
							switch ( alt15 )
							{
							case 1:
								DebugEnterAlt(1);
								// C:\\DEVGIT\\typesharp\\TypeScript.g:39:37: LT !
								{
								DebugLocation(39, 37);
								LT29=(IToken)Match(input,LT,Follow._LT_in_formalParameterList182); if (state.failed) return retval;

								}
								break;

							default:
								goto loop15;
							}
						}

						loop15:
							;

						} finally { DebugExitSubRule(15); }

						DebugLocation(39, 40);
						Identifier30=(IToken)Match(input,Identifier,Follow._Identifier_in_formalParameterList186); if (state.failed) return retval;
						if (state.backtracking == 0) {
						Identifier30_tree = (object)adaptor.Create(Identifier30);
						adaptor.AddChild(root_0, Identifier30_tree);
						}

						}
						break;

					default:
						goto loop16;
					}
				}

				loop16:
					;

				} finally { DebugExitSubRule(16); }


				}
				break;

			}
			} finally { DebugExitSubRule(17); }

			DebugLocation(39, 57);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:39:57: ( LT !)*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_1 = input.LA(1);

				if ((LA18_1==LT))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:39:57: LT !
					{
					DebugLocation(39, 57);
					LT31=(IToken)Match(input,LT,Follow._LT_in_formalParameterList192); if (state.failed) return retval;

					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }

			DebugLocation(39, 60);
			char_literal32=(IToken)Match(input,40,Follow._40_in_formalParameterList196); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal32_tree = (object)adaptor.Create(char_literal32);
			adaptor.AddChild(root_0, char_literal32_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("formalParameterList", 6);
			LeaveRule("formalParameterList", 6);
			LeaveRule_formalParameterList();
			if (state.backtracking > 0) { Memoize(input, 6, formalParameterList_StartIndex); }

		}
		DebugLocation(40, 1);
		} finally { DebugExitRule(GrammarFileName, "formalParameterList"); }
		return retval;

	}
	// $ANTLR end "formalParameterList"

	partial void EnterRule_functionBody();
	partial void LeaveRule_functionBody();
	// $ANTLR start "functionBody"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:42:1: functionBody : '{' ( LT !)* sourceElements ( LT !)* '}' ;
	[GrammarRule("functionBody")]
	private AstParserRuleReturnScope<object, IToken> functionBody()
	{
		EnterRule_functionBody();
		EnterRule("functionBody", 7);
		TraceIn("functionBody", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int functionBody_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal33 = default(IToken);
		IToken LT34 = default(IToken);
		IToken LT36 = default(IToken);
		IToken char_literal37 = default(IToken);
		AstParserRuleReturnScope<object, IToken> sourceElements35 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal33_tree = default(object);
		object LT34_tree = default(object);
		object LT36_tree = default(object);
		object char_literal37_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "functionBody");
		DebugLocation(42, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 7)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:43:2: ( '{' ( LT !)* sourceElements ( LT !)* '}' )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:43:4: '{' ( LT !)* sourceElements ( LT !)* '}'
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(43, 4);
			char_literal33=(IToken)Match(input,101,Follow._101_in_functionBody207); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal33_tree = (object)adaptor.Create(char_literal33);
			adaptor.AddChild(root_0, char_literal33_tree);
			}
			DebugLocation(43, 10);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:43:10: ( LT !)*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_1 = input.LA(1);

				if ((LA19_1==LT))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:43:10: LT !
					{
					DebugLocation(43, 10);
					LT34=(IToken)Match(input,LT,Follow._LT_in_functionBody209); if (state.failed) return retval;

					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }

			DebugLocation(43, 13);
			PushFollow(Follow._sourceElements_in_functionBody213);
			sourceElements35=sourceElements();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, sourceElements35.Tree);
			DebugLocation(43, 30);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:43:30: ( LT !)*
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=2;
				try { DebugEnterDecision(20, false);
				int LA20_1 = input.LA(1);

				if ((LA20_1==LT))
				{
					alt20 = 1;
				}


				} finally { DebugExitDecision(20); }
				switch ( alt20 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:43:30: LT !
					{
					DebugLocation(43, 30);
					LT36=(IToken)Match(input,LT,Follow._LT_in_functionBody215); if (state.failed) return retval;

					}
					break;

				default:
					goto loop20;
				}
			}

			loop20:
				;

			} finally { DebugExitSubRule(20); }

			DebugLocation(43, 33);
			char_literal37=(IToken)Match(input,105,Follow._105_in_functionBody219); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal37_tree = (object)adaptor.Create(char_literal37);
			adaptor.AddChild(root_0, char_literal37_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("functionBody", 7);
			LeaveRule("functionBody", 7);
			LeaveRule_functionBody();
			if (state.backtracking > 0) { Memoize(input, 7, functionBody_StartIndex); }

		}
		DebugLocation(44, 1);
		} finally { DebugExitRule(GrammarFileName, "functionBody"); }
		return retval;

	}
	// $ANTLR end "functionBody"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();
	// $ANTLR start "statement"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:47:1: statement : ( statementBlock | variableStatement | emptyStatement | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement );
	[GrammarRule("statement")]
	private AstParserRuleReturnScope<object, IToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 8);
		TraceIn("statement", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int statement_StartIndex = input.Index;

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> statementBlock38 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> variableStatement39 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> emptyStatement40 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expressionStatement41 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> ifStatement42 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> iterationStatement43 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> continueStatement44 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> breakStatement45 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> returnStatement46 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> withStatement47 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> labelledStatement48 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> switchStatement49 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> throwStatement50 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> tryStatement51 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(47, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 8)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:48:2: ( statementBlock | variableStatement | emptyStatement | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement )
			int alt21=14;
			try { DebugEnterDecision(21, false);
			switch (input.LA(1))
			{
			case 101:
				{
				int LA21_2 = input.LA(2);

				if ((EvaluatePredicate(synpred21_TypeScript_fragment)))
				{
					alt21 = 1;
				}
				else if ((EvaluatePredicate(synpred24_TypeScript_fragment)))
				{
					alt21 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 21, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 97:
				{
				alt21 = 2;
				}
				break;
			case 54:
				{
				alt21 = 3;
				}
				break;
			case NumericLiteral:
			case StringLiteral:
			case 31:
			case 39:
			case 43:
			case 44:
			case 47:
			case 48:
			case 69:
			case 78:
			case 81:
			case 84:
			case 88:
			case 89:
			case 92:
			case 94:
			case 96:
			case 98:
			case 106:
				{
				alt21 = 4;
				}
				break;
			case Identifier:
				{
				int LA21_2 = input.LA(2);

				if ((EvaluatePredicate(synpred24_TypeScript_fragment)))
				{
					alt21 = 4;
				}
				else if ((EvaluatePredicate(synpred31_TypeScript_fragment)))
				{
					alt21 = 11;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 21, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 85:
				{
				alt21 = 5;
				}
				break;
			case 79:
			case 83:
			case 99:
				{
				alt21 = 6;
				}
				break;
			case 76:
				{
				alt21 = 7;
				}
				break;
			case 73:
				{
				alt21 = 8;
				}
				break;
			case 90:
				{
				alt21 = 9;
				}
				break;
			case 100:
				{
				alt21 = 10;
				}
				break;
			case 91:
				{
				alt21 = 12;
				}
				break;
			case 93:
				{
				alt21 = 13;
				}
				break;
			case 95:
				{
				alt21 = 14;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 21, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:48:4: statementBlock
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(48, 4);
				PushFollow(Follow._statementBlock_in_statement231);
				statementBlock38=statementBlock();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, statementBlock38.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:49:4: variableStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(49, 4);
				PushFollow(Follow._variableStatement_in_statement236);
				variableStatement39=variableStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, variableStatement39.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:50:4: emptyStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(50, 4);
				PushFollow(Follow._emptyStatement_in_statement241);
				emptyStatement40=emptyStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, emptyStatement40.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:51:4: expressionStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(51, 4);
				PushFollow(Follow._expressionStatement_in_statement246);
				expressionStatement41=expressionStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expressionStatement41.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:52:4: ifStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(52, 4);
				PushFollow(Follow._ifStatement_in_statement251);
				ifStatement42=ifStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ifStatement42.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:53:4: iterationStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(53, 4);
				PushFollow(Follow._iterationStatement_in_statement256);
				iterationStatement43=iterationStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, iterationStatement43.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:54:4: continueStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(54, 4);
				PushFollow(Follow._continueStatement_in_statement261);
				continueStatement44=continueStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, continueStatement44.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:55:4: breakStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(55, 4);
				PushFollow(Follow._breakStatement_in_statement266);
				breakStatement45=breakStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, breakStatement45.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:56:4: returnStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(56, 4);
				PushFollow(Follow._returnStatement_in_statement271);
				returnStatement46=returnStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, returnStatement46.Tree);

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:57:4: withStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(57, 4);
				PushFollow(Follow._withStatement_in_statement276);
				withStatement47=withStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, withStatement47.Tree);

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:58:4: labelledStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(58, 4);
				PushFollow(Follow._labelledStatement_in_statement281);
				labelledStatement48=labelledStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, labelledStatement48.Tree);

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:59:4: switchStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(59, 4);
				PushFollow(Follow._switchStatement_in_statement286);
				switchStatement49=switchStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, switchStatement49.Tree);

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:60:4: throwStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(60, 4);
				PushFollow(Follow._throwStatement_in_statement291);
				throwStatement50=throwStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, throwStatement50.Tree);

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:61:4: tryStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(61, 4);
				PushFollow(Follow._tryStatement_in_statement296);
				tryStatement51=tryStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, tryStatement51.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statement", 8);
			LeaveRule("statement", 8);
			LeaveRule_statement();
			if (state.backtracking > 0) { Memoize(input, 8, statement_StartIndex); }

		}
		DebugLocation(62, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_statementBlock();
	partial void LeaveRule_statementBlock();
	// $ANTLR start "statementBlock"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:64:1: statementBlock : '{' ( LT !)* ( statementList )? ( LT !)* '}' ;
	[GrammarRule("statementBlock")]
	private AstParserRuleReturnScope<object, IToken> statementBlock()
	{
		EnterRule_statementBlock();
		EnterRule("statementBlock", 9);
		TraceIn("statementBlock", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int statementBlock_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal52 = default(IToken);
		IToken LT53 = default(IToken);
		IToken LT55 = default(IToken);
		IToken char_literal56 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statementList54 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal52_tree = default(object);
		object LT53_tree = default(object);
		object LT55_tree = default(object);
		object char_literal56_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "statementBlock");
		DebugLocation(64, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 9)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:65:2: ( '{' ( LT !)* ( statementList )? ( LT !)* '}' )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:65:4: '{' ( LT !)* ( statementList )? ( LT !)* '}'
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(65, 4);
			char_literal52=(IToken)Match(input,101,Follow._101_in_statementBlock308); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal52_tree = (object)adaptor.Create(char_literal52);
			adaptor.AddChild(root_0, char_literal52_tree);
			}
			DebugLocation(65, 10);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:65:10: ( LT !)*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				int LA22_1 = input.LA(1);

				if ((LA22_1==LT))
				{
					int LA22_2 = input.LA(2);

					if ((EvaluatePredicate(synpred34_TypeScript_fragment)))
					{
						alt22 = 1;
					}


				}


				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:65:10: LT !
					{
					DebugLocation(65, 10);
					LT53=(IToken)Match(input,LT,Follow._LT_in_statementBlock310); if (state.failed) return retval;

					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }

			DebugLocation(65, 13);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:65:13: ( statementList )?
			int alt23=2;
			try { DebugEnterSubRule(23);
			try { DebugEnterDecision(23, false);
			int LA23_1 = input.LA(1);

			if ((LA23_1==Identifier||LA23_1==NumericLiteral||LA23_1==StringLiteral||LA23_1==31||LA23_1==39||(LA23_1>=43 && LA23_1<=44)||(LA23_1>=47 && LA23_1<=48)||LA23_1==54||LA23_1==69||LA23_1==73||LA23_1==76||(LA23_1>=78 && LA23_1<=79)||LA23_1==81||(LA23_1>=83 && LA23_1<=85)||(LA23_1>=88 && LA23_1<=101)||LA23_1==106))
			{
				alt23 = 1;
			}
			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:65:13: statementList
				{
				DebugLocation(65, 13);
				PushFollow(Follow._statementList_in_statementBlock314);
				statementList54=statementList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, statementList54.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(23); }

			DebugLocation(65, 30);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:65:30: ( LT !)*
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=2;
				try { DebugEnterDecision(24, false);
				int LA24_1 = input.LA(1);

				if ((LA24_1==LT))
				{
					alt24 = 1;
				}


				} finally { DebugExitDecision(24); }
				switch ( alt24 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:65:30: LT !
					{
					DebugLocation(65, 30);
					LT55=(IToken)Match(input,LT,Follow._LT_in_statementBlock317); if (state.failed) return retval;

					}
					break;

				default:
					goto loop24;
				}
			}

			loop24:
				;

			} finally { DebugExitSubRule(24); }

			DebugLocation(65, 33);
			char_literal56=(IToken)Match(input,105,Follow._105_in_statementBlock321); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal56_tree = (object)adaptor.Create(char_literal56);
			adaptor.AddChild(root_0, char_literal56_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statementBlock", 9);
			LeaveRule("statementBlock", 9);
			LeaveRule_statementBlock();
			if (state.backtracking > 0) { Memoize(input, 9, statementBlock_StartIndex); }

		}
		DebugLocation(66, 1);
		} finally { DebugExitRule(GrammarFileName, "statementBlock"); }
		return retval;

	}
	// $ANTLR end "statementBlock"

	partial void EnterRule_statementList();
	partial void LeaveRule_statementList();
	// $ANTLR start "statementList"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:68:1: statementList : statement ( ( LT !)* statement )* ;
	[GrammarRule("statementList")]
	private AstParserRuleReturnScope<object, IToken> statementList()
	{
		EnterRule_statementList();
		EnterRule("statementList", 10);
		TraceIn("statementList", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int statementList_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT58 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statement57 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement59 = default(AstParserRuleReturnScope<object, IToken>);

		object LT58_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "statementList");
		DebugLocation(68, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 10)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:69:2: ( statement ( ( LT !)* statement )* )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:69:4: statement ( ( LT !)* statement )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(69, 4);
			PushFollow(Follow._statement_in_statementList333);
			statement57=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, statement57.Tree);
			DebugLocation(69, 14);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:69:14: ( ( LT !)* statement )*
			try { DebugEnterSubRule(26);
			while (true)
			{
				int alt26=2;
				try { DebugEnterDecision(26, false);
				try
				{
					alt26 = dfa26.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(26); }
				switch ( alt26 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:69:15: ( LT !)* statement
					{
					DebugLocation(69, 17);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:69:17: ( LT !)*
					try { DebugEnterSubRule(25);
					while (true)
					{
						int alt25=2;
						try { DebugEnterDecision(25, false);
						int LA25_1 = input.LA(1);

						if ((LA25_1==LT))
						{
							alt25 = 1;
						}


						} finally { DebugExitDecision(25); }
						switch ( alt25 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:69:17: LT !
							{
							DebugLocation(69, 17);
							LT58=(IToken)Match(input,LT,Follow._LT_in_statementList336); if (state.failed) return retval;

							}
							break;

						default:
							goto loop25;
						}
					}

					loop25:
						;

					} finally { DebugExitSubRule(25); }

					DebugLocation(69, 20);
					PushFollow(Follow._statement_in_statementList340);
					statement59=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, statement59.Tree);

					}
					break;

				default:
					goto loop26;
				}
			}

			loop26:
				;

			} finally { DebugExitSubRule(26); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statementList", 10);
			LeaveRule("statementList", 10);
			LeaveRule_statementList();
			if (state.backtracking > 0) { Memoize(input, 10, statementList_StartIndex); }

		}
		DebugLocation(70, 1);
		} finally { DebugExitRule(GrammarFileName, "statementList"); }
		return retval;

	}
	// $ANTLR end "statementList"

	partial void EnterRule_variableStatement();
	partial void LeaveRule_variableStatement();
	// $ANTLR start "variableStatement"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:72:1: variableStatement : 'var' ( LT !)* variableDeclarationList ( LT | ';' ) !;
	[GrammarRule("variableStatement")]
	private AstParserRuleReturnScope<object, IToken> variableStatement()
	{
		EnterRule_variableStatement();
		EnterRule("variableStatement", 11);
		TraceIn("variableStatement", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int variableStatement_StartIndex = input.Index;

		object root_0 = default(object);

		IToken string_literal60 = default(IToken);
		IToken LT61 = default(IToken);
		IToken set63 = default(IToken);
		AstParserRuleReturnScope<object, IToken> variableDeclarationList62 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal60_tree = default(object);
		object LT61_tree = default(object);
		object set63_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "variableStatement");
		DebugLocation(72, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 11)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:73:2: ( 'var' ( LT !)* variableDeclarationList ( LT | ';' ) !)
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:73:4: 'var' ( LT !)* variableDeclarationList ( LT | ';' ) !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(73, 4);
			string_literal60=(IToken)Match(input,97,Follow._97_in_variableStatement354); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal60_tree = (object)adaptor.Create(string_literal60);
			adaptor.AddChild(root_0, string_literal60_tree);
			}
			DebugLocation(73, 12);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:73:12: ( LT !)*
			try { DebugEnterSubRule(27);
			while (true)
			{
				int alt27=2;
				try { DebugEnterDecision(27, false);
				int LA27_1 = input.LA(1);

				if ((LA27_1==LT))
				{
					alt27 = 1;
				}


				} finally { DebugExitDecision(27); }
				switch ( alt27 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:73:12: LT !
					{
					DebugLocation(73, 12);
					LT61=(IToken)Match(input,LT,Follow._LT_in_variableStatement356); if (state.failed) return retval;

					}
					break;

				default:
					goto loop27;
				}
			}

			loop27:
				;

			} finally { DebugExitSubRule(27); }

			DebugLocation(73, 15);
			PushFollow(Follow._variableDeclarationList_in_variableStatement360);
			variableDeclarationList62=variableDeclarationList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclarationList62.Tree);
			DebugLocation(73, 49);

			set63=(IToken)input.LT(1);
			if (input.LA(1)==LT||input.LA(1)==54)
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableStatement", 11);
			LeaveRule("variableStatement", 11);
			LeaveRule_variableStatement();
			if (state.backtracking > 0) { Memoize(input, 11, variableStatement_StartIndex); }

		}
		DebugLocation(74, 1);
		} finally { DebugExitRule(GrammarFileName, "variableStatement"); }
		return retval;

	}
	// $ANTLR end "variableStatement"

	partial void EnterRule_variableDeclarationList();
	partial void LeaveRule_variableDeclarationList();
	// $ANTLR start "variableDeclarationList"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:76:1: variableDeclarationList : variableDeclaration ( ( LT !)* ',' ( LT !)* variableDeclaration )* ;
	[GrammarRule("variableDeclarationList")]
	private AstParserRuleReturnScope<object, IToken> variableDeclarationList()
	{
		EnterRule_variableDeclarationList();
		EnterRule("variableDeclarationList", 12);
		TraceIn("variableDeclarationList", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int variableDeclarationList_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT65 = default(IToken);
		IToken char_literal66 = default(IToken);
		IToken LT67 = default(IToken);
		AstParserRuleReturnScope<object, IToken> variableDeclaration64 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> variableDeclaration68 = default(AstParserRuleReturnScope<object, IToken>);

		object LT65_tree = default(object);
		object char_literal66_tree = default(object);
		object LT67_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "variableDeclarationList");
		DebugLocation(76, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 12)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:77:2: ( variableDeclaration ( ( LT !)* ',' ( LT !)* variableDeclaration )* )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:77:4: variableDeclaration ( ( LT !)* ',' ( LT !)* variableDeclaration )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(77, 4);
			PushFollow(Follow._variableDeclaration_in_variableDeclarationList381);
			variableDeclaration64=variableDeclaration();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclaration64.Tree);
			DebugLocation(77, 24);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:77:24: ( ( LT !)* ',' ( LT !)* variableDeclaration )*
			try { DebugEnterSubRule(30);
			while (true)
			{
				int alt30=2;
				try { DebugEnterDecision(30, false);
				try
				{
					alt30 = dfa30.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(30); }
				switch ( alt30 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:77:25: ( LT !)* ',' ( LT !)* variableDeclaration
					{
					DebugLocation(77, 27);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:77:27: ( LT !)*
					try { DebugEnterSubRule(28);
					while (true)
					{
						int alt28=2;
						try { DebugEnterDecision(28, false);
						int LA28_1 = input.LA(1);

						if ((LA28_1==LT))
						{
							alt28 = 1;
						}


						} finally { DebugExitDecision(28); }
						switch ( alt28 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:77:27: LT !
							{
							DebugLocation(77, 27);
							LT65=(IToken)Match(input,LT,Follow._LT_in_variableDeclarationList384); if (state.failed) return retval;

							}
							break;

						default:
							goto loop28;
						}
					}

					loop28:
						;

					} finally { DebugExitSubRule(28); }

					DebugLocation(77, 30);
					char_literal66=(IToken)Match(input,46,Follow._46_in_variableDeclarationList388); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal66_tree = (object)adaptor.Create(char_literal66);
					adaptor.AddChild(root_0, char_literal66_tree);
					}
					DebugLocation(77, 36);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:77:36: ( LT !)*
					try { DebugEnterSubRule(29);
					while (true)
					{
						int alt29=2;
						try { DebugEnterDecision(29, false);
						int LA29_1 = input.LA(1);

						if ((LA29_1==LT))
						{
							alt29 = 1;
						}


						} finally { DebugExitDecision(29); }
						switch ( alt29 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:77:36: LT !
							{
							DebugLocation(77, 36);
							LT67=(IToken)Match(input,LT,Follow._LT_in_variableDeclarationList390); if (state.failed) return retval;

							}
							break;

						default:
							goto loop29;
						}
					}

					loop29:
						;

					} finally { DebugExitSubRule(29); }

					DebugLocation(77, 39);
					PushFollow(Follow._variableDeclaration_in_variableDeclarationList394);
					variableDeclaration68=variableDeclaration();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclaration68.Tree);

					}
					break;

				default:
					goto loop30;
				}
			}

			loop30:
				;

			} finally { DebugExitSubRule(30); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableDeclarationList", 12);
			LeaveRule("variableDeclarationList", 12);
			LeaveRule_variableDeclarationList();
			if (state.backtracking > 0) { Memoize(input, 12, variableDeclarationList_StartIndex); }

		}
		DebugLocation(78, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclarationList"); }
		return retval;

	}
	// $ANTLR end "variableDeclarationList"

	partial void EnterRule_variableDeclarationListNoIn();
	partial void LeaveRule_variableDeclarationListNoIn();
	// $ANTLR start "variableDeclarationListNoIn"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:80:1: variableDeclarationListNoIn : variableDeclarationNoIn ( ( LT !)* ',' ( LT !)* variableDeclarationNoIn )* ;
	[GrammarRule("variableDeclarationListNoIn")]
	private AstParserRuleReturnScope<object, IToken> variableDeclarationListNoIn()
	{
		EnterRule_variableDeclarationListNoIn();
		EnterRule("variableDeclarationListNoIn", 13);
		TraceIn("variableDeclarationListNoIn", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int variableDeclarationListNoIn_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT70 = default(IToken);
		IToken char_literal71 = default(IToken);
		IToken LT72 = default(IToken);
		AstParserRuleReturnScope<object, IToken> variableDeclarationNoIn69 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> variableDeclarationNoIn73 = default(AstParserRuleReturnScope<object, IToken>);

		object LT70_tree = default(object);
		object char_literal71_tree = default(object);
		object LT72_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "variableDeclarationListNoIn");
		DebugLocation(80, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 13)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:81:2: ( variableDeclarationNoIn ( ( LT !)* ',' ( LT !)* variableDeclarationNoIn )* )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:81:4: variableDeclarationNoIn ( ( LT !)* ',' ( LT !)* variableDeclarationNoIn )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(81, 4);
			PushFollow(Follow._variableDeclarationNoIn_in_variableDeclarationListNoIn408);
			variableDeclarationNoIn69=variableDeclarationNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclarationNoIn69.Tree);
			DebugLocation(81, 28);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:81:28: ( ( LT !)* ',' ( LT !)* variableDeclarationNoIn )*
			try { DebugEnterSubRule(33);
			while (true)
			{
				int alt33=2;
				try { DebugEnterDecision(33, false);
				try
				{
					alt33 = dfa33.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(33); }
				switch ( alt33 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:81:29: ( LT !)* ',' ( LT !)* variableDeclarationNoIn
					{
					DebugLocation(81, 31);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:81:31: ( LT !)*
					try { DebugEnterSubRule(31);
					while (true)
					{
						int alt31=2;
						try { DebugEnterDecision(31, false);
						int LA31_1 = input.LA(1);

						if ((LA31_1==LT))
						{
							alt31 = 1;
						}


						} finally { DebugExitDecision(31); }
						switch ( alt31 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:81:31: LT !
							{
							DebugLocation(81, 31);
							LT70=(IToken)Match(input,LT,Follow._LT_in_variableDeclarationListNoIn411); if (state.failed) return retval;

							}
							break;

						default:
							goto loop31;
						}
					}

					loop31:
						;

					} finally { DebugExitSubRule(31); }

					DebugLocation(81, 34);
					char_literal71=(IToken)Match(input,46,Follow._46_in_variableDeclarationListNoIn415); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal71_tree = (object)adaptor.Create(char_literal71);
					adaptor.AddChild(root_0, char_literal71_tree);
					}
					DebugLocation(81, 40);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:81:40: ( LT !)*
					try { DebugEnterSubRule(32);
					while (true)
					{
						int alt32=2;
						try { DebugEnterDecision(32, false);
						int LA32_1 = input.LA(1);

						if ((LA32_1==LT))
						{
							alt32 = 1;
						}


						} finally { DebugExitDecision(32); }
						switch ( alt32 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:81:40: LT !
							{
							DebugLocation(81, 40);
							LT72=(IToken)Match(input,LT,Follow._LT_in_variableDeclarationListNoIn417); if (state.failed) return retval;

							}
							break;

						default:
							goto loop32;
						}
					}

					loop32:
						;

					} finally { DebugExitSubRule(32); }

					DebugLocation(81, 43);
					PushFollow(Follow._variableDeclarationNoIn_in_variableDeclarationListNoIn421);
					variableDeclarationNoIn73=variableDeclarationNoIn();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclarationNoIn73.Tree);

					}
					break;

				default:
					goto loop33;
				}
			}

			loop33:
				;

			} finally { DebugExitSubRule(33); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableDeclarationListNoIn", 13);
			LeaveRule("variableDeclarationListNoIn", 13);
			LeaveRule_variableDeclarationListNoIn();
			if (state.backtracking > 0) { Memoize(input, 13, variableDeclarationListNoIn_StartIndex); }

		}
		DebugLocation(82, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclarationListNoIn"); }
		return retval;

	}
	// $ANTLR end "variableDeclarationListNoIn"

	partial void EnterRule_variableDeclaration();
	partial void LeaveRule_variableDeclaration();
	// $ANTLR start "variableDeclaration"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:84:1: variableDeclaration : Identifier ( LT !)* ( initialiser )? ;
	[GrammarRule("variableDeclaration")]
	private AstParserRuleReturnScope<object, IToken> variableDeclaration()
	{
		EnterRule_variableDeclaration();
		EnterRule("variableDeclaration", 14);
		TraceIn("variableDeclaration", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int variableDeclaration_StartIndex = input.Index;

		object root_0 = default(object);

		IToken Identifier74 = default(IToken);
		IToken LT75 = default(IToken);
		AstParserRuleReturnScope<object, IToken> initialiser76 = default(AstParserRuleReturnScope<object, IToken>);

		object Identifier74_tree = default(object);
		object LT75_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "variableDeclaration");
		DebugLocation(84, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 14)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:85:2: ( Identifier ( LT !)* ( initialiser )? )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:85:4: Identifier ( LT !)* ( initialiser )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(85, 4);
			Identifier74=(IToken)Match(input,Identifier,Follow._Identifier_in_variableDeclaration435); if (state.failed) return retval;
			if (state.backtracking == 0) {
			Identifier74_tree = (object)adaptor.Create(Identifier74);
			adaptor.AddChild(root_0, Identifier74_tree);
			}
			DebugLocation(85, 17);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:85:17: ( LT !)*
			try { DebugEnterSubRule(34);
			while (true)
			{
				int alt34=2;
				try { DebugEnterDecision(34, false);
				int LA34_1 = input.LA(1);

				if ((LA34_1==LT))
				{
					int LA34_2 = input.LA(2);

					if ((EvaluatePredicate(synpred47_TypeScript_fragment)))
					{
						alt34 = 1;
					}


				}


				} finally { DebugExitDecision(34); }
				switch ( alt34 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:85:17: LT !
					{
					DebugLocation(85, 17);
					LT75=(IToken)Match(input,LT,Follow._LT_in_variableDeclaration437); if (state.failed) return retval;

					}
					break;

				default:
					goto loop34;
				}
			}

			loop34:
				;

			} finally { DebugExitSubRule(34); }

			DebugLocation(85, 20);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:85:20: ( initialiser )?
			int alt35=2;
			try { DebugEnterSubRule(35);
			try { DebugEnterDecision(35, false);
			int LA35_1 = input.LA(1);

			if ((LA35_1==59))
			{
				alt35 = 1;
			}
			} finally { DebugExitDecision(35); }
			switch (alt35)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:85:20: initialiser
				{
				DebugLocation(85, 20);
				PushFollow(Follow._initialiser_in_variableDeclaration441);
				initialiser76=initialiser();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, initialiser76.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(35); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableDeclaration", 14);
			LeaveRule("variableDeclaration", 14);
			LeaveRule_variableDeclaration();
			if (state.backtracking > 0) { Memoize(input, 14, variableDeclaration_StartIndex); }

		}
		DebugLocation(86, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclaration"); }
		return retval;

	}
	// $ANTLR end "variableDeclaration"

	partial void EnterRule_variableDeclarationNoIn();
	partial void LeaveRule_variableDeclarationNoIn();
	// $ANTLR start "variableDeclarationNoIn"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:88:1: variableDeclarationNoIn : Identifier ( LT !)* ( initialiserNoIn )? ;
	[GrammarRule("variableDeclarationNoIn")]
	private AstParserRuleReturnScope<object, IToken> variableDeclarationNoIn()
	{
		EnterRule_variableDeclarationNoIn();
		EnterRule("variableDeclarationNoIn", 15);
		TraceIn("variableDeclarationNoIn", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int variableDeclarationNoIn_StartIndex = input.Index;

		object root_0 = default(object);

		IToken Identifier77 = default(IToken);
		IToken LT78 = default(IToken);
		AstParserRuleReturnScope<object, IToken> initialiserNoIn79 = default(AstParserRuleReturnScope<object, IToken>);

		object Identifier77_tree = default(object);
		object LT78_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "variableDeclarationNoIn");
		DebugLocation(88, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 15)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:89:2: ( Identifier ( LT !)* ( initialiserNoIn )? )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:89:4: Identifier ( LT !)* ( initialiserNoIn )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(89, 4);
			Identifier77=(IToken)Match(input,Identifier,Follow._Identifier_in_variableDeclarationNoIn454); if (state.failed) return retval;
			if (state.backtracking == 0) {
			Identifier77_tree = (object)adaptor.Create(Identifier77);
			adaptor.AddChild(root_0, Identifier77_tree);
			}
			DebugLocation(89, 17);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:89:17: ( LT !)*
			try { DebugEnterSubRule(36);
			while (true)
			{
				int alt36=2;
				try { DebugEnterDecision(36, false);
				int LA36_1 = input.LA(1);

				if ((LA36_1==LT))
				{
					int LA36_2 = input.LA(2);

					if ((EvaluatePredicate(synpred49_TypeScript_fragment)))
					{
						alt36 = 1;
					}


				}


				} finally { DebugExitDecision(36); }
				switch ( alt36 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:89:17: LT !
					{
					DebugLocation(89, 17);
					LT78=(IToken)Match(input,LT,Follow._LT_in_variableDeclarationNoIn456); if (state.failed) return retval;

					}
					break;

				default:
					goto loop36;
				}
			}

			loop36:
				;

			} finally { DebugExitSubRule(36); }

			DebugLocation(89, 20);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:89:20: ( initialiserNoIn )?
			int alt37=2;
			try { DebugEnterSubRule(37);
			try { DebugEnterDecision(37, false);
			int LA37_1 = input.LA(1);

			if ((LA37_1==59))
			{
				alt37 = 1;
			}
			} finally { DebugExitDecision(37); }
			switch (alt37)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:89:20: initialiserNoIn
				{
				DebugLocation(89, 20);
				PushFollow(Follow._initialiserNoIn_in_variableDeclarationNoIn460);
				initialiserNoIn79=initialiserNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, initialiserNoIn79.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(37); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableDeclarationNoIn", 15);
			LeaveRule("variableDeclarationNoIn", 15);
			LeaveRule_variableDeclarationNoIn();
			if (state.backtracking > 0) { Memoize(input, 15, variableDeclarationNoIn_StartIndex); }

		}
		DebugLocation(90, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclarationNoIn"); }
		return retval;

	}
	// $ANTLR end "variableDeclarationNoIn"

	partial void EnterRule_initialiser();
	partial void LeaveRule_initialiser();
	// $ANTLR start "initialiser"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:92:1: initialiser : '=' ( LT !)* assignmentExpression ;
	[GrammarRule("initialiser")]
	private AstParserRuleReturnScope<object, IToken> initialiser()
	{
		EnterRule_initialiser();
		EnterRule("initialiser", 16);
		TraceIn("initialiser", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int initialiser_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal80 = default(IToken);
		IToken LT81 = default(IToken);
		AstParserRuleReturnScope<object, IToken> assignmentExpression82 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal80_tree = default(object);
		object LT81_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "initialiser");
		DebugLocation(92, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 16)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:93:2: ( '=' ( LT !)* assignmentExpression )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:93:4: '=' ( LT !)* assignmentExpression
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(93, 4);
			char_literal80=(IToken)Match(input,59,Follow._59_in_initialiser473); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal80_tree = (object)adaptor.Create(char_literal80);
			adaptor.AddChild(root_0, char_literal80_tree);
			}
			DebugLocation(93, 10);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:93:10: ( LT !)*
			try { DebugEnterSubRule(38);
			while (true)
			{
				int alt38=2;
				try { DebugEnterDecision(38, false);
				int LA38_1 = input.LA(1);

				if ((LA38_1==LT))
				{
					alt38 = 1;
				}


				} finally { DebugExitDecision(38); }
				switch ( alt38 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:93:10: LT !
					{
					DebugLocation(93, 10);
					LT81=(IToken)Match(input,LT,Follow._LT_in_initialiser475); if (state.failed) return retval;

					}
					break;

				default:
					goto loop38;
				}
			}

			loop38:
				;

			} finally { DebugExitSubRule(38); }

			DebugLocation(93, 13);
			PushFollow(Follow._assignmentExpression_in_initialiser479);
			assignmentExpression82=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression82.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("initialiser", 16);
			LeaveRule("initialiser", 16);
			LeaveRule_initialiser();
			if (state.backtracking > 0) { Memoize(input, 16, initialiser_StartIndex); }

		}
		DebugLocation(94, 1);
		} finally { DebugExitRule(GrammarFileName, "initialiser"); }
		return retval;

	}
	// $ANTLR end "initialiser"

	partial void EnterRule_initialiserNoIn();
	partial void LeaveRule_initialiserNoIn();
	// $ANTLR start "initialiserNoIn"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:96:1: initialiserNoIn : '=' ( LT !)* assignmentExpressionNoIn ;
	[GrammarRule("initialiserNoIn")]
	private AstParserRuleReturnScope<object, IToken> initialiserNoIn()
	{
		EnterRule_initialiserNoIn();
		EnterRule("initialiserNoIn", 17);
		TraceIn("initialiserNoIn", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int initialiserNoIn_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal83 = default(IToken);
		IToken LT84 = default(IToken);
		AstParserRuleReturnScope<object, IToken> assignmentExpressionNoIn85 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal83_tree = default(object);
		object LT84_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "initialiserNoIn");
		DebugLocation(96, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 17)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:97:2: ( '=' ( LT !)* assignmentExpressionNoIn )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:97:4: '=' ( LT !)* assignmentExpressionNoIn
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(97, 4);
			char_literal83=(IToken)Match(input,59,Follow._59_in_initialiserNoIn491); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal83_tree = (object)adaptor.Create(char_literal83);
			adaptor.AddChild(root_0, char_literal83_tree);
			}
			DebugLocation(97, 10);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:97:10: ( LT !)*
			try { DebugEnterSubRule(39);
			while (true)
			{
				int alt39=2;
				try { DebugEnterDecision(39, false);
				int LA39_1 = input.LA(1);

				if ((LA39_1==LT))
				{
					alt39 = 1;
				}


				} finally { DebugExitDecision(39); }
				switch ( alt39 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:97:10: LT !
					{
					DebugLocation(97, 10);
					LT84=(IToken)Match(input,LT,Follow._LT_in_initialiserNoIn493); if (state.failed) return retval;

					}
					break;

				default:
					goto loop39;
				}
			}

			loop39:
				;

			} finally { DebugExitSubRule(39); }

			DebugLocation(97, 13);
			PushFollow(Follow._assignmentExpressionNoIn_in_initialiserNoIn497);
			assignmentExpressionNoIn85=assignmentExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpressionNoIn85.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("initialiserNoIn", 17);
			LeaveRule("initialiserNoIn", 17);
			LeaveRule_initialiserNoIn();
			if (state.backtracking > 0) { Memoize(input, 17, initialiserNoIn_StartIndex); }

		}
		DebugLocation(98, 1);
		} finally { DebugExitRule(GrammarFileName, "initialiserNoIn"); }
		return retval;

	}
	// $ANTLR end "initialiserNoIn"

	partial void EnterRule_emptyStatement();
	partial void LeaveRule_emptyStatement();
	// $ANTLR start "emptyStatement"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:100:1: emptyStatement : ';' ;
	[GrammarRule("emptyStatement")]
	private AstParserRuleReturnScope<object, IToken> emptyStatement()
	{
		EnterRule_emptyStatement();
		EnterRule("emptyStatement", 18);
		TraceIn("emptyStatement", 18);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int emptyStatement_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal86 = default(IToken);

		object char_literal86_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "emptyStatement");
		DebugLocation(100, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 18)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:101:2: ( ';' )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:101:4: ';'
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(101, 4);
			char_literal86=(IToken)Match(input,54,Follow._54_in_emptyStatement509); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal86_tree = (object)adaptor.Create(char_literal86);
			adaptor.AddChild(root_0, char_literal86_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("emptyStatement", 18);
			LeaveRule("emptyStatement", 18);
			LeaveRule_emptyStatement();
			if (state.backtracking > 0) { Memoize(input, 18, emptyStatement_StartIndex); }

		}
		DebugLocation(102, 1);
		} finally { DebugExitRule(GrammarFileName, "emptyStatement"); }
		return retval;

	}
	// $ANTLR end "emptyStatement"

	partial void EnterRule_expressionStatement();
	partial void LeaveRule_expressionStatement();
	// $ANTLR start "expressionStatement"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:104:1: expressionStatement : expression ( LT | ';' ) !;
	[GrammarRule("expressionStatement")]
	private AstParserRuleReturnScope<object, IToken> expressionStatement()
	{
		EnterRule_expressionStatement();
		EnterRule("expressionStatement", 19);
		TraceIn("expressionStatement", 19);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int expressionStatement_StartIndex = input.Index;

		object root_0 = default(object);

		IToken set88 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression87 = default(AstParserRuleReturnScope<object, IToken>);

		object set88_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "expressionStatement");
		DebugLocation(104, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 19)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:105:2: ( expression ( LT | ';' ) !)
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:105:4: expression ( LT | ';' ) !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(105, 4);
			PushFollow(Follow._expression_in_expressionStatement521);
			expression87=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression87.Tree);
			DebugLocation(105, 25);

			set88=(IToken)input.LT(1);
			if (input.LA(1)==LT||input.LA(1)==54)
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expressionStatement", 19);
			LeaveRule("expressionStatement", 19);
			LeaveRule_expressionStatement();
			if (state.backtracking > 0) { Memoize(input, 19, expressionStatement_StartIndex); }

		}
		DebugLocation(106, 1);
		} finally { DebugExitRule(GrammarFileName, "expressionStatement"); }
		return retval;

	}
	// $ANTLR end "expressionStatement"

	partial void EnterRule_ifStatement();
	partial void LeaveRule_ifStatement();
	// $ANTLR start "ifStatement"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:108:1: ifStatement : 'if' ( LT !)* '(' ( LT !)* expression ( LT !)* ')' ( LT !)* statement ( ( LT !)* 'else' ( LT !)* statement )? ;
	[GrammarRule("ifStatement")]
	private AstParserRuleReturnScope<object, IToken> ifStatement()
	{
		EnterRule_ifStatement();
		EnterRule("ifStatement", 20);
		TraceIn("ifStatement", 20);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int ifStatement_StartIndex = input.Index;

		object root_0 = default(object);

		IToken string_literal89 = default(IToken);
		IToken LT90 = default(IToken);
		IToken char_literal91 = default(IToken);
		IToken LT92 = default(IToken);
		IToken LT94 = default(IToken);
		IToken char_literal95 = default(IToken);
		IToken LT96 = default(IToken);
		IToken LT98 = default(IToken);
		IToken string_literal99 = default(IToken);
		IToken LT100 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression93 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement97 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement101 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal89_tree = default(object);
		object LT90_tree = default(object);
		object char_literal91_tree = default(object);
		object LT92_tree = default(object);
		object LT94_tree = default(object);
		object char_literal95_tree = default(object);
		object LT96_tree = default(object);
		object LT98_tree = default(object);
		object string_literal99_tree = default(object);
		object LT100_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "ifStatement");
		DebugLocation(108, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 20)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:109:2: ( 'if' ( LT !)* '(' ( LT !)* expression ( LT !)* ')' ( LT !)* statement ( ( LT !)* 'else' ( LT !)* statement )? )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:109:4: 'if' ( LT !)* '(' ( LT !)* expression ( LT !)* ')' ( LT !)* statement ( ( LT !)* 'else' ( LT !)* statement )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(109, 4);
			string_literal89=(IToken)Match(input,85,Follow._85_in_ifStatement542); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal89_tree = (object)adaptor.Create(string_literal89);
			adaptor.AddChild(root_0, string_literal89_tree);
			}
			DebugLocation(109, 11);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:109:11: ( LT !)*
			try { DebugEnterSubRule(40);
			while (true)
			{
				int alt40=2;
				try { DebugEnterDecision(40, false);
				int LA40_1 = input.LA(1);

				if ((LA40_1==LT))
				{
					alt40 = 1;
				}


				} finally { DebugExitDecision(40); }
				switch ( alt40 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:109:11: LT !
					{
					DebugLocation(109, 11);
					LT90=(IToken)Match(input,LT,Follow._LT_in_ifStatement544); if (state.failed) return retval;

					}
					break;

				default:
					goto loop40;
				}
			}

			loop40:
				;

			} finally { DebugExitSubRule(40); }

			DebugLocation(109, 14);
			char_literal91=(IToken)Match(input,39,Follow._39_in_ifStatement548); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal91_tree = (object)adaptor.Create(char_literal91);
			adaptor.AddChild(root_0, char_literal91_tree);
			}
			DebugLocation(109, 20);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:109:20: ( LT !)*
			try { DebugEnterSubRule(41);
			while (true)
			{
				int alt41=2;
				try { DebugEnterDecision(41, false);
				int LA41_1 = input.LA(1);

				if ((LA41_1==LT))
				{
					alt41 = 1;
				}


				} finally { DebugExitDecision(41); }
				switch ( alt41 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:109:20: LT !
					{
					DebugLocation(109, 20);
					LT92=(IToken)Match(input,LT,Follow._LT_in_ifStatement550); if (state.failed) return retval;

					}
					break;

				default:
					goto loop41;
				}
			}

			loop41:
				;

			} finally { DebugExitSubRule(41); }

			DebugLocation(109, 23);
			PushFollow(Follow._expression_in_ifStatement554);
			expression93=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression93.Tree);
			DebugLocation(109, 36);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:109:36: ( LT !)*
			try { DebugEnterSubRule(42);
			while (true)
			{
				int alt42=2;
				try { DebugEnterDecision(42, false);
				int LA42_1 = input.LA(1);

				if ((LA42_1==LT))
				{
					alt42 = 1;
				}


				} finally { DebugExitDecision(42); }
				switch ( alt42 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:109:36: LT !
					{
					DebugLocation(109, 36);
					LT94=(IToken)Match(input,LT,Follow._LT_in_ifStatement556); if (state.failed) return retval;

					}
					break;

				default:
					goto loop42;
				}
			}

			loop42:
				;

			} finally { DebugExitSubRule(42); }

			DebugLocation(109, 39);
			char_literal95=(IToken)Match(input,40,Follow._40_in_ifStatement560); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal95_tree = (object)adaptor.Create(char_literal95);
			adaptor.AddChild(root_0, char_literal95_tree);
			}
			DebugLocation(109, 45);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:109:45: ( LT !)*
			try { DebugEnterSubRule(43);
			while (true)
			{
				int alt43=2;
				try { DebugEnterDecision(43, false);
				int LA43_1 = input.LA(1);

				if ((LA43_1==LT))
				{
					alt43 = 1;
				}


				} finally { DebugExitDecision(43); }
				switch ( alt43 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:109:45: LT !
					{
					DebugLocation(109, 45);
					LT96=(IToken)Match(input,LT,Follow._LT_in_ifStatement562); if (state.failed) return retval;

					}
					break;

				default:
					goto loop43;
				}
			}

			loop43:
				;

			} finally { DebugExitSubRule(43); }

			DebugLocation(109, 48);
			PushFollow(Follow._statement_in_ifStatement566);
			statement97=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, statement97.Tree);
			DebugLocation(109, 58);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:109:58: ( ( LT !)* 'else' ( LT !)* statement )?
			int alt46=2;
			try { DebugEnterSubRule(46);
			try { DebugEnterDecision(46, false);
			int LA46_1 = input.LA(1);

			if ((LA46_1==LT))
			{
				int LA46_2 = input.LA(2);

				if ((EvaluatePredicate(synpred60_TypeScript_fragment)))
				{
					alt46 = 1;
				}
			}
			else if ((LA46_1==80))
			{
				int LA46_2 = input.LA(2);

				if ((EvaluatePredicate(synpred60_TypeScript_fragment)))
				{
					alt46 = 1;
				}
			}
			} finally { DebugExitDecision(46); }
			switch (alt46)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:109:59: ( LT !)* 'else' ( LT !)* statement
				{
				DebugLocation(109, 61);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:109:61: ( LT !)*
				try { DebugEnterSubRule(44);
				while (true)
				{
					int alt44=2;
					try { DebugEnterDecision(44, false);
					int LA44_1 = input.LA(1);

					if ((LA44_1==LT))
					{
						alt44 = 1;
					}


					} finally { DebugExitDecision(44); }
					switch ( alt44 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:109:61: LT !
						{
						DebugLocation(109, 61);
						LT98=(IToken)Match(input,LT,Follow._LT_in_ifStatement569); if (state.failed) return retval;

						}
						break;

					default:
						goto loop44;
					}
				}

				loop44:
					;

				} finally { DebugExitSubRule(44); }

				DebugLocation(109, 64);
				string_literal99=(IToken)Match(input,80,Follow._80_in_ifStatement573); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal99_tree = (object)adaptor.Create(string_literal99);
				adaptor.AddChild(root_0, string_literal99_tree);
				}
				DebugLocation(109, 73);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:109:73: ( LT !)*
				try { DebugEnterSubRule(45);
				while (true)
				{
					int alt45=2;
					try { DebugEnterDecision(45, false);
					int LA45_1 = input.LA(1);

					if ((LA45_1==LT))
					{
						alt45 = 1;
					}


					} finally { DebugExitDecision(45); }
					switch ( alt45 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:109:73: LT !
						{
						DebugLocation(109, 73);
						LT100=(IToken)Match(input,LT,Follow._LT_in_ifStatement575); if (state.failed) return retval;

						}
						break;

					default:
						goto loop45;
					}
				}

				loop45:
					;

				} finally { DebugExitSubRule(45); }

				DebugLocation(109, 76);
				PushFollow(Follow._statement_in_ifStatement579);
				statement101=statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, statement101.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(46); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ifStatement", 20);
			LeaveRule("ifStatement", 20);
			LeaveRule_ifStatement();
			if (state.backtracking > 0) { Memoize(input, 20, ifStatement_StartIndex); }

		}
		DebugLocation(110, 1);
		} finally { DebugExitRule(GrammarFileName, "ifStatement"); }
		return retval;

	}
	// $ANTLR end "ifStatement"

	partial void EnterRule_iterationStatement();
	partial void LeaveRule_iterationStatement();
	// $ANTLR start "iterationStatement"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:112:1: iterationStatement : ( doWhileStatement | whileStatement | forStatement | forInStatement );
	[GrammarRule("iterationStatement")]
	private AstParserRuleReturnScope<object, IToken> iterationStatement()
	{
		EnterRule_iterationStatement();
		EnterRule("iterationStatement", 21);
		TraceIn("iterationStatement", 21);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int iterationStatement_StartIndex = input.Index;

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> doWhileStatement102 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> whileStatement103 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> forStatement104 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> forInStatement105 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "iterationStatement");
		DebugLocation(112, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 21)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:113:2: ( doWhileStatement | whileStatement | forStatement | forInStatement )
			int alt47=4;
			try { DebugEnterDecision(47, false);
			switch (input.LA(1))
			{
			case 79:
				{
				alt47 = 1;
				}
				break;
			case 99:
				{
				alt47 = 2;
				}
				break;
			case 83:
				{
				int LA47_2 = input.LA(2);

				if ((EvaluatePredicate(synpred63_TypeScript_fragment)))
				{
					alt47 = 3;
				}
				else if ((true))
				{
					alt47 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 47, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 47, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(47); }
			switch (alt47)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:113:4: doWhileStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(113, 4);
				PushFollow(Follow._doWhileStatement_in_iterationStatement593);
				doWhileStatement102=doWhileStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, doWhileStatement102.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:114:4: whileStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(114, 4);
				PushFollow(Follow._whileStatement_in_iterationStatement598);
				whileStatement103=whileStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, whileStatement103.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:115:4: forStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(115, 4);
				PushFollow(Follow._forStatement_in_iterationStatement603);
				forStatement104=forStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, forStatement104.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:116:4: forInStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(116, 4);
				PushFollow(Follow._forInStatement_in_iterationStatement608);
				forInStatement105=forInStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, forInStatement105.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("iterationStatement", 21);
			LeaveRule("iterationStatement", 21);
			LeaveRule_iterationStatement();
			if (state.backtracking > 0) { Memoize(input, 21, iterationStatement_StartIndex); }

		}
		DebugLocation(117, 1);
		} finally { DebugExitRule(GrammarFileName, "iterationStatement"); }
		return retval;

	}
	// $ANTLR end "iterationStatement"

	partial void EnterRule_doWhileStatement();
	partial void LeaveRule_doWhileStatement();
	// $ANTLR start "doWhileStatement"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:119:1: doWhileStatement : 'do' ( LT !)* statement ( LT !)* 'while' ( LT !)* '(' expression ')' ( LT | ';' ) !;
	[GrammarRule("doWhileStatement")]
	private AstParserRuleReturnScope<object, IToken> doWhileStatement()
	{
		EnterRule_doWhileStatement();
		EnterRule("doWhileStatement", 22);
		TraceIn("doWhileStatement", 22);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int doWhileStatement_StartIndex = input.Index;

		object root_0 = default(object);

		IToken string_literal106 = default(IToken);
		IToken LT107 = default(IToken);
		IToken LT109 = default(IToken);
		IToken string_literal110 = default(IToken);
		IToken LT111 = default(IToken);
		IToken char_literal112 = default(IToken);
		IToken char_literal114 = default(IToken);
		IToken set115 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statement108 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression113 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal106_tree = default(object);
		object LT107_tree = default(object);
		object LT109_tree = default(object);
		object string_literal110_tree = default(object);
		object LT111_tree = default(object);
		object char_literal112_tree = default(object);
		object char_literal114_tree = default(object);
		object set115_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "doWhileStatement");
		DebugLocation(119, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 22)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:120:2: ( 'do' ( LT !)* statement ( LT !)* 'while' ( LT !)* '(' expression ')' ( LT | ';' ) !)
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:120:4: 'do' ( LT !)* statement ( LT !)* 'while' ( LT !)* '(' expression ')' ( LT | ';' ) !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(120, 4);
			string_literal106=(IToken)Match(input,79,Follow._79_in_doWhileStatement620); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal106_tree = (object)adaptor.Create(string_literal106);
			adaptor.AddChild(root_0, string_literal106_tree);
			}
			DebugLocation(120, 11);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:120:11: ( LT !)*
			try { DebugEnterSubRule(48);
			while (true)
			{
				int alt48=2;
				try { DebugEnterDecision(48, false);
				int LA48_1 = input.LA(1);

				if ((LA48_1==LT))
				{
					alt48 = 1;
				}


				} finally { DebugExitDecision(48); }
				switch ( alt48 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:120:11: LT !
					{
					DebugLocation(120, 11);
					LT107=(IToken)Match(input,LT,Follow._LT_in_doWhileStatement622); if (state.failed) return retval;

					}
					break;

				default:
					goto loop48;
				}
			}

			loop48:
				;

			} finally { DebugExitSubRule(48); }

			DebugLocation(120, 14);
			PushFollow(Follow._statement_in_doWhileStatement626);
			statement108=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, statement108.Tree);
			DebugLocation(120, 26);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:120:26: ( LT !)*
			try { DebugEnterSubRule(49);
			while (true)
			{
				int alt49=2;
				try { DebugEnterDecision(49, false);
				int LA49_1 = input.LA(1);

				if ((LA49_1==LT))
				{
					alt49 = 1;
				}


				} finally { DebugExitDecision(49); }
				switch ( alt49 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:120:26: LT !
					{
					DebugLocation(120, 26);
					LT109=(IToken)Match(input,LT,Follow._LT_in_doWhileStatement628); if (state.failed) return retval;

					}
					break;

				default:
					goto loop49;
				}
			}

			loop49:
				;

			} finally { DebugExitSubRule(49); }

			DebugLocation(120, 29);
			string_literal110=(IToken)Match(input,99,Follow._99_in_doWhileStatement632); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal110_tree = (object)adaptor.Create(string_literal110);
			adaptor.AddChild(root_0, string_literal110_tree);
			}
			DebugLocation(120, 39);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:120:39: ( LT !)*
			try { DebugEnterSubRule(50);
			while (true)
			{
				int alt50=2;
				try { DebugEnterDecision(50, false);
				int LA50_1 = input.LA(1);

				if ((LA50_1==LT))
				{
					alt50 = 1;
				}


				} finally { DebugExitDecision(50); }
				switch ( alt50 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:120:39: LT !
					{
					DebugLocation(120, 39);
					LT111=(IToken)Match(input,LT,Follow._LT_in_doWhileStatement634); if (state.failed) return retval;

					}
					break;

				default:
					goto loop50;
				}
			}

			loop50:
				;

			} finally { DebugExitSubRule(50); }

			DebugLocation(120, 42);
			char_literal112=(IToken)Match(input,39,Follow._39_in_doWhileStatement638); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal112_tree = (object)adaptor.Create(char_literal112);
			adaptor.AddChild(root_0, char_literal112_tree);
			}
			DebugLocation(120, 46);
			PushFollow(Follow._expression_in_doWhileStatement640);
			expression113=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression113.Tree);
			DebugLocation(120, 57);
			char_literal114=(IToken)Match(input,40,Follow._40_in_doWhileStatement642); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal114_tree = (object)adaptor.Create(char_literal114);
			adaptor.AddChild(root_0, char_literal114_tree);
			}
			DebugLocation(120, 71);

			set115=(IToken)input.LT(1);
			if (input.LA(1)==LT||input.LA(1)==54)
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("doWhileStatement", 22);
			LeaveRule("doWhileStatement", 22);
			LeaveRule_doWhileStatement();
			if (state.backtracking > 0) { Memoize(input, 22, doWhileStatement_StartIndex); }

		}
		DebugLocation(121, 1);
		} finally { DebugExitRule(GrammarFileName, "doWhileStatement"); }
		return retval;

	}
	// $ANTLR end "doWhileStatement"

	partial void EnterRule_whileStatement();
	partial void LeaveRule_whileStatement();
	// $ANTLR start "whileStatement"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:123:1: whileStatement : 'while' ( LT !)* '(' ( LT !)* expression ( LT !)* ')' ( LT !)* statement ;
	[GrammarRule("whileStatement")]
	private AstParserRuleReturnScope<object, IToken> whileStatement()
	{
		EnterRule_whileStatement();
		EnterRule("whileStatement", 23);
		TraceIn("whileStatement", 23);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int whileStatement_StartIndex = input.Index;

		object root_0 = default(object);

		IToken string_literal116 = default(IToken);
		IToken LT117 = default(IToken);
		IToken char_literal118 = default(IToken);
		IToken LT119 = default(IToken);
		IToken LT121 = default(IToken);
		IToken char_literal122 = default(IToken);
		IToken LT123 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression120 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement124 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal116_tree = default(object);
		object LT117_tree = default(object);
		object char_literal118_tree = default(object);
		object LT119_tree = default(object);
		object LT121_tree = default(object);
		object char_literal122_tree = default(object);
		object LT123_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "whileStatement");
		DebugLocation(123, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 23)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:124:2: ( 'while' ( LT !)* '(' ( LT !)* expression ( LT !)* ')' ( LT !)* statement )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:124:4: 'while' ( LT !)* '(' ( LT !)* expression ( LT !)* ')' ( LT !)* statement
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(124, 4);
			string_literal116=(IToken)Match(input,99,Follow._99_in_whileStatement663); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal116_tree = (object)adaptor.Create(string_literal116);
			adaptor.AddChild(root_0, string_literal116_tree);
			}
			DebugLocation(124, 14);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:124:14: ( LT !)*
			try { DebugEnterSubRule(51);
			while (true)
			{
				int alt51=2;
				try { DebugEnterDecision(51, false);
				int LA51_1 = input.LA(1);

				if ((LA51_1==LT))
				{
					alt51 = 1;
				}


				} finally { DebugExitDecision(51); }
				switch ( alt51 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:124:14: LT !
					{
					DebugLocation(124, 14);
					LT117=(IToken)Match(input,LT,Follow._LT_in_whileStatement665); if (state.failed) return retval;

					}
					break;

				default:
					goto loop51;
				}
			}

			loop51:
				;

			} finally { DebugExitSubRule(51); }

			DebugLocation(124, 17);
			char_literal118=(IToken)Match(input,39,Follow._39_in_whileStatement669); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal118_tree = (object)adaptor.Create(char_literal118);
			adaptor.AddChild(root_0, char_literal118_tree);
			}
			DebugLocation(124, 23);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:124:23: ( LT !)*
			try { DebugEnterSubRule(52);
			while (true)
			{
				int alt52=2;
				try { DebugEnterDecision(52, false);
				int LA52_1 = input.LA(1);

				if ((LA52_1==LT))
				{
					alt52 = 1;
				}


				} finally { DebugExitDecision(52); }
				switch ( alt52 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:124:23: LT !
					{
					DebugLocation(124, 23);
					LT119=(IToken)Match(input,LT,Follow._LT_in_whileStatement671); if (state.failed) return retval;

					}
					break;

				default:
					goto loop52;
				}
			}

			loop52:
				;

			} finally { DebugExitSubRule(52); }

			DebugLocation(124, 26);
			PushFollow(Follow._expression_in_whileStatement675);
			expression120=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression120.Tree);
			DebugLocation(124, 39);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:124:39: ( LT !)*
			try { DebugEnterSubRule(53);
			while (true)
			{
				int alt53=2;
				try { DebugEnterDecision(53, false);
				int LA53_1 = input.LA(1);

				if ((LA53_1==LT))
				{
					alt53 = 1;
				}


				} finally { DebugExitDecision(53); }
				switch ( alt53 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:124:39: LT !
					{
					DebugLocation(124, 39);
					LT121=(IToken)Match(input,LT,Follow._LT_in_whileStatement677); if (state.failed) return retval;

					}
					break;

				default:
					goto loop53;
				}
			}

			loop53:
				;

			} finally { DebugExitSubRule(53); }

			DebugLocation(124, 42);
			char_literal122=(IToken)Match(input,40,Follow._40_in_whileStatement681); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal122_tree = (object)adaptor.Create(char_literal122);
			adaptor.AddChild(root_0, char_literal122_tree);
			}
			DebugLocation(124, 48);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:124:48: ( LT !)*
			try { DebugEnterSubRule(54);
			while (true)
			{
				int alt54=2;
				try { DebugEnterDecision(54, false);
				int LA54_1 = input.LA(1);

				if ((LA54_1==LT))
				{
					alt54 = 1;
				}


				} finally { DebugExitDecision(54); }
				switch ( alt54 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:124:48: LT !
					{
					DebugLocation(124, 48);
					LT123=(IToken)Match(input,LT,Follow._LT_in_whileStatement683); if (state.failed) return retval;

					}
					break;

				default:
					goto loop54;
				}
			}

			loop54:
				;

			} finally { DebugExitSubRule(54); }

			DebugLocation(124, 51);
			PushFollow(Follow._statement_in_whileStatement687);
			statement124=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, statement124.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whileStatement", 23);
			LeaveRule("whileStatement", 23);
			LeaveRule_whileStatement();
			if (state.backtracking > 0) { Memoize(input, 23, whileStatement_StartIndex); }

		}
		DebugLocation(125, 1);
		} finally { DebugExitRule(GrammarFileName, "whileStatement"); }
		return retval;

	}
	// $ANTLR end "whileStatement"

	partial void EnterRule_forStatement();
	partial void LeaveRule_forStatement();
	// $ANTLR start "forStatement"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:127:1: forStatement : 'for' ( LT !)* '(' ( ( LT !)* forStatementInitialiserPart )? ( LT !)* ';' ( ( LT !)* expression )? ( LT !)* ';' ( ( LT !)* expression )? ( LT !)* ')' ( LT !)* statement ;
	[GrammarRule("forStatement")]
	private AstParserRuleReturnScope<object, IToken> forStatement()
	{
		EnterRule_forStatement();
		EnterRule("forStatement", 24);
		TraceIn("forStatement", 24);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int forStatement_StartIndex = input.Index;

		object root_0 = default(object);

		IToken string_literal125 = default(IToken);
		IToken LT126 = default(IToken);
		IToken char_literal127 = default(IToken);
		IToken LT128 = default(IToken);
		IToken LT130 = default(IToken);
		IToken char_literal131 = default(IToken);
		IToken LT132 = default(IToken);
		IToken LT134 = default(IToken);
		IToken char_literal135 = default(IToken);
		IToken LT136 = default(IToken);
		IToken LT138 = default(IToken);
		IToken char_literal139 = default(IToken);
		IToken LT140 = default(IToken);
		AstParserRuleReturnScope<object, IToken> forStatementInitialiserPart129 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression133 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression137 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement141 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal125_tree = default(object);
		object LT126_tree = default(object);
		object char_literal127_tree = default(object);
		object LT128_tree = default(object);
		object LT130_tree = default(object);
		object char_literal131_tree = default(object);
		object LT132_tree = default(object);
		object LT134_tree = default(object);
		object char_literal135_tree = default(object);
		object LT136_tree = default(object);
		object LT138_tree = default(object);
		object char_literal139_tree = default(object);
		object LT140_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "forStatement");
		DebugLocation(127, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 24)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:128:2: ( 'for' ( LT !)* '(' ( ( LT !)* forStatementInitialiserPart )? ( LT !)* ';' ( ( LT !)* expression )? ( LT !)* ';' ( ( LT !)* expression )? ( LT !)* ')' ( LT !)* statement )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:128:4: 'for' ( LT !)* '(' ( ( LT !)* forStatementInitialiserPart )? ( LT !)* ';' ( ( LT !)* expression )? ( LT !)* ';' ( ( LT !)* expression )? ( LT !)* ')' ( LT !)* statement
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(128, 4);
			string_literal125=(IToken)Match(input,83,Follow._83_in_forStatement699); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal125_tree = (object)adaptor.Create(string_literal125);
			adaptor.AddChild(root_0, string_literal125_tree);
			}
			DebugLocation(128, 12);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:128:12: ( LT !)*
			try { DebugEnterSubRule(55);
			while (true)
			{
				int alt55=2;
				try { DebugEnterDecision(55, false);
				int LA55_1 = input.LA(1);

				if ((LA55_1==LT))
				{
					alt55 = 1;
				}


				} finally { DebugExitDecision(55); }
				switch ( alt55 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:128:12: LT !
					{
					DebugLocation(128, 12);
					LT126=(IToken)Match(input,LT,Follow._LT_in_forStatement701); if (state.failed) return retval;

					}
					break;

				default:
					goto loop55;
				}
			}

			loop55:
				;

			} finally { DebugExitSubRule(55); }

			DebugLocation(128, 15);
			char_literal127=(IToken)Match(input,39,Follow._39_in_forStatement705); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal127_tree = (object)adaptor.Create(char_literal127);
			adaptor.AddChild(root_0, char_literal127_tree);
			}
			DebugLocation(128, 19);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:128:19: ( ( LT !)* forStatementInitialiserPart )?
			int alt57=2;
			try { DebugEnterSubRule(57);
			try { DebugEnterDecision(57, false);
			try
			{
				alt57 = dfa57.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(57); }
			switch (alt57)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:128:20: ( LT !)* forStatementInitialiserPart
				{
				DebugLocation(128, 22);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:128:22: ( LT !)*
				try { DebugEnterSubRule(56);
				while (true)
				{
					int alt56=2;
					try { DebugEnterDecision(56, false);
					int LA56_1 = input.LA(1);

					if ((LA56_1==LT))
					{
						alt56 = 1;
					}


					} finally { DebugExitDecision(56); }
					switch ( alt56 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:128:22: LT !
						{
						DebugLocation(128, 22);
						LT128=(IToken)Match(input,LT,Follow._LT_in_forStatement708); if (state.failed) return retval;

						}
						break;

					default:
						goto loop56;
					}
				}

				loop56:
					;

				} finally { DebugExitSubRule(56); }

				DebugLocation(128, 25);
				PushFollow(Follow._forStatementInitialiserPart_in_forStatement712);
				forStatementInitialiserPart129=forStatementInitialiserPart();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, forStatementInitialiserPart129.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(57); }

			DebugLocation(128, 57);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:128:57: ( LT !)*
			try { DebugEnterSubRule(58);
			while (true)
			{
				int alt58=2;
				try { DebugEnterDecision(58, false);
				int LA58_1 = input.LA(1);

				if ((LA58_1==LT))
				{
					alt58 = 1;
				}


				} finally { DebugExitDecision(58); }
				switch ( alt58 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:128:57: LT !
					{
					DebugLocation(128, 57);
					LT130=(IToken)Match(input,LT,Follow._LT_in_forStatement716); if (state.failed) return retval;

					}
					break;

				default:
					goto loop58;
				}
			}

			loop58:
				;

			} finally { DebugExitSubRule(58); }

			DebugLocation(128, 60);
			char_literal131=(IToken)Match(input,54,Follow._54_in_forStatement720); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal131_tree = (object)adaptor.Create(char_literal131);
			adaptor.AddChild(root_0, char_literal131_tree);
			}
			DebugLocation(128, 64);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:128:64: ( ( LT !)* expression )?
			int alt60=2;
			try { DebugEnterSubRule(60);
			try { DebugEnterDecision(60, false);
			try
			{
				alt60 = dfa60.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(60); }
			switch (alt60)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:128:65: ( LT !)* expression
				{
				DebugLocation(128, 67);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:128:67: ( LT !)*
				try { DebugEnterSubRule(59);
				while (true)
				{
					int alt59=2;
					try { DebugEnterDecision(59, false);
					int LA59_1 = input.LA(1);

					if ((LA59_1==LT))
					{
						alt59 = 1;
					}


					} finally { DebugExitDecision(59); }
					switch ( alt59 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:128:67: LT !
						{
						DebugLocation(128, 67);
						LT132=(IToken)Match(input,LT,Follow._LT_in_forStatement723); if (state.failed) return retval;

						}
						break;

					default:
						goto loop59;
					}
				}

				loop59:
					;

				} finally { DebugExitSubRule(59); }

				DebugLocation(128, 70);
				PushFollow(Follow._expression_in_forStatement727);
				expression133=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expression133.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(60); }

			DebugLocation(128, 85);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:128:85: ( LT !)*
			try { DebugEnterSubRule(61);
			while (true)
			{
				int alt61=2;
				try { DebugEnterDecision(61, false);
				int LA61_1 = input.LA(1);

				if ((LA61_1==LT))
				{
					alt61 = 1;
				}


				} finally { DebugExitDecision(61); }
				switch ( alt61 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:128:85: LT !
					{
					DebugLocation(128, 85);
					LT134=(IToken)Match(input,LT,Follow._LT_in_forStatement731); if (state.failed) return retval;

					}
					break;

				default:
					goto loop61;
				}
			}

			loop61:
				;

			} finally { DebugExitSubRule(61); }

			DebugLocation(128, 88);
			char_literal135=(IToken)Match(input,54,Follow._54_in_forStatement735); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal135_tree = (object)adaptor.Create(char_literal135);
			adaptor.AddChild(root_0, char_literal135_tree);
			}
			DebugLocation(128, 92);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:128:92: ( ( LT !)* expression )?
			int alt63=2;
			try { DebugEnterSubRule(63);
			try { DebugEnterDecision(63, false);
			try
			{
				alt63 = dfa63.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(63); }
			switch (alt63)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:128:93: ( LT !)* expression
				{
				DebugLocation(128, 95);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:128:95: ( LT !)*
				try { DebugEnterSubRule(62);
				while (true)
				{
					int alt62=2;
					try { DebugEnterDecision(62, false);
					int LA62_1 = input.LA(1);

					if ((LA62_1==LT))
					{
						alt62 = 1;
					}


					} finally { DebugExitDecision(62); }
					switch ( alt62 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:128:95: LT !
						{
						DebugLocation(128, 95);
						LT136=(IToken)Match(input,LT,Follow._LT_in_forStatement738); if (state.failed) return retval;

						}
						break;

					default:
						goto loop62;
					}
				}

				loop62:
					;

				} finally { DebugExitSubRule(62); }

				DebugLocation(128, 98);
				PushFollow(Follow._expression_in_forStatement742);
				expression137=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expression137.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(63); }

			DebugLocation(128, 113);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:128:113: ( LT !)*
			try { DebugEnterSubRule(64);
			while (true)
			{
				int alt64=2;
				try { DebugEnterDecision(64, false);
				int LA64_1 = input.LA(1);

				if ((LA64_1==LT))
				{
					alt64 = 1;
				}


				} finally { DebugExitDecision(64); }
				switch ( alt64 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:128:113: LT !
					{
					DebugLocation(128, 113);
					LT138=(IToken)Match(input,LT,Follow._LT_in_forStatement746); if (state.failed) return retval;

					}
					break;

				default:
					goto loop64;
				}
			}

			loop64:
				;

			} finally { DebugExitSubRule(64); }

			DebugLocation(128, 116);
			char_literal139=(IToken)Match(input,40,Follow._40_in_forStatement750); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal139_tree = (object)adaptor.Create(char_literal139);
			adaptor.AddChild(root_0, char_literal139_tree);
			}
			DebugLocation(128, 122);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:128:122: ( LT !)*
			try { DebugEnterSubRule(65);
			while (true)
			{
				int alt65=2;
				try { DebugEnterDecision(65, false);
				int LA65_1 = input.LA(1);

				if ((LA65_1==LT))
				{
					alt65 = 1;
				}


				} finally { DebugExitDecision(65); }
				switch ( alt65 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:128:122: LT !
					{
					DebugLocation(128, 122);
					LT140=(IToken)Match(input,LT,Follow._LT_in_forStatement752); if (state.failed) return retval;

					}
					break;

				default:
					goto loop65;
				}
			}

			loop65:
				;

			} finally { DebugExitSubRule(65); }

			DebugLocation(128, 125);
			PushFollow(Follow._statement_in_forStatement756);
			statement141=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, statement141.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forStatement", 24);
			LeaveRule("forStatement", 24);
			LeaveRule_forStatement();
			if (state.backtracking > 0) { Memoize(input, 24, forStatement_StartIndex); }

		}
		DebugLocation(129, 1);
		} finally { DebugExitRule(GrammarFileName, "forStatement"); }
		return retval;

	}
	// $ANTLR end "forStatement"

	partial void EnterRule_forStatementInitialiserPart();
	partial void LeaveRule_forStatementInitialiserPart();
	// $ANTLR start "forStatementInitialiserPart"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:131:1: forStatementInitialiserPart : ( expressionNoIn | 'var' ( LT !)* variableDeclarationListNoIn );
	[GrammarRule("forStatementInitialiserPart")]
	private AstParserRuleReturnScope<object, IToken> forStatementInitialiserPart()
	{
		EnterRule_forStatementInitialiserPart();
		EnterRule("forStatementInitialiserPart", 25);
		TraceIn("forStatementInitialiserPart", 25);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int forStatementInitialiserPart_StartIndex = input.Index;

		object root_0 = default(object);

		IToken string_literal143 = default(IToken);
		IToken LT144 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expressionNoIn142 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> variableDeclarationListNoIn145 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal143_tree = default(object);
		object LT144_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "forStatementInitialiserPart");
		DebugLocation(131, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 25)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:132:2: ( expressionNoIn | 'var' ( LT !)* variableDeclarationListNoIn )
			int alt67=2;
			try { DebugEnterDecision(67, false);
			int LA67_1 = input.LA(1);

			if ((LA67_1==Identifier||LA67_1==NumericLiteral||LA67_1==StringLiteral||LA67_1==31||LA67_1==39||(LA67_1>=43 && LA67_1<=44)||(LA67_1>=47 && LA67_1<=48)||LA67_1==69||LA67_1==78||LA67_1==81||LA67_1==84||(LA67_1>=88 && LA67_1<=89)||LA67_1==92||LA67_1==94||LA67_1==96||LA67_1==98||LA67_1==101||LA67_1==106))
			{
				alt67 = 1;
			}
			else if ((LA67_1==97))
			{
				alt67 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 67, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(67); }
			switch (alt67)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:132:4: expressionNoIn
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(132, 4);
				PushFollow(Follow._expressionNoIn_in_forStatementInitialiserPart768);
				expressionNoIn142=expressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expressionNoIn142.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:133:4: 'var' ( LT !)* variableDeclarationListNoIn
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(133, 4);
				string_literal143=(IToken)Match(input,97,Follow._97_in_forStatementInitialiserPart773); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal143_tree = (object)adaptor.Create(string_literal143);
				adaptor.AddChild(root_0, string_literal143_tree);
				}
				DebugLocation(133, 12);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:133:12: ( LT !)*
				try { DebugEnterSubRule(66);
				while (true)
				{
					int alt66=2;
					try { DebugEnterDecision(66, false);
					int LA66_1 = input.LA(1);

					if ((LA66_1==LT))
					{
						alt66 = 1;
					}


					} finally { DebugExitDecision(66); }
					switch ( alt66 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:133:12: LT !
						{
						DebugLocation(133, 12);
						LT144=(IToken)Match(input,LT,Follow._LT_in_forStatementInitialiserPart775); if (state.failed) return retval;

						}
						break;

					default:
						goto loop66;
					}
				}

				loop66:
					;

				} finally { DebugExitSubRule(66); }

				DebugLocation(133, 15);
				PushFollow(Follow._variableDeclarationListNoIn_in_forStatementInitialiserPart779);
				variableDeclarationListNoIn145=variableDeclarationListNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclarationListNoIn145.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forStatementInitialiserPart", 25);
			LeaveRule("forStatementInitialiserPart", 25);
			LeaveRule_forStatementInitialiserPart();
			if (state.backtracking > 0) { Memoize(input, 25, forStatementInitialiserPart_StartIndex); }

		}
		DebugLocation(134, 1);
		} finally { DebugExitRule(GrammarFileName, "forStatementInitialiserPart"); }
		return retval;

	}
	// $ANTLR end "forStatementInitialiserPart"

	partial void EnterRule_forInStatement();
	partial void LeaveRule_forInStatement();
	// $ANTLR start "forInStatement"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:136:1: forInStatement : 'for' ( LT !)* '(' ( LT !)* forInStatementInitialiserPart ( LT !)* 'in' ( LT !)* expression ( LT !)* ')' ( LT !)* statement ;
	[GrammarRule("forInStatement")]
	private AstParserRuleReturnScope<object, IToken> forInStatement()
	{
		EnterRule_forInStatement();
		EnterRule("forInStatement", 26);
		TraceIn("forInStatement", 26);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int forInStatement_StartIndex = input.Index;

		object root_0 = default(object);

		IToken string_literal146 = default(IToken);
		IToken LT147 = default(IToken);
		IToken char_literal148 = default(IToken);
		IToken LT149 = default(IToken);
		IToken LT151 = default(IToken);
		IToken string_literal152 = default(IToken);
		IToken LT153 = default(IToken);
		IToken LT155 = default(IToken);
		IToken char_literal156 = default(IToken);
		IToken LT157 = default(IToken);
		AstParserRuleReturnScope<object, IToken> forInStatementInitialiserPart150 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression154 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement158 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal146_tree = default(object);
		object LT147_tree = default(object);
		object char_literal148_tree = default(object);
		object LT149_tree = default(object);
		object LT151_tree = default(object);
		object string_literal152_tree = default(object);
		object LT153_tree = default(object);
		object LT155_tree = default(object);
		object char_literal156_tree = default(object);
		object LT157_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "forInStatement");
		DebugLocation(136, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 26)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:137:2: ( 'for' ( LT !)* '(' ( LT !)* forInStatementInitialiserPart ( LT !)* 'in' ( LT !)* expression ( LT !)* ')' ( LT !)* statement )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:137:4: 'for' ( LT !)* '(' ( LT !)* forInStatementInitialiserPart ( LT !)* 'in' ( LT !)* expression ( LT !)* ')' ( LT !)* statement
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(137, 4);
			string_literal146=(IToken)Match(input,83,Follow._83_in_forInStatement791); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal146_tree = (object)adaptor.Create(string_literal146);
			adaptor.AddChild(root_0, string_literal146_tree);
			}
			DebugLocation(137, 12);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:137:12: ( LT !)*
			try { DebugEnterSubRule(68);
			while (true)
			{
				int alt68=2;
				try { DebugEnterDecision(68, false);
				int LA68_1 = input.LA(1);

				if ((LA68_1==LT))
				{
					alt68 = 1;
				}


				} finally { DebugExitDecision(68); }
				switch ( alt68 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:137:12: LT !
					{
					DebugLocation(137, 12);
					LT147=(IToken)Match(input,LT,Follow._LT_in_forInStatement793); if (state.failed) return retval;

					}
					break;

				default:
					goto loop68;
				}
			}

			loop68:
				;

			} finally { DebugExitSubRule(68); }

			DebugLocation(137, 15);
			char_literal148=(IToken)Match(input,39,Follow._39_in_forInStatement797); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal148_tree = (object)adaptor.Create(char_literal148);
			adaptor.AddChild(root_0, char_literal148_tree);
			}
			DebugLocation(137, 21);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:137:21: ( LT !)*
			try { DebugEnterSubRule(69);
			while (true)
			{
				int alt69=2;
				try { DebugEnterDecision(69, false);
				int LA69_1 = input.LA(1);

				if ((LA69_1==LT))
				{
					alt69 = 1;
				}


				} finally { DebugExitDecision(69); }
				switch ( alt69 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:137:21: LT !
					{
					DebugLocation(137, 21);
					LT149=(IToken)Match(input,LT,Follow._LT_in_forInStatement799); if (state.failed) return retval;

					}
					break;

				default:
					goto loop69;
				}
			}

			loop69:
				;

			} finally { DebugExitSubRule(69); }

			DebugLocation(137, 24);
			PushFollow(Follow._forInStatementInitialiserPart_in_forInStatement803);
			forInStatementInitialiserPart150=forInStatementInitialiserPart();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, forInStatementInitialiserPart150.Tree);
			DebugLocation(137, 56);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:137:56: ( LT !)*
			try { DebugEnterSubRule(70);
			while (true)
			{
				int alt70=2;
				try { DebugEnterDecision(70, false);
				int LA70_1 = input.LA(1);

				if ((LA70_1==LT))
				{
					alt70 = 1;
				}


				} finally { DebugExitDecision(70); }
				switch ( alt70 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:137:56: LT !
					{
					DebugLocation(137, 56);
					LT151=(IToken)Match(input,LT,Follow._LT_in_forInStatement805); if (state.failed) return retval;

					}
					break;

				default:
					goto loop70;
				}
			}

			loop70:
				;

			} finally { DebugExitSubRule(70); }

			DebugLocation(137, 59);
			string_literal152=(IToken)Match(input,86,Follow._86_in_forInStatement809); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal152_tree = (object)adaptor.Create(string_literal152);
			adaptor.AddChild(root_0, string_literal152_tree);
			}
			DebugLocation(137, 66);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:137:66: ( LT !)*
			try { DebugEnterSubRule(71);
			while (true)
			{
				int alt71=2;
				try { DebugEnterDecision(71, false);
				int LA71_1 = input.LA(1);

				if ((LA71_1==LT))
				{
					alt71 = 1;
				}


				} finally { DebugExitDecision(71); }
				switch ( alt71 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:137:66: LT !
					{
					DebugLocation(137, 66);
					LT153=(IToken)Match(input,LT,Follow._LT_in_forInStatement811); if (state.failed) return retval;

					}
					break;

				default:
					goto loop71;
				}
			}

			loop71:
				;

			} finally { DebugExitSubRule(71); }

			DebugLocation(137, 69);
			PushFollow(Follow._expression_in_forInStatement815);
			expression154=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression154.Tree);
			DebugLocation(137, 82);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:137:82: ( LT !)*
			try { DebugEnterSubRule(72);
			while (true)
			{
				int alt72=2;
				try { DebugEnterDecision(72, false);
				int LA72_1 = input.LA(1);

				if ((LA72_1==LT))
				{
					alt72 = 1;
				}


				} finally { DebugExitDecision(72); }
				switch ( alt72 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:137:82: LT !
					{
					DebugLocation(137, 82);
					LT155=(IToken)Match(input,LT,Follow._LT_in_forInStatement817); if (state.failed) return retval;

					}
					break;

				default:
					goto loop72;
				}
			}

			loop72:
				;

			} finally { DebugExitSubRule(72); }

			DebugLocation(137, 85);
			char_literal156=(IToken)Match(input,40,Follow._40_in_forInStatement821); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal156_tree = (object)adaptor.Create(char_literal156);
			adaptor.AddChild(root_0, char_literal156_tree);
			}
			DebugLocation(137, 91);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:137:91: ( LT !)*
			try { DebugEnterSubRule(73);
			while (true)
			{
				int alt73=2;
				try { DebugEnterDecision(73, false);
				int LA73_1 = input.LA(1);

				if ((LA73_1==LT))
				{
					alt73 = 1;
				}


				} finally { DebugExitDecision(73); }
				switch ( alt73 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:137:91: LT !
					{
					DebugLocation(137, 91);
					LT157=(IToken)Match(input,LT,Follow._LT_in_forInStatement823); if (state.failed) return retval;

					}
					break;

				default:
					goto loop73;
				}
			}

			loop73:
				;

			} finally { DebugExitSubRule(73); }

			DebugLocation(137, 94);
			PushFollow(Follow._statement_in_forInStatement827);
			statement158=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, statement158.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forInStatement", 26);
			LeaveRule("forInStatement", 26);
			LeaveRule_forInStatement();
			if (state.backtracking > 0) { Memoize(input, 26, forInStatement_StartIndex); }

		}
		DebugLocation(138, 1);
		} finally { DebugExitRule(GrammarFileName, "forInStatement"); }
		return retval;

	}
	// $ANTLR end "forInStatement"

	partial void EnterRule_forInStatementInitialiserPart();
	partial void LeaveRule_forInStatementInitialiserPart();
	// $ANTLR start "forInStatementInitialiserPart"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:140:1: forInStatementInitialiserPart : ( leftHandSideExpression | 'var' ( LT !)* variableDeclarationNoIn );
	[GrammarRule("forInStatementInitialiserPart")]
	private AstParserRuleReturnScope<object, IToken> forInStatementInitialiserPart()
	{
		EnterRule_forInStatementInitialiserPart();
		EnterRule("forInStatementInitialiserPart", 27);
		TraceIn("forInStatementInitialiserPart", 27);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int forInStatementInitialiserPart_StartIndex = input.Index;

		object root_0 = default(object);

		IToken string_literal160 = default(IToken);
		IToken LT161 = default(IToken);
		AstParserRuleReturnScope<object, IToken> leftHandSideExpression159 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> variableDeclarationNoIn162 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal160_tree = default(object);
		object LT161_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "forInStatementInitialiserPart");
		DebugLocation(140, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 27)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:141:2: ( leftHandSideExpression | 'var' ( LT !)* variableDeclarationNoIn )
			int alt75=2;
			try { DebugEnterDecision(75, false);
			int LA75_1 = input.LA(1);

			if ((LA75_1==Identifier||LA75_1==NumericLiteral||LA75_1==StringLiteral||LA75_1==39||LA75_1==69||LA75_1==81||LA75_1==84||(LA75_1>=88 && LA75_1<=89)||LA75_1==92||LA75_1==94||LA75_1==101))
			{
				alt75 = 1;
			}
			else if ((LA75_1==97))
			{
				alt75 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 75, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(75); }
			switch (alt75)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:141:4: leftHandSideExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(141, 4);
				PushFollow(Follow._leftHandSideExpression_in_forInStatementInitialiserPart839);
				leftHandSideExpression159=leftHandSideExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, leftHandSideExpression159.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:142:4: 'var' ( LT !)* variableDeclarationNoIn
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(142, 4);
				string_literal160=(IToken)Match(input,97,Follow._97_in_forInStatementInitialiserPart844); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal160_tree = (object)adaptor.Create(string_literal160);
				adaptor.AddChild(root_0, string_literal160_tree);
				}
				DebugLocation(142, 12);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:142:12: ( LT !)*
				try { DebugEnterSubRule(74);
				while (true)
				{
					int alt74=2;
					try { DebugEnterDecision(74, false);
					int LA74_1 = input.LA(1);

					if ((LA74_1==LT))
					{
						alt74 = 1;
					}


					} finally { DebugExitDecision(74); }
					switch ( alt74 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:142:12: LT !
						{
						DebugLocation(142, 12);
						LT161=(IToken)Match(input,LT,Follow._LT_in_forInStatementInitialiserPart846); if (state.failed) return retval;

						}
						break;

					default:
						goto loop74;
					}
				}

				loop74:
					;

				} finally { DebugExitSubRule(74); }

				DebugLocation(142, 15);
				PushFollow(Follow._variableDeclarationNoIn_in_forInStatementInitialiserPart850);
				variableDeclarationNoIn162=variableDeclarationNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclarationNoIn162.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forInStatementInitialiserPart", 27);
			LeaveRule("forInStatementInitialiserPart", 27);
			LeaveRule_forInStatementInitialiserPart();
			if (state.backtracking > 0) { Memoize(input, 27, forInStatementInitialiserPart_StartIndex); }

		}
		DebugLocation(143, 1);
		} finally { DebugExitRule(GrammarFileName, "forInStatementInitialiserPart"); }
		return retval;

	}
	// $ANTLR end "forInStatementInitialiserPart"

	partial void EnterRule_continueStatement();
	partial void LeaveRule_continueStatement();
	// $ANTLR start "continueStatement"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:145:1: continueStatement : 'continue' ( Identifier )? ( LT | ';' ) !;
	[GrammarRule("continueStatement")]
	private AstParserRuleReturnScope<object, IToken> continueStatement()
	{
		EnterRule_continueStatement();
		EnterRule("continueStatement", 28);
		TraceIn("continueStatement", 28);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int continueStatement_StartIndex = input.Index;

		object root_0 = default(object);

		IToken string_literal163 = default(IToken);
		IToken Identifier164 = default(IToken);
		IToken set165 = default(IToken);

		object string_literal163_tree = default(object);
		object Identifier164_tree = default(object);
		object set165_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "continueStatement");
		DebugLocation(145, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 28)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:146:2: ( 'continue' ( Identifier )? ( LT | ';' ) !)
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:146:4: 'continue' ( Identifier )? ( LT | ';' ) !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(146, 4);
			string_literal163=(IToken)Match(input,76,Follow._76_in_continueStatement861); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal163_tree = (object)adaptor.Create(string_literal163);
			adaptor.AddChild(root_0, string_literal163_tree);
			}
			DebugLocation(146, 15);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:146:15: ( Identifier )?
			int alt76=2;
			try { DebugEnterSubRule(76);
			try { DebugEnterDecision(76, false);
			int LA76_1 = input.LA(1);

			if ((LA76_1==Identifier))
			{
				alt76 = 1;
			}
			} finally { DebugExitDecision(76); }
			switch (alt76)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:146:15: Identifier
				{
				DebugLocation(146, 15);
				Identifier164=(IToken)Match(input,Identifier,Follow._Identifier_in_continueStatement863); if (state.failed) return retval;
				if (state.backtracking == 0) {
				Identifier164_tree = (object)adaptor.Create(Identifier164);
				adaptor.AddChild(root_0, Identifier164_tree);
				}

				}
				break;

			}
			} finally { DebugExitSubRule(76); }

			DebugLocation(146, 37);

			set165=(IToken)input.LT(1);
			if (input.LA(1)==LT||input.LA(1)==54)
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("continueStatement", 28);
			LeaveRule("continueStatement", 28);
			LeaveRule_continueStatement();
			if (state.backtracking > 0) { Memoize(input, 28, continueStatement_StartIndex); }

		}
		DebugLocation(147, 1);
		} finally { DebugExitRule(GrammarFileName, "continueStatement"); }
		return retval;

	}
	// $ANTLR end "continueStatement"

	partial void EnterRule_breakStatement();
	partial void LeaveRule_breakStatement();
	// $ANTLR start "breakStatement"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:149:1: breakStatement : 'break' ( Identifier )? ( LT | ';' ) !;
	[GrammarRule("breakStatement")]
	private AstParserRuleReturnScope<object, IToken> breakStatement()
	{
		EnterRule_breakStatement();
		EnterRule("breakStatement", 29);
		TraceIn("breakStatement", 29);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int breakStatement_StartIndex = input.Index;

		object root_0 = default(object);

		IToken string_literal166 = default(IToken);
		IToken Identifier167 = default(IToken);
		IToken set168 = default(IToken);

		object string_literal166_tree = default(object);
		object Identifier167_tree = default(object);
		object set168_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "breakStatement");
		DebugLocation(149, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 29)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:150:2: ( 'break' ( Identifier )? ( LT | ';' ) !)
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:150:4: 'break' ( Identifier )? ( LT | ';' ) !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(150, 4);
			string_literal166=(IToken)Match(input,73,Follow._73_in_breakStatement884); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal166_tree = (object)adaptor.Create(string_literal166);
			adaptor.AddChild(root_0, string_literal166_tree);
			}
			DebugLocation(150, 12);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:150:12: ( Identifier )?
			int alt77=2;
			try { DebugEnterSubRule(77);
			try { DebugEnterDecision(77, false);
			int LA77_1 = input.LA(1);

			if ((LA77_1==Identifier))
			{
				alt77 = 1;
			}
			} finally { DebugExitDecision(77); }
			switch (alt77)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:150:12: Identifier
				{
				DebugLocation(150, 12);
				Identifier167=(IToken)Match(input,Identifier,Follow._Identifier_in_breakStatement886); if (state.failed) return retval;
				if (state.backtracking == 0) {
				Identifier167_tree = (object)adaptor.Create(Identifier167);
				adaptor.AddChild(root_0, Identifier167_tree);
				}

				}
				break;

			}
			} finally { DebugExitSubRule(77); }

			DebugLocation(150, 34);

			set168=(IToken)input.LT(1);
			if (input.LA(1)==LT||input.LA(1)==54)
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("breakStatement", 29);
			LeaveRule("breakStatement", 29);
			LeaveRule_breakStatement();
			if (state.backtracking > 0) { Memoize(input, 29, breakStatement_StartIndex); }

		}
		DebugLocation(151, 1);
		} finally { DebugExitRule(GrammarFileName, "breakStatement"); }
		return retval;

	}
	// $ANTLR end "breakStatement"

	partial void EnterRule_returnStatement();
	partial void LeaveRule_returnStatement();
	// $ANTLR start "returnStatement"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:153:1: returnStatement : 'return' ( expression )? ( LT | ';' ) !;
	[GrammarRule("returnStatement")]
	private AstParserRuleReturnScope<object, IToken> returnStatement()
	{
		EnterRule_returnStatement();
		EnterRule("returnStatement", 30);
		TraceIn("returnStatement", 30);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int returnStatement_StartIndex = input.Index;

		object root_0 = default(object);

		IToken string_literal169 = default(IToken);
		IToken set171 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression170 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal169_tree = default(object);
		object set171_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "returnStatement");
		DebugLocation(153, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 30)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:154:2: ( 'return' ( expression )? ( LT | ';' ) !)
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:154:4: 'return' ( expression )? ( LT | ';' ) !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(154, 4);
			string_literal169=(IToken)Match(input,90,Follow._90_in_returnStatement907); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal169_tree = (object)adaptor.Create(string_literal169);
			adaptor.AddChild(root_0, string_literal169_tree);
			}
			DebugLocation(154, 13);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:154:13: ( expression )?
			int alt78=2;
			try { DebugEnterSubRule(78);
			try { DebugEnterDecision(78, false);
			int LA78_1 = input.LA(1);

			if ((LA78_1==Identifier||LA78_1==NumericLiteral||LA78_1==StringLiteral||LA78_1==31||LA78_1==39||(LA78_1>=43 && LA78_1<=44)||(LA78_1>=47 && LA78_1<=48)||LA78_1==69||LA78_1==78||LA78_1==81||LA78_1==84||(LA78_1>=88 && LA78_1<=89)||LA78_1==92||LA78_1==94||LA78_1==96||LA78_1==98||LA78_1==101||LA78_1==106))
			{
				alt78 = 1;
			}
			} finally { DebugExitDecision(78); }
			switch (alt78)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:154:13: expression
				{
				DebugLocation(154, 13);
				PushFollow(Follow._expression_in_returnStatement909);
				expression170=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expression170.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(78); }

			DebugLocation(154, 35);

			set171=(IToken)input.LT(1);
			if (input.LA(1)==LT||input.LA(1)==54)
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("returnStatement", 30);
			LeaveRule("returnStatement", 30);
			LeaveRule_returnStatement();
			if (state.backtracking > 0) { Memoize(input, 30, returnStatement_StartIndex); }

		}
		DebugLocation(155, 1);
		} finally { DebugExitRule(GrammarFileName, "returnStatement"); }
		return retval;

	}
	// $ANTLR end "returnStatement"

	partial void EnterRule_withStatement();
	partial void LeaveRule_withStatement();
	// $ANTLR start "withStatement"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:157:1: withStatement : 'with' ( LT !)* '(' ( LT !)* expression ( LT !)* ')' ( LT !)* statement ;
	[GrammarRule("withStatement")]
	private AstParserRuleReturnScope<object, IToken> withStatement()
	{
		EnterRule_withStatement();
		EnterRule("withStatement", 31);
		TraceIn("withStatement", 31);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int withStatement_StartIndex = input.Index;

		object root_0 = default(object);

		IToken string_literal172 = default(IToken);
		IToken LT173 = default(IToken);
		IToken char_literal174 = default(IToken);
		IToken LT175 = default(IToken);
		IToken LT177 = default(IToken);
		IToken char_literal178 = default(IToken);
		IToken LT179 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression176 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement180 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal172_tree = default(object);
		object LT173_tree = default(object);
		object char_literal174_tree = default(object);
		object LT175_tree = default(object);
		object LT177_tree = default(object);
		object char_literal178_tree = default(object);
		object LT179_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "withStatement");
		DebugLocation(157, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 31)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:158:2: ( 'with' ( LT !)* '(' ( LT !)* expression ( LT !)* ')' ( LT !)* statement )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:158:4: 'with' ( LT !)* '(' ( LT !)* expression ( LT !)* ')' ( LT !)* statement
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(158, 4);
			string_literal172=(IToken)Match(input,100,Follow._100_in_withStatement931); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal172_tree = (object)adaptor.Create(string_literal172);
			adaptor.AddChild(root_0, string_literal172_tree);
			}
			DebugLocation(158, 13);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:158:13: ( LT !)*
			try { DebugEnterSubRule(79);
			while (true)
			{
				int alt79=2;
				try { DebugEnterDecision(79, false);
				int LA79_1 = input.LA(1);

				if ((LA79_1==LT))
				{
					alt79 = 1;
				}


				} finally { DebugExitDecision(79); }
				switch ( alt79 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:158:13: LT !
					{
					DebugLocation(158, 13);
					LT173=(IToken)Match(input,LT,Follow._LT_in_withStatement933); if (state.failed) return retval;

					}
					break;

				default:
					goto loop79;
				}
			}

			loop79:
				;

			} finally { DebugExitSubRule(79); }

			DebugLocation(158, 16);
			char_literal174=(IToken)Match(input,39,Follow._39_in_withStatement937); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal174_tree = (object)adaptor.Create(char_literal174);
			adaptor.AddChild(root_0, char_literal174_tree);
			}
			DebugLocation(158, 22);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:158:22: ( LT !)*
			try { DebugEnterSubRule(80);
			while (true)
			{
				int alt80=2;
				try { DebugEnterDecision(80, false);
				int LA80_1 = input.LA(1);

				if ((LA80_1==LT))
				{
					alt80 = 1;
				}


				} finally { DebugExitDecision(80); }
				switch ( alt80 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:158:22: LT !
					{
					DebugLocation(158, 22);
					LT175=(IToken)Match(input,LT,Follow._LT_in_withStatement939); if (state.failed) return retval;

					}
					break;

				default:
					goto loop80;
				}
			}

			loop80:
				;

			} finally { DebugExitSubRule(80); }

			DebugLocation(158, 25);
			PushFollow(Follow._expression_in_withStatement943);
			expression176=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression176.Tree);
			DebugLocation(158, 38);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:158:38: ( LT !)*
			try { DebugEnterSubRule(81);
			while (true)
			{
				int alt81=2;
				try { DebugEnterDecision(81, false);
				int LA81_1 = input.LA(1);

				if ((LA81_1==LT))
				{
					alt81 = 1;
				}


				} finally { DebugExitDecision(81); }
				switch ( alt81 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:158:38: LT !
					{
					DebugLocation(158, 38);
					LT177=(IToken)Match(input,LT,Follow._LT_in_withStatement945); if (state.failed) return retval;

					}
					break;

				default:
					goto loop81;
				}
			}

			loop81:
				;

			} finally { DebugExitSubRule(81); }

			DebugLocation(158, 41);
			char_literal178=(IToken)Match(input,40,Follow._40_in_withStatement949); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal178_tree = (object)adaptor.Create(char_literal178);
			adaptor.AddChild(root_0, char_literal178_tree);
			}
			DebugLocation(158, 47);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:158:47: ( LT !)*
			try { DebugEnterSubRule(82);
			while (true)
			{
				int alt82=2;
				try { DebugEnterDecision(82, false);
				int LA82_1 = input.LA(1);

				if ((LA82_1==LT))
				{
					alt82 = 1;
				}


				} finally { DebugExitDecision(82); }
				switch ( alt82 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:158:47: LT !
					{
					DebugLocation(158, 47);
					LT179=(IToken)Match(input,LT,Follow._LT_in_withStatement951); if (state.failed) return retval;

					}
					break;

				default:
					goto loop82;
				}
			}

			loop82:
				;

			} finally { DebugExitSubRule(82); }

			DebugLocation(158, 50);
			PushFollow(Follow._statement_in_withStatement955);
			statement180=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, statement180.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("withStatement", 31);
			LeaveRule("withStatement", 31);
			LeaveRule_withStatement();
			if (state.backtracking > 0) { Memoize(input, 31, withStatement_StartIndex); }

		}
		DebugLocation(159, 1);
		} finally { DebugExitRule(GrammarFileName, "withStatement"); }
		return retval;

	}
	// $ANTLR end "withStatement"

	partial void EnterRule_labelledStatement();
	partial void LeaveRule_labelledStatement();
	// $ANTLR start "labelledStatement"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:161:1: labelledStatement : Identifier ( LT !)* ':' ( LT !)* statement ;
	[GrammarRule("labelledStatement")]
	private AstParserRuleReturnScope<object, IToken> labelledStatement()
	{
		EnterRule_labelledStatement();
		EnterRule("labelledStatement", 32);
		TraceIn("labelledStatement", 32);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int labelledStatement_StartIndex = input.Index;

		object root_0 = default(object);

		IToken Identifier181 = default(IToken);
		IToken LT182 = default(IToken);
		IToken char_literal183 = default(IToken);
		IToken LT184 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statement185 = default(AstParserRuleReturnScope<object, IToken>);

		object Identifier181_tree = default(object);
		object LT182_tree = default(object);
		object char_literal183_tree = default(object);
		object LT184_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "labelledStatement");
		DebugLocation(161, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 32)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:162:2: ( Identifier ( LT !)* ':' ( LT !)* statement )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:162:4: Identifier ( LT !)* ':' ( LT !)* statement
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(162, 4);
			Identifier181=(IToken)Match(input,Identifier,Follow._Identifier_in_labelledStatement966); if (state.failed) return retval;
			if (state.backtracking == 0) {
			Identifier181_tree = (object)adaptor.Create(Identifier181);
			adaptor.AddChild(root_0, Identifier181_tree);
			}
			DebugLocation(162, 17);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:162:17: ( LT !)*
			try { DebugEnterSubRule(83);
			while (true)
			{
				int alt83=2;
				try { DebugEnterDecision(83, false);
				int LA83_1 = input.LA(1);

				if ((LA83_1==LT))
				{
					alt83 = 1;
				}


				} finally { DebugExitDecision(83); }
				switch ( alt83 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:162:17: LT !
					{
					DebugLocation(162, 17);
					LT182=(IToken)Match(input,LT,Follow._LT_in_labelledStatement968); if (state.failed) return retval;

					}
					break;

				default:
					goto loop83;
				}
			}

			loop83:
				;

			} finally { DebugExitSubRule(83); }

			DebugLocation(162, 20);
			char_literal183=(IToken)Match(input,53,Follow._53_in_labelledStatement972); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal183_tree = (object)adaptor.Create(char_literal183);
			adaptor.AddChild(root_0, char_literal183_tree);
			}
			DebugLocation(162, 26);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:162:26: ( LT !)*
			try { DebugEnterSubRule(84);
			while (true)
			{
				int alt84=2;
				try { DebugEnterDecision(84, false);
				int LA84_1 = input.LA(1);

				if ((LA84_1==LT))
				{
					alt84 = 1;
				}


				} finally { DebugExitDecision(84); }
				switch ( alt84 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:162:26: LT !
					{
					DebugLocation(162, 26);
					LT184=(IToken)Match(input,LT,Follow._LT_in_labelledStatement974); if (state.failed) return retval;

					}
					break;

				default:
					goto loop84;
				}
			}

			loop84:
				;

			} finally { DebugExitSubRule(84); }

			DebugLocation(162, 29);
			PushFollow(Follow._statement_in_labelledStatement978);
			statement185=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, statement185.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("labelledStatement", 32);
			LeaveRule("labelledStatement", 32);
			LeaveRule_labelledStatement();
			if (state.backtracking > 0) { Memoize(input, 32, labelledStatement_StartIndex); }

		}
		DebugLocation(163, 1);
		} finally { DebugExitRule(GrammarFileName, "labelledStatement"); }
		return retval;

	}
	// $ANTLR end "labelledStatement"

	partial void EnterRule_switchStatement();
	partial void LeaveRule_switchStatement();
	// $ANTLR start "switchStatement"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:165:1: switchStatement : 'switch' ( LT !)* '(' ( LT !)* expression ( LT !)* ')' ( LT !)* caseBlock ;
	[GrammarRule("switchStatement")]
	private AstParserRuleReturnScope<object, IToken> switchStatement()
	{
		EnterRule_switchStatement();
		EnterRule("switchStatement", 33);
		TraceIn("switchStatement", 33);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int switchStatement_StartIndex = input.Index;

		object root_0 = default(object);

		IToken string_literal186 = default(IToken);
		IToken LT187 = default(IToken);
		IToken char_literal188 = default(IToken);
		IToken LT189 = default(IToken);
		IToken LT191 = default(IToken);
		IToken char_literal192 = default(IToken);
		IToken LT193 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression190 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> caseBlock194 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal186_tree = default(object);
		object LT187_tree = default(object);
		object char_literal188_tree = default(object);
		object LT189_tree = default(object);
		object LT191_tree = default(object);
		object char_literal192_tree = default(object);
		object LT193_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "switchStatement");
		DebugLocation(165, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 33)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:166:2: ( 'switch' ( LT !)* '(' ( LT !)* expression ( LT !)* ')' ( LT !)* caseBlock )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:166:4: 'switch' ( LT !)* '(' ( LT !)* expression ( LT !)* ')' ( LT !)* caseBlock
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(166, 4);
			string_literal186=(IToken)Match(input,91,Follow._91_in_switchStatement990); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal186_tree = (object)adaptor.Create(string_literal186);
			adaptor.AddChild(root_0, string_literal186_tree);
			}
			DebugLocation(166, 15);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:166:15: ( LT !)*
			try { DebugEnterSubRule(85);
			while (true)
			{
				int alt85=2;
				try { DebugEnterDecision(85, false);
				int LA85_1 = input.LA(1);

				if ((LA85_1==LT))
				{
					alt85 = 1;
				}


				} finally { DebugExitDecision(85); }
				switch ( alt85 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:166:15: LT !
					{
					DebugLocation(166, 15);
					LT187=(IToken)Match(input,LT,Follow._LT_in_switchStatement992); if (state.failed) return retval;

					}
					break;

				default:
					goto loop85;
				}
			}

			loop85:
				;

			} finally { DebugExitSubRule(85); }

			DebugLocation(166, 18);
			char_literal188=(IToken)Match(input,39,Follow._39_in_switchStatement996); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal188_tree = (object)adaptor.Create(char_literal188);
			adaptor.AddChild(root_0, char_literal188_tree);
			}
			DebugLocation(166, 24);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:166:24: ( LT !)*
			try { DebugEnterSubRule(86);
			while (true)
			{
				int alt86=2;
				try { DebugEnterDecision(86, false);
				int LA86_1 = input.LA(1);

				if ((LA86_1==LT))
				{
					alt86 = 1;
				}


				} finally { DebugExitDecision(86); }
				switch ( alt86 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:166:24: LT !
					{
					DebugLocation(166, 24);
					LT189=(IToken)Match(input,LT,Follow._LT_in_switchStatement998); if (state.failed) return retval;

					}
					break;

				default:
					goto loop86;
				}
			}

			loop86:
				;

			} finally { DebugExitSubRule(86); }

			DebugLocation(166, 27);
			PushFollow(Follow._expression_in_switchStatement1002);
			expression190=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression190.Tree);
			DebugLocation(166, 40);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:166:40: ( LT !)*
			try { DebugEnterSubRule(87);
			while (true)
			{
				int alt87=2;
				try { DebugEnterDecision(87, false);
				int LA87_1 = input.LA(1);

				if ((LA87_1==LT))
				{
					alt87 = 1;
				}


				} finally { DebugExitDecision(87); }
				switch ( alt87 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:166:40: LT !
					{
					DebugLocation(166, 40);
					LT191=(IToken)Match(input,LT,Follow._LT_in_switchStatement1004); if (state.failed) return retval;

					}
					break;

				default:
					goto loop87;
				}
			}

			loop87:
				;

			} finally { DebugExitSubRule(87); }

			DebugLocation(166, 43);
			char_literal192=(IToken)Match(input,40,Follow._40_in_switchStatement1008); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal192_tree = (object)adaptor.Create(char_literal192);
			adaptor.AddChild(root_0, char_literal192_tree);
			}
			DebugLocation(166, 49);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:166:49: ( LT !)*
			try { DebugEnterSubRule(88);
			while (true)
			{
				int alt88=2;
				try { DebugEnterDecision(88, false);
				int LA88_1 = input.LA(1);

				if ((LA88_1==LT))
				{
					alt88 = 1;
				}


				} finally { DebugExitDecision(88); }
				switch ( alt88 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:166:49: LT !
					{
					DebugLocation(166, 49);
					LT193=(IToken)Match(input,LT,Follow._LT_in_switchStatement1010); if (state.failed) return retval;

					}
					break;

				default:
					goto loop88;
				}
			}

			loop88:
				;

			} finally { DebugExitSubRule(88); }

			DebugLocation(166, 52);
			PushFollow(Follow._caseBlock_in_switchStatement1014);
			caseBlock194=caseBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, caseBlock194.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("switchStatement", 33);
			LeaveRule("switchStatement", 33);
			LeaveRule_switchStatement();
			if (state.backtracking > 0) { Memoize(input, 33, switchStatement_StartIndex); }

		}
		DebugLocation(167, 1);
		} finally { DebugExitRule(GrammarFileName, "switchStatement"); }
		return retval;

	}
	// $ANTLR end "switchStatement"

	partial void EnterRule_caseBlock();
	partial void LeaveRule_caseBlock();
	// $ANTLR start "caseBlock"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:169:1: caseBlock : '{' ( ( LT !)* caseClause )* ( ( LT !)* defaultClause ( ( LT !)* caseClause )* )? ( LT !)* '}' ;
	[GrammarRule("caseBlock")]
	private AstParserRuleReturnScope<object, IToken> caseBlock()
	{
		EnterRule_caseBlock();
		EnterRule("caseBlock", 34);
		TraceIn("caseBlock", 34);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int caseBlock_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal195 = default(IToken);
		IToken LT196 = default(IToken);
		IToken LT198 = default(IToken);
		IToken LT200 = default(IToken);
		IToken LT202 = default(IToken);
		IToken char_literal203 = default(IToken);
		AstParserRuleReturnScope<object, IToken> caseClause197 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> defaultClause199 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> caseClause201 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal195_tree = default(object);
		object LT196_tree = default(object);
		object LT198_tree = default(object);
		object LT200_tree = default(object);
		object LT202_tree = default(object);
		object char_literal203_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "caseBlock");
		DebugLocation(169, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 34)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:170:2: ( '{' ( ( LT !)* caseClause )* ( ( LT !)* defaultClause ( ( LT !)* caseClause )* )? ( LT !)* '}' )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:170:4: '{' ( ( LT !)* caseClause )* ( ( LT !)* defaultClause ( ( LT !)* caseClause )* )? ( LT !)* '}'
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(170, 4);
			char_literal195=(IToken)Match(input,101,Follow._101_in_caseBlock1026); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal195_tree = (object)adaptor.Create(char_literal195);
			adaptor.AddChild(root_0, char_literal195_tree);
			}
			DebugLocation(170, 8);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:170:8: ( ( LT !)* caseClause )*
			try { DebugEnterSubRule(90);
			while (true)
			{
				int alt90=2;
				try { DebugEnterDecision(90, false);
				try
				{
					alt90 = dfa90.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(90); }
				switch ( alt90 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:170:9: ( LT !)* caseClause
					{
					DebugLocation(170, 11);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:170:11: ( LT !)*
					try { DebugEnterSubRule(89);
					while (true)
					{
						int alt89=2;
						try { DebugEnterDecision(89, false);
						int LA89_1 = input.LA(1);

						if ((LA89_1==LT))
						{
							alt89 = 1;
						}


						} finally { DebugExitDecision(89); }
						switch ( alt89 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:170:11: LT !
							{
							DebugLocation(170, 11);
							LT196=(IToken)Match(input,LT,Follow._LT_in_caseBlock1029); if (state.failed) return retval;

							}
							break;

						default:
							goto loop89;
						}
					}

					loop89:
						;

					} finally { DebugExitSubRule(89); }

					DebugLocation(170, 14);
					PushFollow(Follow._caseClause_in_caseBlock1033);
					caseClause197=caseClause();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, caseClause197.Tree);

					}
					break;

				default:
					goto loop90;
				}
			}

			loop90:
				;

			} finally { DebugExitSubRule(90); }

			DebugLocation(170, 27);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:170:27: ( ( LT !)* defaultClause ( ( LT !)* caseClause )* )?
			int alt94=2;
			try { DebugEnterSubRule(94);
			try { DebugEnterDecision(94, false);
			try
			{
				alt94 = dfa94.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(94); }
			switch (alt94)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:170:28: ( LT !)* defaultClause ( ( LT !)* caseClause )*
				{
				DebugLocation(170, 30);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:170:30: ( LT !)*
				try { DebugEnterSubRule(91);
				while (true)
				{
					int alt91=2;
					try { DebugEnterDecision(91, false);
					int LA91_1 = input.LA(1);

					if ((LA91_1==LT))
					{
						alt91 = 1;
					}


					} finally { DebugExitDecision(91); }
					switch ( alt91 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:170:30: LT !
						{
						DebugLocation(170, 30);
						LT198=(IToken)Match(input,LT,Follow._LT_in_caseBlock1038); if (state.failed) return retval;

						}
						break;

					default:
						goto loop91;
					}
				}

				loop91:
					;

				} finally { DebugExitSubRule(91); }

				DebugLocation(170, 33);
				PushFollow(Follow._defaultClause_in_caseBlock1042);
				defaultClause199=defaultClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, defaultClause199.Tree);
				DebugLocation(170, 47);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:170:47: ( ( LT !)* caseClause )*
				try { DebugEnterSubRule(93);
				while (true)
				{
					int alt93=2;
					try { DebugEnterDecision(93, false);
					try
					{
						alt93 = dfa93.Predict(input);
					}
					catch (NoViableAltException nvae)
					{
						DebugRecognitionException(nvae);
						throw;
					}
					} finally { DebugExitDecision(93); }
					switch ( alt93 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:170:48: ( LT !)* caseClause
						{
						DebugLocation(170, 50);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:170:50: ( LT !)*
						try { DebugEnterSubRule(92);
						while (true)
						{
							int alt92=2;
							try { DebugEnterDecision(92, false);
							int LA92_1 = input.LA(1);

							if ((LA92_1==LT))
							{
								alt92 = 1;
							}


							} finally { DebugExitDecision(92); }
							switch ( alt92 )
							{
							case 1:
								DebugEnterAlt(1);
								// C:\\DEVGIT\\typesharp\\TypeScript.g:170:50: LT !
								{
								DebugLocation(170, 50);
								LT200=(IToken)Match(input,LT,Follow._LT_in_caseBlock1045); if (state.failed) return retval;

								}
								break;

							default:
								goto loop92;
							}
						}

						loop92:
							;

						} finally { DebugExitSubRule(92); }

						DebugLocation(170, 53);
						PushFollow(Follow._caseClause_in_caseBlock1049);
						caseClause201=caseClause();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) adaptor.AddChild(root_0, caseClause201.Tree);

						}
						break;

					default:
						goto loop93;
					}
				}

				loop93:
					;

				} finally { DebugExitSubRule(93); }


				}
				break;

			}
			} finally { DebugExitSubRule(94); }

			DebugLocation(170, 70);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:170:70: ( LT !)*
			try { DebugEnterSubRule(95);
			while (true)
			{
				int alt95=2;
				try { DebugEnterDecision(95, false);
				int LA95_1 = input.LA(1);

				if ((LA95_1==LT))
				{
					alt95 = 1;
				}


				} finally { DebugExitDecision(95); }
				switch ( alt95 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:170:70: LT !
					{
					DebugLocation(170, 70);
					LT202=(IToken)Match(input,LT,Follow._LT_in_caseBlock1055); if (state.failed) return retval;

					}
					break;

				default:
					goto loop95;
				}
			}

			loop95:
				;

			} finally { DebugExitSubRule(95); }

			DebugLocation(170, 73);
			char_literal203=(IToken)Match(input,105,Follow._105_in_caseBlock1059); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal203_tree = (object)adaptor.Create(char_literal203);
			adaptor.AddChild(root_0, char_literal203_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("caseBlock", 34);
			LeaveRule("caseBlock", 34);
			LeaveRule_caseBlock();
			if (state.backtracking > 0) { Memoize(input, 34, caseBlock_StartIndex); }

		}
		DebugLocation(171, 1);
		} finally { DebugExitRule(GrammarFileName, "caseBlock"); }
		return retval;

	}
	// $ANTLR end "caseBlock"

	partial void EnterRule_caseClause();
	partial void LeaveRule_caseClause();
	// $ANTLR start "caseClause"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:173:1: caseClause : 'case' ( LT !)* expression ( LT !)* ':' ( LT !)* ( statementList )? ;
	[GrammarRule("caseClause")]
	private AstParserRuleReturnScope<object, IToken> caseClause()
	{
		EnterRule_caseClause();
		EnterRule("caseClause", 35);
		TraceIn("caseClause", 35);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int caseClause_StartIndex = input.Index;

		object root_0 = default(object);

		IToken string_literal204 = default(IToken);
		IToken LT205 = default(IToken);
		IToken LT207 = default(IToken);
		IToken char_literal208 = default(IToken);
		IToken LT209 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression206 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statementList210 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal204_tree = default(object);
		object LT205_tree = default(object);
		object LT207_tree = default(object);
		object char_literal208_tree = default(object);
		object LT209_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "caseClause");
		DebugLocation(173, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 35)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:174:2: ( 'case' ( LT !)* expression ( LT !)* ':' ( LT !)* ( statementList )? )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:174:4: 'case' ( LT !)* expression ( LT !)* ':' ( LT !)* ( statementList )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(174, 4);
			string_literal204=(IToken)Match(input,74,Follow._74_in_caseClause1070); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal204_tree = (object)adaptor.Create(string_literal204);
			adaptor.AddChild(root_0, string_literal204_tree);
			}
			DebugLocation(174, 13);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:174:13: ( LT !)*
			try { DebugEnterSubRule(96);
			while (true)
			{
				int alt96=2;
				try { DebugEnterDecision(96, false);
				int LA96_1 = input.LA(1);

				if ((LA96_1==LT))
				{
					alt96 = 1;
				}


				} finally { DebugExitDecision(96); }
				switch ( alt96 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:174:13: LT !
					{
					DebugLocation(174, 13);
					LT205=(IToken)Match(input,LT,Follow._LT_in_caseClause1072); if (state.failed) return retval;

					}
					break;

				default:
					goto loop96;
				}
			}

			loop96:
				;

			} finally { DebugExitSubRule(96); }

			DebugLocation(174, 16);
			PushFollow(Follow._expression_in_caseClause1076);
			expression206=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression206.Tree);
			DebugLocation(174, 29);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:174:29: ( LT !)*
			try { DebugEnterSubRule(97);
			while (true)
			{
				int alt97=2;
				try { DebugEnterDecision(97, false);
				int LA97_1 = input.LA(1);

				if ((LA97_1==LT))
				{
					alt97 = 1;
				}


				} finally { DebugExitDecision(97); }
				switch ( alt97 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:174:29: LT !
					{
					DebugLocation(174, 29);
					LT207=(IToken)Match(input,LT,Follow._LT_in_caseClause1078); if (state.failed) return retval;

					}
					break;

				default:
					goto loop97;
				}
			}

			loop97:
				;

			} finally { DebugExitSubRule(97); }

			DebugLocation(174, 32);
			char_literal208=(IToken)Match(input,53,Follow._53_in_caseClause1082); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal208_tree = (object)adaptor.Create(char_literal208);
			adaptor.AddChild(root_0, char_literal208_tree);
			}
			DebugLocation(174, 38);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:174:38: ( LT !)*
			try { DebugEnterSubRule(98);
			while (true)
			{
				int alt98=2;
				try { DebugEnterDecision(98, false);
				int LA98_1 = input.LA(1);

				if ((LA98_1==LT))
				{
					int LA98_2 = input.LA(2);

					if ((EvaluatePredicate(synpred118_TypeScript_fragment)))
					{
						alt98 = 1;
					}


				}


				} finally { DebugExitDecision(98); }
				switch ( alt98 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:174:38: LT !
					{
					DebugLocation(174, 38);
					LT209=(IToken)Match(input,LT,Follow._LT_in_caseClause1084); if (state.failed) return retval;

					}
					break;

				default:
					goto loop98;
				}
			}

			loop98:
				;

			} finally { DebugExitSubRule(98); }

			DebugLocation(174, 41);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:174:41: ( statementList )?
			int alt99=2;
			try { DebugEnterSubRule(99);
			try { DebugEnterDecision(99, false);
			int LA99_1 = input.LA(1);

			if ((LA99_1==Identifier||LA99_1==NumericLiteral||LA99_1==StringLiteral||LA99_1==31||LA99_1==39||(LA99_1>=43 && LA99_1<=44)||(LA99_1>=47 && LA99_1<=48)||LA99_1==54||LA99_1==69||LA99_1==73||LA99_1==76||(LA99_1>=78 && LA99_1<=79)||LA99_1==81||(LA99_1>=83 && LA99_1<=85)||(LA99_1>=88 && LA99_1<=101)||LA99_1==106))
			{
				alt99 = 1;
			}
			} finally { DebugExitDecision(99); }
			switch (alt99)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:174:41: statementList
				{
				DebugLocation(174, 41);
				PushFollow(Follow._statementList_in_caseClause1088);
				statementList210=statementList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, statementList210.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(99); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("caseClause", 35);
			LeaveRule("caseClause", 35);
			LeaveRule_caseClause();
			if (state.backtracking > 0) { Memoize(input, 35, caseClause_StartIndex); }

		}
		DebugLocation(175, 1);
		} finally { DebugExitRule(GrammarFileName, "caseClause"); }
		return retval;

	}
	// $ANTLR end "caseClause"

	partial void EnterRule_defaultClause();
	partial void LeaveRule_defaultClause();
	// $ANTLR start "defaultClause"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:177:1: defaultClause : 'default' ( LT !)* ':' ( LT !)* ( statementList )? ;
	[GrammarRule("defaultClause")]
	private AstParserRuleReturnScope<object, IToken> defaultClause()
	{
		EnterRule_defaultClause();
		EnterRule("defaultClause", 36);
		TraceIn("defaultClause", 36);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int defaultClause_StartIndex = input.Index;

		object root_0 = default(object);

		IToken string_literal211 = default(IToken);
		IToken LT212 = default(IToken);
		IToken char_literal213 = default(IToken);
		IToken LT214 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statementList215 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal211_tree = default(object);
		object LT212_tree = default(object);
		object char_literal213_tree = default(object);
		object LT214_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "defaultClause");
		DebugLocation(177, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 36)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:178:2: ( 'default' ( LT !)* ':' ( LT !)* ( statementList )? )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:178:4: 'default' ( LT !)* ':' ( LT !)* ( statementList )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(178, 4);
			string_literal211=(IToken)Match(input,77,Follow._77_in_defaultClause1101); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal211_tree = (object)adaptor.Create(string_literal211);
			adaptor.AddChild(root_0, string_literal211_tree);
			}
			DebugLocation(178, 16);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:178:16: ( LT !)*
			try { DebugEnterSubRule(100);
			while (true)
			{
				int alt100=2;
				try { DebugEnterDecision(100, false);
				int LA100_1 = input.LA(1);

				if ((LA100_1==LT))
				{
					alt100 = 1;
				}


				} finally { DebugExitDecision(100); }
				switch ( alt100 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:178:16: LT !
					{
					DebugLocation(178, 16);
					LT212=(IToken)Match(input,LT,Follow._LT_in_defaultClause1103); if (state.failed) return retval;

					}
					break;

				default:
					goto loop100;
				}
			}

			loop100:
				;

			} finally { DebugExitSubRule(100); }

			DebugLocation(178, 19);
			char_literal213=(IToken)Match(input,53,Follow._53_in_defaultClause1107); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal213_tree = (object)adaptor.Create(char_literal213);
			adaptor.AddChild(root_0, char_literal213_tree);
			}
			DebugLocation(178, 25);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:178:25: ( LT !)*
			try { DebugEnterSubRule(101);
			while (true)
			{
				int alt101=2;
				try { DebugEnterDecision(101, false);
				int LA101_1 = input.LA(1);

				if ((LA101_1==LT))
				{
					int LA101_2 = input.LA(2);

					if ((EvaluatePredicate(synpred121_TypeScript_fragment)))
					{
						alt101 = 1;
					}


				}


				} finally { DebugExitDecision(101); }
				switch ( alt101 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:178:25: LT !
					{
					DebugLocation(178, 25);
					LT214=(IToken)Match(input,LT,Follow._LT_in_defaultClause1109); if (state.failed) return retval;

					}
					break;

				default:
					goto loop101;
				}
			}

			loop101:
				;

			} finally { DebugExitSubRule(101); }

			DebugLocation(178, 28);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:178:28: ( statementList )?
			int alt102=2;
			try { DebugEnterSubRule(102);
			try { DebugEnterDecision(102, false);
			int LA102_1 = input.LA(1);

			if ((LA102_1==Identifier||LA102_1==NumericLiteral||LA102_1==StringLiteral||LA102_1==31||LA102_1==39||(LA102_1>=43 && LA102_1<=44)||(LA102_1>=47 && LA102_1<=48)||LA102_1==54||LA102_1==69||LA102_1==73||LA102_1==76||(LA102_1>=78 && LA102_1<=79)||LA102_1==81||(LA102_1>=83 && LA102_1<=85)||(LA102_1>=88 && LA102_1<=101)||LA102_1==106))
			{
				alt102 = 1;
			}
			} finally { DebugExitDecision(102); }
			switch (alt102)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:178:28: statementList
				{
				DebugLocation(178, 28);
				PushFollow(Follow._statementList_in_defaultClause1113);
				statementList215=statementList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, statementList215.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(102); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("defaultClause", 36);
			LeaveRule("defaultClause", 36);
			LeaveRule_defaultClause();
			if (state.backtracking > 0) { Memoize(input, 36, defaultClause_StartIndex); }

		}
		DebugLocation(179, 1);
		} finally { DebugExitRule(GrammarFileName, "defaultClause"); }
		return retval;

	}
	// $ANTLR end "defaultClause"

	partial void EnterRule_throwStatement();
	partial void LeaveRule_throwStatement();
	// $ANTLR start "throwStatement"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:181:1: throwStatement : 'throw' expression ( LT | ';' ) !;
	[GrammarRule("throwStatement")]
	private AstParserRuleReturnScope<object, IToken> throwStatement()
	{
		EnterRule_throwStatement();
		EnterRule("throwStatement", 37);
		TraceIn("throwStatement", 37);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int throwStatement_StartIndex = input.Index;

		object root_0 = default(object);

		IToken string_literal216 = default(IToken);
		IToken set218 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression217 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal216_tree = default(object);
		object set218_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "throwStatement");
		DebugLocation(181, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 37)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:182:2: ( 'throw' expression ( LT | ';' ) !)
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:182:4: 'throw' expression ( LT | ';' ) !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(182, 4);
			string_literal216=(IToken)Match(input,93,Follow._93_in_throwStatement1126); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal216_tree = (object)adaptor.Create(string_literal216);
			adaptor.AddChild(root_0, string_literal216_tree);
			}
			DebugLocation(182, 12);
			PushFollow(Follow._expression_in_throwStatement1128);
			expression217=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression217.Tree);
			DebugLocation(182, 33);

			set218=(IToken)input.LT(1);
			if (input.LA(1)==LT||input.LA(1)==54)
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("throwStatement", 37);
			LeaveRule("throwStatement", 37);
			LeaveRule_throwStatement();
			if (state.backtracking > 0) { Memoize(input, 37, throwStatement_StartIndex); }

		}
		DebugLocation(183, 1);
		} finally { DebugExitRule(GrammarFileName, "throwStatement"); }
		return retval;

	}
	// $ANTLR end "throwStatement"

	partial void EnterRule_tryStatement();
	partial void LeaveRule_tryStatement();
	// $ANTLR start "tryStatement"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:185:1: tryStatement : 'try' ( LT !)* statementBlock ( LT !)* ( finallyClause | catchClause ( ( LT !)* finallyClause )? ) ;
	[GrammarRule("tryStatement")]
	private AstParserRuleReturnScope<object, IToken> tryStatement()
	{
		EnterRule_tryStatement();
		EnterRule("tryStatement", 38);
		TraceIn("tryStatement", 38);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int tryStatement_StartIndex = input.Index;

		object root_0 = default(object);

		IToken string_literal219 = default(IToken);
		IToken LT220 = default(IToken);
		IToken LT222 = default(IToken);
		IToken LT225 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statementBlock221 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> finallyClause223 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> catchClause224 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> finallyClause226 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal219_tree = default(object);
		object LT220_tree = default(object);
		object LT222_tree = default(object);
		object LT225_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "tryStatement");
		DebugLocation(185, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 38)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:186:2: ( 'try' ( LT !)* statementBlock ( LT !)* ( finallyClause | catchClause ( ( LT !)* finallyClause )? ) )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:186:4: 'try' ( LT !)* statementBlock ( LT !)* ( finallyClause | catchClause ( ( LT !)* finallyClause )? )
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(186, 4);
			string_literal219=(IToken)Match(input,95,Follow._95_in_tryStatement1148); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal219_tree = (object)adaptor.Create(string_literal219);
			adaptor.AddChild(root_0, string_literal219_tree);
			}
			DebugLocation(186, 12);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:186:12: ( LT !)*
			try { DebugEnterSubRule(103);
			while (true)
			{
				int alt103=2;
				try { DebugEnterDecision(103, false);
				int LA103_1 = input.LA(1);

				if ((LA103_1==LT))
				{
					alt103 = 1;
				}


				} finally { DebugExitDecision(103); }
				switch ( alt103 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:186:12: LT !
					{
					DebugLocation(186, 12);
					LT220=(IToken)Match(input,LT,Follow._LT_in_tryStatement1150); if (state.failed) return retval;

					}
					break;

				default:
					goto loop103;
				}
			}

			loop103:
				;

			} finally { DebugExitSubRule(103); }

			DebugLocation(186, 15);
			PushFollow(Follow._statementBlock_in_tryStatement1154);
			statementBlock221=statementBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, statementBlock221.Tree);
			DebugLocation(186, 32);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:186:32: ( LT !)*
			try { DebugEnterSubRule(104);
			while (true)
			{
				int alt104=2;
				try { DebugEnterDecision(104, false);
				int LA104_1 = input.LA(1);

				if ((LA104_1==LT))
				{
					alt104 = 1;
				}


				} finally { DebugExitDecision(104); }
				switch ( alt104 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:186:32: LT !
					{
					DebugLocation(186, 32);
					LT222=(IToken)Match(input,LT,Follow._LT_in_tryStatement1156); if (state.failed) return retval;

					}
					break;

				default:
					goto loop104;
				}
			}

			loop104:
				;

			} finally { DebugExitSubRule(104); }

			DebugLocation(186, 35);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:186:35: ( finallyClause | catchClause ( ( LT !)* finallyClause )? )
			int alt107=2;
			try { DebugEnterSubRule(107);
			try { DebugEnterDecision(107, false);
			int LA107_1 = input.LA(1);

			if ((LA107_1==82))
			{
				alt107 = 1;
			}
			else if ((LA107_1==75))
			{
				alt107 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 107, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(107); }
			switch (alt107)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:186:36: finallyClause
				{
				DebugLocation(186, 36);
				PushFollow(Follow._finallyClause_in_tryStatement1161);
				finallyClause223=finallyClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, finallyClause223.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:186:52: catchClause ( ( LT !)* finallyClause )?
				{
				DebugLocation(186, 52);
				PushFollow(Follow._catchClause_in_tryStatement1165);
				catchClause224=catchClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, catchClause224.Tree);
				DebugLocation(186, 64);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:186:64: ( ( LT !)* finallyClause )?
				int alt106=2;
				try { DebugEnterSubRule(106);
				try { DebugEnterDecision(106, false);
				try
				{
					alt106 = dfa106.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(106); }
				switch (alt106)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:186:65: ( LT !)* finallyClause
					{
					DebugLocation(186, 67);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:186:67: ( LT !)*
					try { DebugEnterSubRule(105);
					while (true)
					{
						int alt105=2;
						try { DebugEnterDecision(105, false);
						int LA105_1 = input.LA(1);

						if ((LA105_1==LT))
						{
							alt105 = 1;
						}


						} finally { DebugExitDecision(105); }
						switch ( alt105 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:186:67: LT !
							{
							DebugLocation(186, 67);
							LT225=(IToken)Match(input,LT,Follow._LT_in_tryStatement1168); if (state.failed) return retval;

							}
							break;

						default:
							goto loop105;
						}
					}

					loop105:
						;

					} finally { DebugExitSubRule(105); }

					DebugLocation(186, 70);
					PushFollow(Follow._finallyClause_in_tryStatement1172);
					finallyClause226=finallyClause();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, finallyClause226.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(106); }


				}
				break;

			}
			} finally { DebugExitSubRule(107); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("tryStatement", 38);
			LeaveRule("tryStatement", 38);
			LeaveRule_tryStatement();
			if (state.backtracking > 0) { Memoize(input, 38, tryStatement_StartIndex); }

		}
		DebugLocation(187, 1);
		} finally { DebugExitRule(GrammarFileName, "tryStatement"); }
		return retval;

	}
	// $ANTLR end "tryStatement"

	partial void EnterRule_catchClause();
	partial void LeaveRule_catchClause();
	// $ANTLR start "catchClause"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:189:1: catchClause : 'catch' ( LT !)* '(' ( LT !)* Identifier ( LT !)* ')' ( LT !)* statementBlock ;
	[GrammarRule("catchClause")]
	private AstParserRuleReturnScope<object, IToken> catchClause()
	{
		EnterRule_catchClause();
		EnterRule("catchClause", 39);
		TraceIn("catchClause", 39);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int catchClause_StartIndex = input.Index;

		object root_0 = default(object);

		IToken string_literal227 = default(IToken);
		IToken LT228 = default(IToken);
		IToken char_literal229 = default(IToken);
		IToken LT230 = default(IToken);
		IToken Identifier231 = default(IToken);
		IToken LT232 = default(IToken);
		IToken char_literal233 = default(IToken);
		IToken LT234 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statementBlock235 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal227_tree = default(object);
		object LT228_tree = default(object);
		object char_literal229_tree = default(object);
		object LT230_tree = default(object);
		object Identifier231_tree = default(object);
		object LT232_tree = default(object);
		object char_literal233_tree = default(object);
		object LT234_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "catchClause");
		DebugLocation(189, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 39)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:190:2: ( 'catch' ( LT !)* '(' ( LT !)* Identifier ( LT !)* ')' ( LT !)* statementBlock )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:190:4: 'catch' ( LT !)* '(' ( LT !)* Identifier ( LT !)* ')' ( LT !)* statementBlock
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(190, 4);
			string_literal227=(IToken)Match(input,75,Follow._75_in_catchClause1193); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal227_tree = (object)adaptor.Create(string_literal227);
			adaptor.AddChild(root_0, string_literal227_tree);
			}
			DebugLocation(190, 14);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:190:14: ( LT !)*
			try { DebugEnterSubRule(108);
			while (true)
			{
				int alt108=2;
				try { DebugEnterDecision(108, false);
				int LA108_1 = input.LA(1);

				if ((LA108_1==LT))
				{
					alt108 = 1;
				}


				} finally { DebugExitDecision(108); }
				switch ( alt108 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:190:14: LT !
					{
					DebugLocation(190, 14);
					LT228=(IToken)Match(input,LT,Follow._LT_in_catchClause1195); if (state.failed) return retval;

					}
					break;

				default:
					goto loop108;
				}
			}

			loop108:
				;

			} finally { DebugExitSubRule(108); }

			DebugLocation(190, 17);
			char_literal229=(IToken)Match(input,39,Follow._39_in_catchClause1199); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal229_tree = (object)adaptor.Create(char_literal229);
			adaptor.AddChild(root_0, char_literal229_tree);
			}
			DebugLocation(190, 23);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:190:23: ( LT !)*
			try { DebugEnterSubRule(109);
			while (true)
			{
				int alt109=2;
				try { DebugEnterDecision(109, false);
				int LA109_1 = input.LA(1);

				if ((LA109_1==LT))
				{
					alt109 = 1;
				}


				} finally { DebugExitDecision(109); }
				switch ( alt109 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:190:23: LT !
					{
					DebugLocation(190, 23);
					LT230=(IToken)Match(input,LT,Follow._LT_in_catchClause1201); if (state.failed) return retval;

					}
					break;

				default:
					goto loop109;
				}
			}

			loop109:
				;

			} finally { DebugExitSubRule(109); }

			DebugLocation(190, 26);
			Identifier231=(IToken)Match(input,Identifier,Follow._Identifier_in_catchClause1205); if (state.failed) return retval;
			if (state.backtracking == 0) {
			Identifier231_tree = (object)adaptor.Create(Identifier231);
			adaptor.AddChild(root_0, Identifier231_tree);
			}
			DebugLocation(190, 39);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:190:39: ( LT !)*
			try { DebugEnterSubRule(110);
			while (true)
			{
				int alt110=2;
				try { DebugEnterDecision(110, false);
				int LA110_1 = input.LA(1);

				if ((LA110_1==LT))
				{
					alt110 = 1;
				}


				} finally { DebugExitDecision(110); }
				switch ( alt110 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:190:39: LT !
					{
					DebugLocation(190, 39);
					LT232=(IToken)Match(input,LT,Follow._LT_in_catchClause1207); if (state.failed) return retval;

					}
					break;

				default:
					goto loop110;
				}
			}

			loop110:
				;

			} finally { DebugExitSubRule(110); }

			DebugLocation(190, 42);
			char_literal233=(IToken)Match(input,40,Follow._40_in_catchClause1211); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal233_tree = (object)adaptor.Create(char_literal233);
			adaptor.AddChild(root_0, char_literal233_tree);
			}
			DebugLocation(190, 48);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:190:48: ( LT !)*
			try { DebugEnterSubRule(111);
			while (true)
			{
				int alt111=2;
				try { DebugEnterDecision(111, false);
				int LA111_1 = input.LA(1);

				if ((LA111_1==LT))
				{
					alt111 = 1;
				}


				} finally { DebugExitDecision(111); }
				switch ( alt111 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:190:48: LT !
					{
					DebugLocation(190, 48);
					LT234=(IToken)Match(input,LT,Follow._LT_in_catchClause1213); if (state.failed) return retval;

					}
					break;

				default:
					goto loop111;
				}
			}

			loop111:
				;

			} finally { DebugExitSubRule(111); }

			DebugLocation(190, 51);
			PushFollow(Follow._statementBlock_in_catchClause1217);
			statementBlock235=statementBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, statementBlock235.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("catchClause", 39);
			LeaveRule("catchClause", 39);
			LeaveRule_catchClause();
			if (state.backtracking > 0) { Memoize(input, 39, catchClause_StartIndex); }

		}
		DebugLocation(191, 1);
		} finally { DebugExitRule(GrammarFileName, "catchClause"); }
		return retval;

	}
	// $ANTLR end "catchClause"

	partial void EnterRule_finallyClause();
	partial void LeaveRule_finallyClause();
	// $ANTLR start "finallyClause"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:193:1: finallyClause : 'finally' ( LT !)* statementBlock ;
	[GrammarRule("finallyClause")]
	private AstParserRuleReturnScope<object, IToken> finallyClause()
	{
		EnterRule_finallyClause();
		EnterRule("finallyClause", 40);
		TraceIn("finallyClause", 40);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int finallyClause_StartIndex = input.Index;

		object root_0 = default(object);

		IToken string_literal236 = default(IToken);
		IToken LT237 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statementBlock238 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal236_tree = default(object);
		object LT237_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "finallyClause");
		DebugLocation(193, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 40)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:194:2: ( 'finally' ( LT !)* statementBlock )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:194:4: 'finally' ( LT !)* statementBlock
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(194, 4);
			string_literal236=(IToken)Match(input,82,Follow._82_in_finallyClause1229); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal236_tree = (object)adaptor.Create(string_literal236);
			adaptor.AddChild(root_0, string_literal236_tree);
			}
			DebugLocation(194, 16);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:194:16: ( LT !)*
			try { DebugEnterSubRule(112);
			while (true)
			{
				int alt112=2;
				try { DebugEnterDecision(112, false);
				int LA112_1 = input.LA(1);

				if ((LA112_1==LT))
				{
					alt112 = 1;
				}


				} finally { DebugExitDecision(112); }
				switch ( alt112 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:194:16: LT !
					{
					DebugLocation(194, 16);
					LT237=(IToken)Match(input,LT,Follow._LT_in_finallyClause1231); if (state.failed) return retval;

					}
					break;

				default:
					goto loop112;
				}
			}

			loop112:
				;

			} finally { DebugExitSubRule(112); }

			DebugLocation(194, 19);
			PushFollow(Follow._statementBlock_in_finallyClause1235);
			statementBlock238=statementBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, statementBlock238.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("finallyClause", 40);
			LeaveRule("finallyClause", 40);
			LeaveRule_finallyClause();
			if (state.backtracking > 0) { Memoize(input, 40, finallyClause_StartIndex); }

		}
		DebugLocation(195, 1);
		} finally { DebugExitRule(GrammarFileName, "finallyClause"); }
		return retval;

	}
	// $ANTLR end "finallyClause"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();
	// $ANTLR start "expression"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:198:1: expression : assignmentExpression ( ( LT !)* ',' ( LT !)* assignmentExpression )* ;
	[GrammarRule("expression")]
	private AstParserRuleReturnScope<object, IToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 41);
		TraceIn("expression", 41);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int expression_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT240 = default(IToken);
		IToken char_literal241 = default(IToken);
		IToken LT242 = default(IToken);
		AstParserRuleReturnScope<object, IToken> assignmentExpression239 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpression243 = default(AstParserRuleReturnScope<object, IToken>);

		object LT240_tree = default(object);
		object char_literal241_tree = default(object);
		object LT242_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(198, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 41)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:199:2: ( assignmentExpression ( ( LT !)* ',' ( LT !)* assignmentExpression )* )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:199:4: assignmentExpression ( ( LT !)* ',' ( LT !)* assignmentExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(199, 4);
			PushFollow(Follow._assignmentExpression_in_expression1247);
			assignmentExpression239=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression239.Tree);
			DebugLocation(199, 25);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:199:25: ( ( LT !)* ',' ( LT !)* assignmentExpression )*
			try { DebugEnterSubRule(115);
			while (true)
			{
				int alt115=2;
				try { DebugEnterDecision(115, false);
				try
				{
					alt115 = dfa115.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(115); }
				switch ( alt115 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:199:26: ( LT !)* ',' ( LT !)* assignmentExpression
					{
					DebugLocation(199, 28);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:199:28: ( LT !)*
					try { DebugEnterSubRule(113);
					while (true)
					{
						int alt113=2;
						try { DebugEnterDecision(113, false);
						int LA113_1 = input.LA(1);

						if ((LA113_1==LT))
						{
							alt113 = 1;
						}


						} finally { DebugExitDecision(113); }
						switch ( alt113 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:199:28: LT !
							{
							DebugLocation(199, 28);
							LT240=(IToken)Match(input,LT,Follow._LT_in_expression1250); if (state.failed) return retval;

							}
							break;

						default:
							goto loop113;
						}
					}

					loop113:
						;

					} finally { DebugExitSubRule(113); }

					DebugLocation(199, 31);
					char_literal241=(IToken)Match(input,46,Follow._46_in_expression1254); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal241_tree = (object)adaptor.Create(char_literal241);
					adaptor.AddChild(root_0, char_literal241_tree);
					}
					DebugLocation(199, 37);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:199:37: ( LT !)*
					try { DebugEnterSubRule(114);
					while (true)
					{
						int alt114=2;
						try { DebugEnterDecision(114, false);
						int LA114_1 = input.LA(1);

						if ((LA114_1==LT))
						{
							alt114 = 1;
						}


						} finally { DebugExitDecision(114); }
						switch ( alt114 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:199:37: LT !
							{
							DebugLocation(199, 37);
							LT242=(IToken)Match(input,LT,Follow._LT_in_expression1256); if (state.failed) return retval;

							}
							break;

						default:
							goto loop114;
						}
					}

					loop114:
						;

					} finally { DebugExitSubRule(114); }

					DebugLocation(199, 40);
					PushFollow(Follow._assignmentExpression_in_expression1260);
					assignmentExpression243=assignmentExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression243.Tree);

					}
					break;

				default:
					goto loop115;
				}
			}

			loop115:
				;

			} finally { DebugExitSubRule(115); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 41);
			LeaveRule("expression", 41);
			LeaveRule_expression();
			if (state.backtracking > 0) { Memoize(input, 41, expression_StartIndex); }

		}
		DebugLocation(200, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"

	partial void EnterRule_expressionNoIn();
	partial void LeaveRule_expressionNoIn();
	// $ANTLR start "expressionNoIn"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:202:1: expressionNoIn : assignmentExpressionNoIn ( ( LT !)* ',' ( LT !)* assignmentExpressionNoIn )* ;
	[GrammarRule("expressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> expressionNoIn()
	{
		EnterRule_expressionNoIn();
		EnterRule("expressionNoIn", 42);
		TraceIn("expressionNoIn", 42);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int expressionNoIn_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT245 = default(IToken);
		IToken char_literal246 = default(IToken);
		IToken LT247 = default(IToken);
		AstParserRuleReturnScope<object, IToken> assignmentExpressionNoIn244 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpressionNoIn248 = default(AstParserRuleReturnScope<object, IToken>);

		object LT245_tree = default(object);
		object char_literal246_tree = default(object);
		object LT247_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "expressionNoIn");
		DebugLocation(202, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 42)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:203:2: ( assignmentExpressionNoIn ( ( LT !)* ',' ( LT !)* assignmentExpressionNoIn )* )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:203:4: assignmentExpressionNoIn ( ( LT !)* ',' ( LT !)* assignmentExpressionNoIn )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(203, 4);
			PushFollow(Follow._assignmentExpressionNoIn_in_expressionNoIn1274);
			assignmentExpressionNoIn244=assignmentExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpressionNoIn244.Tree);
			DebugLocation(203, 29);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:203:29: ( ( LT !)* ',' ( LT !)* assignmentExpressionNoIn )*
			try { DebugEnterSubRule(118);
			while (true)
			{
				int alt118=2;
				try { DebugEnterDecision(118, false);
				try
				{
					alt118 = dfa118.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(118); }
				switch ( alt118 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:203:30: ( LT !)* ',' ( LT !)* assignmentExpressionNoIn
					{
					DebugLocation(203, 32);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:203:32: ( LT !)*
					try { DebugEnterSubRule(116);
					while (true)
					{
						int alt116=2;
						try { DebugEnterDecision(116, false);
						int LA116_1 = input.LA(1);

						if ((LA116_1==LT))
						{
							alt116 = 1;
						}


						} finally { DebugExitDecision(116); }
						switch ( alt116 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:203:32: LT !
							{
							DebugLocation(203, 32);
							LT245=(IToken)Match(input,LT,Follow._LT_in_expressionNoIn1277); if (state.failed) return retval;

							}
							break;

						default:
							goto loop116;
						}
					}

					loop116:
						;

					} finally { DebugExitSubRule(116); }

					DebugLocation(203, 35);
					char_literal246=(IToken)Match(input,46,Follow._46_in_expressionNoIn1281); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal246_tree = (object)adaptor.Create(char_literal246);
					adaptor.AddChild(root_0, char_literal246_tree);
					}
					DebugLocation(203, 41);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:203:41: ( LT !)*
					try { DebugEnterSubRule(117);
					while (true)
					{
						int alt117=2;
						try { DebugEnterDecision(117, false);
						int LA117_1 = input.LA(1);

						if ((LA117_1==LT))
						{
							alt117 = 1;
						}


						} finally { DebugExitDecision(117); }
						switch ( alt117 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:203:41: LT !
							{
							DebugLocation(203, 41);
							LT247=(IToken)Match(input,LT,Follow._LT_in_expressionNoIn1283); if (state.failed) return retval;

							}
							break;

						default:
							goto loop117;
						}
					}

					loop117:
						;

					} finally { DebugExitSubRule(117); }

					DebugLocation(203, 44);
					PushFollow(Follow._assignmentExpressionNoIn_in_expressionNoIn1287);
					assignmentExpressionNoIn248=assignmentExpressionNoIn();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpressionNoIn248.Tree);

					}
					break;

				default:
					goto loop118;
				}
			}

			loop118:
				;

			} finally { DebugExitSubRule(118); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expressionNoIn", 42);
			LeaveRule("expressionNoIn", 42);
			LeaveRule_expressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 42, expressionNoIn_StartIndex); }

		}
		DebugLocation(204, 1);
		} finally { DebugExitRule(GrammarFileName, "expressionNoIn"); }
		return retval;

	}
	// $ANTLR end "expressionNoIn"

	partial void EnterRule_assignmentExpression();
	partial void LeaveRule_assignmentExpression();
	// $ANTLR start "assignmentExpression"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:206:1: assignmentExpression : ( conditionalExpression | leftHandSideExpression ( LT !)* assignmentOperator ( LT !)* assignmentExpression );
	[GrammarRule("assignmentExpression")]
	private AstParserRuleReturnScope<object, IToken> assignmentExpression()
	{
		EnterRule_assignmentExpression();
		EnterRule("assignmentExpression", 43);
		TraceIn("assignmentExpression", 43);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int assignmentExpression_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT251 = default(IToken);
		IToken LT253 = default(IToken);
		AstParserRuleReturnScope<object, IToken> conditionalExpression249 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> leftHandSideExpression250 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentOperator252 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpression254 = default(AstParserRuleReturnScope<object, IToken>);

		object LT251_tree = default(object);
		object LT253_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "assignmentExpression");
		DebugLocation(206, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 43)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:207:2: ( conditionalExpression | leftHandSideExpression ( LT !)* assignmentOperator ( LT !)* assignmentExpression )
			int alt121=2;
			try { DebugEnterDecision(121, false);
			switch (input.LA(1))
			{
			case 92:
				{
				int LA121_2 = input.LA(2);

				if ((EvaluatePredicate(synpred140_TypeScript_fragment)))
				{
					alt121 = 1;
				}
				else if ((true))
				{
					alt121 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 121, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Identifier:
				{
				int LA121_2 = input.LA(2);

				if ((EvaluatePredicate(synpred140_TypeScript_fragment)))
				{
					alt121 = 1;
				}
				else if ((true))
				{
					alt121 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 121, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case NumericLiteral:
			case StringLiteral:
			case 81:
			case 89:
			case 94:
				{
				int LA121_2 = input.LA(2);

				if ((EvaluatePredicate(synpred140_TypeScript_fragment)))
				{
					alt121 = 1;
				}
				else if ((true))
				{
					alt121 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 121, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 69:
				{
				int LA121_2 = input.LA(2);

				if ((EvaluatePredicate(synpred140_TypeScript_fragment)))
				{
					alt121 = 1;
				}
				else if ((true))
				{
					alt121 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 121, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 101:
				{
				int LA121_2 = input.LA(2);

				if ((EvaluatePredicate(synpred140_TypeScript_fragment)))
				{
					alt121 = 1;
				}
				else if ((true))
				{
					alt121 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 121, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 39:
				{
				int LA121_2 = input.LA(2);

				if ((EvaluatePredicate(synpred140_TypeScript_fragment)))
				{
					alt121 = 1;
				}
				else if ((true))
				{
					alt121 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 121, 6, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 84:
				{
				int LA121_2 = input.LA(2);

				if ((EvaluatePredicate(synpred140_TypeScript_fragment)))
				{
					alt121 = 1;
				}
				else if ((true))
				{
					alt121 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 121, 7, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 88:
				{
				int LA121_2 = input.LA(2);

				if ((EvaluatePredicate(synpred140_TypeScript_fragment)))
				{
					alt121 = 1;
				}
				else if ((true))
				{
					alt121 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 121, 8, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 31:
			case 43:
			case 44:
			case 47:
			case 48:
			case 78:
			case 96:
			case 98:
			case 106:
				{
				alt121 = 1;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 121, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(121); }
			switch (alt121)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:207:4: conditionalExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(207, 4);
				PushFollow(Follow._conditionalExpression_in_assignmentExpression1301);
				conditionalExpression249=conditionalExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, conditionalExpression249.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:208:4: leftHandSideExpression ( LT !)* assignmentOperator ( LT !)* assignmentExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(208, 4);
				PushFollow(Follow._leftHandSideExpression_in_assignmentExpression1306);
				leftHandSideExpression250=leftHandSideExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, leftHandSideExpression250.Tree);
				DebugLocation(208, 29);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:208:29: ( LT !)*
				try { DebugEnterSubRule(119);
				while (true)
				{
					int alt119=2;
					try { DebugEnterDecision(119, false);
					int LA119_1 = input.LA(1);

					if ((LA119_1==LT))
					{
						alt119 = 1;
					}


					} finally { DebugExitDecision(119); }
					switch ( alt119 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:208:29: LT !
						{
						DebugLocation(208, 29);
						LT251=(IToken)Match(input,LT,Follow._LT_in_assignmentExpression1308); if (state.failed) return retval;

						}
						break;

					default:
						goto loop119;
					}
				}

				loop119:
					;

				} finally { DebugExitSubRule(119); }

				DebugLocation(208, 32);
				PushFollow(Follow._assignmentOperator_in_assignmentExpression1312);
				assignmentOperator252=assignmentOperator();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentOperator252.Tree);
				DebugLocation(208, 53);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:208:53: ( LT !)*
				try { DebugEnterSubRule(120);
				while (true)
				{
					int alt120=2;
					try { DebugEnterDecision(120, false);
					int LA120_1 = input.LA(1);

					if ((LA120_1==LT))
					{
						alt120 = 1;
					}


					} finally { DebugExitDecision(120); }
					switch ( alt120 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:208:53: LT !
						{
						DebugLocation(208, 53);
						LT253=(IToken)Match(input,LT,Follow._LT_in_assignmentExpression1314); if (state.failed) return retval;

						}
						break;

					default:
						goto loop120;
					}
				}

				loop120:
					;

				} finally { DebugExitSubRule(120); }

				DebugLocation(208, 56);
				PushFollow(Follow._assignmentExpression_in_assignmentExpression1318);
				assignmentExpression254=assignmentExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression254.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignmentExpression", 43);
			LeaveRule("assignmentExpression", 43);
			LeaveRule_assignmentExpression();
			if (state.backtracking > 0) { Memoize(input, 43, assignmentExpression_StartIndex); }

		}
		DebugLocation(209, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentExpression"); }
		return retval;

	}
	// $ANTLR end "assignmentExpression"

	partial void EnterRule_assignmentExpressionNoIn();
	partial void LeaveRule_assignmentExpressionNoIn();
	// $ANTLR start "assignmentExpressionNoIn"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:211:1: assignmentExpressionNoIn : ( conditionalExpressionNoIn | leftHandSideExpression ( LT !)* assignmentOperator ( LT !)* assignmentExpressionNoIn );
	[GrammarRule("assignmentExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> assignmentExpressionNoIn()
	{
		EnterRule_assignmentExpressionNoIn();
		EnterRule("assignmentExpressionNoIn", 44);
		TraceIn("assignmentExpressionNoIn", 44);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int assignmentExpressionNoIn_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT257 = default(IToken);
		IToken LT259 = default(IToken);
		AstParserRuleReturnScope<object, IToken> conditionalExpressionNoIn255 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> leftHandSideExpression256 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentOperator258 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpressionNoIn260 = default(AstParserRuleReturnScope<object, IToken>);

		object LT257_tree = default(object);
		object LT259_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "assignmentExpressionNoIn");
		DebugLocation(211, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 44)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:212:2: ( conditionalExpressionNoIn | leftHandSideExpression ( LT !)* assignmentOperator ( LT !)* assignmentExpressionNoIn )
			int alt124=2;
			try { DebugEnterDecision(124, false);
			switch (input.LA(1))
			{
			case 92:
				{
				int LA124_2 = input.LA(2);

				if ((EvaluatePredicate(synpred143_TypeScript_fragment)))
				{
					alt124 = 1;
				}
				else if ((true))
				{
					alt124 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 124, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Identifier:
				{
				int LA124_2 = input.LA(2);

				if ((EvaluatePredicate(synpred143_TypeScript_fragment)))
				{
					alt124 = 1;
				}
				else if ((true))
				{
					alt124 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 124, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case NumericLiteral:
			case StringLiteral:
			case 81:
			case 89:
			case 94:
				{
				int LA124_2 = input.LA(2);

				if ((EvaluatePredicate(synpred143_TypeScript_fragment)))
				{
					alt124 = 1;
				}
				else if ((true))
				{
					alt124 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 124, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 69:
				{
				int LA124_2 = input.LA(2);

				if ((EvaluatePredicate(synpred143_TypeScript_fragment)))
				{
					alt124 = 1;
				}
				else if ((true))
				{
					alt124 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 124, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 101:
				{
				int LA124_2 = input.LA(2);

				if ((EvaluatePredicate(synpred143_TypeScript_fragment)))
				{
					alt124 = 1;
				}
				else if ((true))
				{
					alt124 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 124, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 39:
				{
				int LA124_2 = input.LA(2);

				if ((EvaluatePredicate(synpred143_TypeScript_fragment)))
				{
					alt124 = 1;
				}
				else if ((true))
				{
					alt124 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 124, 6, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 84:
				{
				int LA124_2 = input.LA(2);

				if ((EvaluatePredicate(synpred143_TypeScript_fragment)))
				{
					alt124 = 1;
				}
				else if ((true))
				{
					alt124 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 124, 7, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 88:
				{
				int LA124_2 = input.LA(2);

				if ((EvaluatePredicate(synpred143_TypeScript_fragment)))
				{
					alt124 = 1;
				}
				else if ((true))
				{
					alt124 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 124, 8, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 31:
			case 43:
			case 44:
			case 47:
			case 48:
			case 78:
			case 96:
			case 98:
			case 106:
				{
				alt124 = 1;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 124, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(124); }
			switch (alt124)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:212:4: conditionalExpressionNoIn
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(212, 4);
				PushFollow(Follow._conditionalExpressionNoIn_in_assignmentExpressionNoIn1330);
				conditionalExpressionNoIn255=conditionalExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, conditionalExpressionNoIn255.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:213:4: leftHandSideExpression ( LT !)* assignmentOperator ( LT !)* assignmentExpressionNoIn
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(213, 4);
				PushFollow(Follow._leftHandSideExpression_in_assignmentExpressionNoIn1335);
				leftHandSideExpression256=leftHandSideExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, leftHandSideExpression256.Tree);
				DebugLocation(213, 29);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:213:29: ( LT !)*
				try { DebugEnterSubRule(122);
				while (true)
				{
					int alt122=2;
					try { DebugEnterDecision(122, false);
					int LA122_1 = input.LA(1);

					if ((LA122_1==LT))
					{
						alt122 = 1;
					}


					} finally { DebugExitDecision(122); }
					switch ( alt122 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:213:29: LT !
						{
						DebugLocation(213, 29);
						LT257=(IToken)Match(input,LT,Follow._LT_in_assignmentExpressionNoIn1337); if (state.failed) return retval;

						}
						break;

					default:
						goto loop122;
					}
				}

				loop122:
					;

				} finally { DebugExitSubRule(122); }

				DebugLocation(213, 32);
				PushFollow(Follow._assignmentOperator_in_assignmentExpressionNoIn1341);
				assignmentOperator258=assignmentOperator();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentOperator258.Tree);
				DebugLocation(213, 53);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:213:53: ( LT !)*
				try { DebugEnterSubRule(123);
				while (true)
				{
					int alt123=2;
					try { DebugEnterDecision(123, false);
					int LA123_1 = input.LA(1);

					if ((LA123_1==LT))
					{
						alt123 = 1;
					}


					} finally { DebugExitDecision(123); }
					switch ( alt123 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:213:53: LT !
						{
						DebugLocation(213, 53);
						LT259=(IToken)Match(input,LT,Follow._LT_in_assignmentExpressionNoIn1343); if (state.failed) return retval;

						}
						break;

					default:
						goto loop123;
					}
				}

				loop123:
					;

				} finally { DebugExitSubRule(123); }

				DebugLocation(213, 56);
				PushFollow(Follow._assignmentExpressionNoIn_in_assignmentExpressionNoIn1347);
				assignmentExpressionNoIn260=assignmentExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpressionNoIn260.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignmentExpressionNoIn", 44);
			LeaveRule("assignmentExpressionNoIn", 44);
			LeaveRule_assignmentExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 44, assignmentExpressionNoIn_StartIndex); }

		}
		DebugLocation(214, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "assignmentExpressionNoIn"

	partial void EnterRule_leftHandSideExpression();
	partial void LeaveRule_leftHandSideExpression();
	// $ANTLR start "leftHandSideExpression"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:216:1: leftHandSideExpression : ( callExpression | newExpression );
	[GrammarRule("leftHandSideExpression")]
	private AstParserRuleReturnScope<object, IToken> leftHandSideExpression()
	{
		EnterRule_leftHandSideExpression();
		EnterRule("leftHandSideExpression", 45);
		TraceIn("leftHandSideExpression", 45);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int leftHandSideExpression_StartIndex = input.Index;

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> callExpression261 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> newExpression262 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "leftHandSideExpression");
		DebugLocation(216, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 45)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:217:2: ( callExpression | newExpression )
			int alt125=2;
			try { DebugEnterDecision(125, false);
			switch (input.LA(1))
			{
			case 92:
				{
				int LA125_2 = input.LA(2);

				if ((EvaluatePredicate(synpred146_TypeScript_fragment)))
				{
					alt125 = 1;
				}
				else if ((true))
				{
					alt125 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 125, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Identifier:
				{
				int LA125_2 = input.LA(2);

				if ((EvaluatePredicate(synpred146_TypeScript_fragment)))
				{
					alt125 = 1;
				}
				else if ((true))
				{
					alt125 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 125, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case NumericLiteral:
			case StringLiteral:
			case 81:
			case 89:
			case 94:
				{
				int LA125_2 = input.LA(2);

				if ((EvaluatePredicate(synpred146_TypeScript_fragment)))
				{
					alt125 = 1;
				}
				else if ((true))
				{
					alt125 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 125, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 69:
				{
				int LA125_2 = input.LA(2);

				if ((EvaluatePredicate(synpred146_TypeScript_fragment)))
				{
					alt125 = 1;
				}
				else if ((true))
				{
					alt125 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 125, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 101:
				{
				int LA125_2 = input.LA(2);

				if ((EvaluatePredicate(synpred146_TypeScript_fragment)))
				{
					alt125 = 1;
				}
				else if ((true))
				{
					alt125 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 125, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 39:
				{
				int LA125_2 = input.LA(2);

				if ((EvaluatePredicate(synpred146_TypeScript_fragment)))
				{
					alt125 = 1;
				}
				else if ((true))
				{
					alt125 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 125, 6, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 84:
				{
				int LA125_2 = input.LA(2);

				if ((EvaluatePredicate(synpred146_TypeScript_fragment)))
				{
					alt125 = 1;
				}
				else if ((true))
				{
					alt125 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 125, 7, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 88:
				{
				int LA125_2 = input.LA(2);

				if ((EvaluatePredicate(synpred146_TypeScript_fragment)))
				{
					alt125 = 1;
				}
				else if ((true))
				{
					alt125 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 125, 8, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 125, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(125); }
			switch (alt125)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:217:4: callExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(217, 4);
				PushFollow(Follow._callExpression_in_leftHandSideExpression1359);
				callExpression261=callExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, callExpression261.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:218:4: newExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(218, 4);
				PushFollow(Follow._newExpression_in_leftHandSideExpression1364);
				newExpression262=newExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, newExpression262.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("leftHandSideExpression", 45);
			LeaveRule("leftHandSideExpression", 45);
			LeaveRule_leftHandSideExpression();
			if (state.backtracking > 0) { Memoize(input, 45, leftHandSideExpression_StartIndex); }

		}
		DebugLocation(219, 1);
		} finally { DebugExitRule(GrammarFileName, "leftHandSideExpression"); }
		return retval;

	}
	// $ANTLR end "leftHandSideExpression"

	partial void EnterRule_newExpression();
	partial void LeaveRule_newExpression();
	// $ANTLR start "newExpression"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:221:1: newExpression : ( memberExpression | 'new' ( LT !)* newExpression );
	[GrammarRule("newExpression")]
	private AstParserRuleReturnScope<object, IToken> newExpression()
	{
		EnterRule_newExpression();
		EnterRule("newExpression", 46);
		TraceIn("newExpression", 46);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int newExpression_StartIndex = input.Index;

		object root_0 = default(object);

		IToken string_literal264 = default(IToken);
		IToken LT265 = default(IToken);
		AstParserRuleReturnScope<object, IToken> memberExpression263 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> newExpression266 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal264_tree = default(object);
		object LT265_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "newExpression");
		DebugLocation(221, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 46)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:222:2: ( memberExpression | 'new' ( LT !)* newExpression )
			int alt127=2;
			try { DebugEnterDecision(127, false);
			int LA127_1 = input.LA(1);

			if ((LA127_1==Identifier||LA127_1==NumericLiteral||LA127_1==StringLiteral||LA127_1==39||LA127_1==69||LA127_1==81||LA127_1==84||LA127_1==89||LA127_1==92||LA127_1==94||LA127_1==101))
			{
				alt127 = 1;
			}
			else if ((LA127_1==88))
			{
				int LA127_2 = input.LA(2);

				if ((EvaluatePredicate(synpred147_TypeScript_fragment)))
				{
					alt127 = 1;
				}
				else if ((true))
				{
					alt127 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 127, 8, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 127, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(127); }
			switch (alt127)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:222:4: memberExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(222, 4);
				PushFollow(Follow._memberExpression_in_newExpression1376);
				memberExpression263=memberExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, memberExpression263.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:223:4: 'new' ( LT !)* newExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(223, 4);
				string_literal264=(IToken)Match(input,88,Follow._88_in_newExpression1381); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal264_tree = (object)adaptor.Create(string_literal264);
				adaptor.AddChild(root_0, string_literal264_tree);
				}
				DebugLocation(223, 12);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:223:12: ( LT !)*
				try { DebugEnterSubRule(126);
				while (true)
				{
					int alt126=2;
					try { DebugEnterDecision(126, false);
					int LA126_1 = input.LA(1);

					if ((LA126_1==LT))
					{
						alt126 = 1;
					}


					} finally { DebugExitDecision(126); }
					switch ( alt126 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:223:12: LT !
						{
						DebugLocation(223, 12);
						LT265=(IToken)Match(input,LT,Follow._LT_in_newExpression1383); if (state.failed) return retval;

						}
						break;

					default:
						goto loop126;
					}
				}

				loop126:
					;

				} finally { DebugExitSubRule(126); }

				DebugLocation(223, 15);
				PushFollow(Follow._newExpression_in_newExpression1387);
				newExpression266=newExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, newExpression266.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("newExpression", 46);
			LeaveRule("newExpression", 46);
			LeaveRule_newExpression();
			if (state.backtracking > 0) { Memoize(input, 46, newExpression_StartIndex); }

		}
		DebugLocation(224, 1);
		} finally { DebugExitRule(GrammarFileName, "newExpression"); }
		return retval;

	}
	// $ANTLR end "newExpression"

	partial void EnterRule_memberExpression();
	partial void LeaveRule_memberExpression();
	// $ANTLR start "memberExpression"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:226:1: memberExpression : ( primaryExpression | functionExpression | 'new' ( LT !)* memberExpression ( LT !)* arguments ) ( ( LT !)* memberExpressionSuffix )* ;
	[GrammarRule("memberExpression")]
	private AstParserRuleReturnScope<object, IToken> memberExpression()
	{
		EnterRule_memberExpression();
		EnterRule("memberExpression", 47);
		TraceIn("memberExpression", 47);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int memberExpression_StartIndex = input.Index;

		object root_0 = default(object);

		IToken string_literal269 = default(IToken);
		IToken LT270 = default(IToken);
		IToken LT272 = default(IToken);
		IToken LT274 = default(IToken);
		AstParserRuleReturnScope<object, IToken> primaryExpression267 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> functionExpression268 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> memberExpression271 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> arguments273 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> memberExpressionSuffix275 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal269_tree = default(object);
		object LT270_tree = default(object);
		object LT272_tree = default(object);
		object LT274_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "memberExpression");
		DebugLocation(226, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 47)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:227:2: ( ( primaryExpression | functionExpression | 'new' ( LT !)* memberExpression ( LT !)* arguments ) ( ( LT !)* memberExpressionSuffix )* )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:227:4: ( primaryExpression | functionExpression | 'new' ( LT !)* memberExpression ( LT !)* arguments ) ( ( LT !)* memberExpressionSuffix )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(227, 4);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:227:4: ( primaryExpression | functionExpression | 'new' ( LT !)* memberExpression ( LT !)* arguments )
			int alt130=3;
			try { DebugEnterSubRule(130);
			try { DebugEnterDecision(130, false);
			switch (input.LA(1))
			{
			case Identifier:
			case NumericLiteral:
			case StringLiteral:
			case 39:
			case 69:
			case 81:
			case 89:
			case 92:
			case 94:
			case 101:
				{
				alt130 = 1;
				}
				break;
			case 84:
				{
				alt130 = 2;
				}
				break;
			case 88:
				{
				alt130 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 130, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(130); }
			switch (alt130)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:227:5: primaryExpression
				{
				DebugLocation(227, 5);
				PushFollow(Follow._primaryExpression_in_memberExpression1400);
				primaryExpression267=primaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, primaryExpression267.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:227:25: functionExpression
				{
				DebugLocation(227, 25);
				PushFollow(Follow._functionExpression_in_memberExpression1404);
				functionExpression268=functionExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, functionExpression268.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:227:46: 'new' ( LT !)* memberExpression ( LT !)* arguments
				{
				DebugLocation(227, 46);
				string_literal269=(IToken)Match(input,88,Follow._88_in_memberExpression1408); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal269_tree = (object)adaptor.Create(string_literal269);
				adaptor.AddChild(root_0, string_literal269_tree);
				}
				DebugLocation(227, 54);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:227:54: ( LT !)*
				try { DebugEnterSubRule(128);
				while (true)
				{
					int alt128=2;
					try { DebugEnterDecision(128, false);
					int LA128_1 = input.LA(1);

					if ((LA128_1==LT))
					{
						alt128 = 1;
					}


					} finally { DebugExitDecision(128); }
					switch ( alt128 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:227:54: LT !
						{
						DebugLocation(227, 54);
						LT270=(IToken)Match(input,LT,Follow._LT_in_memberExpression1410); if (state.failed) return retval;

						}
						break;

					default:
						goto loop128;
					}
				}

				loop128:
					;

				} finally { DebugExitSubRule(128); }

				DebugLocation(227, 57);
				PushFollow(Follow._memberExpression_in_memberExpression1414);
				memberExpression271=memberExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, memberExpression271.Tree);
				DebugLocation(227, 76);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:227:76: ( LT !)*
				try { DebugEnterSubRule(129);
				while (true)
				{
					int alt129=2;
					try { DebugEnterDecision(129, false);
					int LA129_1 = input.LA(1);

					if ((LA129_1==LT))
					{
						alt129 = 1;
					}


					} finally { DebugExitDecision(129); }
					switch ( alt129 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:227:76: LT !
						{
						DebugLocation(227, 76);
						LT272=(IToken)Match(input,LT,Follow._LT_in_memberExpression1416); if (state.failed) return retval;

						}
						break;

					default:
						goto loop129;
					}
				}

				loop129:
					;

				} finally { DebugExitSubRule(129); }

				DebugLocation(227, 79);
				PushFollow(Follow._arguments_in_memberExpression1420);
				arguments273=arguments();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, arguments273.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(130); }

			DebugLocation(227, 90);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:227:90: ( ( LT !)* memberExpressionSuffix )*
			try { DebugEnterSubRule(132);
			while (true)
			{
				int alt132=2;
				try { DebugEnterDecision(132, false);
				int LA132_1 = input.LA(1);

				if ((LA132_1==LT))
				{
					int LA132_2 = input.LA(2);

					if ((EvaluatePredicate(synpred154_TypeScript_fragment)))
					{
						alt132 = 1;
					}


				}
				else if ((LA132_1==50||LA132_1==69))
				{
					alt132 = 1;
				}


				} finally { DebugExitDecision(132); }
				switch ( alt132 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:227:91: ( LT !)* memberExpressionSuffix
					{
					DebugLocation(227, 93);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:227:93: ( LT !)*
					try { DebugEnterSubRule(131);
					while (true)
					{
						int alt131=2;
						try { DebugEnterDecision(131, false);
						int LA131_1 = input.LA(1);

						if ((LA131_1==LT))
						{
							alt131 = 1;
						}


						} finally { DebugExitDecision(131); }
						switch ( alt131 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:227:93: LT !
							{
							DebugLocation(227, 93);
							LT274=(IToken)Match(input,LT,Follow._LT_in_memberExpression1424); if (state.failed) return retval;

							}
							break;

						default:
							goto loop131;
						}
					}

					loop131:
						;

					} finally { DebugExitSubRule(131); }

					DebugLocation(227, 96);
					PushFollow(Follow._memberExpressionSuffix_in_memberExpression1428);
					memberExpressionSuffix275=memberExpressionSuffix();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, memberExpressionSuffix275.Tree);

					}
					break;

				default:
					goto loop132;
				}
			}

			loop132:
				;

			} finally { DebugExitSubRule(132); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("memberExpression", 47);
			LeaveRule("memberExpression", 47);
			LeaveRule_memberExpression();
			if (state.backtracking > 0) { Memoize(input, 47, memberExpression_StartIndex); }

		}
		DebugLocation(228, 1);
		} finally { DebugExitRule(GrammarFileName, "memberExpression"); }
		return retval;

	}
	// $ANTLR end "memberExpression"

	partial void EnterRule_memberExpressionSuffix();
	partial void LeaveRule_memberExpressionSuffix();
	// $ANTLR start "memberExpressionSuffix"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:230:1: memberExpressionSuffix : ( indexSuffix | propertyReferenceSuffix );
	[GrammarRule("memberExpressionSuffix")]
	private AstParserRuleReturnScope<object, IToken> memberExpressionSuffix()
	{
		EnterRule_memberExpressionSuffix();
		EnterRule("memberExpressionSuffix", 48);
		TraceIn("memberExpressionSuffix", 48);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int memberExpressionSuffix_StartIndex = input.Index;

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> indexSuffix276 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> propertyReferenceSuffix277 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "memberExpressionSuffix");
		DebugLocation(230, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 48)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:231:2: ( indexSuffix | propertyReferenceSuffix )
			int alt133=2;
			try { DebugEnterDecision(133, false);
			int LA133_1 = input.LA(1);

			if ((LA133_1==69))
			{
				alt133 = 1;
			}
			else if ((LA133_1==50))
			{
				alt133 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 133, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(133); }
			switch (alt133)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:231:4: indexSuffix
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(231, 4);
				PushFollow(Follow._indexSuffix_in_memberExpressionSuffix1442);
				indexSuffix276=indexSuffix();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, indexSuffix276.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:232:4: propertyReferenceSuffix
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(232, 4);
				PushFollow(Follow._propertyReferenceSuffix_in_memberExpressionSuffix1447);
				propertyReferenceSuffix277=propertyReferenceSuffix();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, propertyReferenceSuffix277.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("memberExpressionSuffix", 48);
			LeaveRule("memberExpressionSuffix", 48);
			LeaveRule_memberExpressionSuffix();
			if (state.backtracking > 0) { Memoize(input, 48, memberExpressionSuffix_StartIndex); }

		}
		DebugLocation(233, 1);
		} finally { DebugExitRule(GrammarFileName, "memberExpressionSuffix"); }
		return retval;

	}
	// $ANTLR end "memberExpressionSuffix"

	partial void EnterRule_callExpression();
	partial void LeaveRule_callExpression();
	// $ANTLR start "callExpression"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:235:1: callExpression : memberExpression ( LT !)* arguments ( ( LT !)* callExpressionSuffix )* ;
	[GrammarRule("callExpression")]
	private AstParserRuleReturnScope<object, IToken> callExpression()
	{
		EnterRule_callExpression();
		EnterRule("callExpression", 49);
		TraceIn("callExpression", 49);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int callExpression_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT279 = default(IToken);
		IToken LT281 = default(IToken);
		AstParserRuleReturnScope<object, IToken> memberExpression278 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> arguments280 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> callExpressionSuffix282 = default(AstParserRuleReturnScope<object, IToken>);

		object LT279_tree = default(object);
		object LT281_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "callExpression");
		DebugLocation(235, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 49)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:236:2: ( memberExpression ( LT !)* arguments ( ( LT !)* callExpressionSuffix )* )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:236:4: memberExpression ( LT !)* arguments ( ( LT !)* callExpressionSuffix )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(236, 4);
			PushFollow(Follow._memberExpression_in_callExpression1458);
			memberExpression278=memberExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, memberExpression278.Tree);
			DebugLocation(236, 23);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:236:23: ( LT !)*
			try { DebugEnterSubRule(134);
			while (true)
			{
				int alt134=2;
				try { DebugEnterDecision(134, false);
				int LA134_1 = input.LA(1);

				if ((LA134_1==LT))
				{
					alt134 = 1;
				}


				} finally { DebugExitDecision(134); }
				switch ( alt134 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:236:23: LT !
					{
					DebugLocation(236, 23);
					LT279=(IToken)Match(input,LT,Follow._LT_in_callExpression1460); if (state.failed) return retval;

					}
					break;

				default:
					goto loop134;
				}
			}

			loop134:
				;

			} finally { DebugExitSubRule(134); }

			DebugLocation(236, 26);
			PushFollow(Follow._arguments_in_callExpression1464);
			arguments280=arguments();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, arguments280.Tree);
			DebugLocation(236, 36);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:236:36: ( ( LT !)* callExpressionSuffix )*
			try { DebugEnterSubRule(136);
			while (true)
			{
				int alt136=2;
				try { DebugEnterDecision(136, false);
				int LA136_1 = input.LA(1);

				if ((LA136_1==LT))
				{
					int LA136_2 = input.LA(2);

					if ((EvaluatePredicate(synpred158_TypeScript_fragment)))
					{
						alt136 = 1;
					}


				}
				else if ((LA136_1==39||LA136_1==50||LA136_1==69))
				{
					alt136 = 1;
				}


				} finally { DebugExitDecision(136); }
				switch ( alt136 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:236:37: ( LT !)* callExpressionSuffix
					{
					DebugLocation(236, 39);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:236:39: ( LT !)*
					try { DebugEnterSubRule(135);
					while (true)
					{
						int alt135=2;
						try { DebugEnterDecision(135, false);
						int LA135_1 = input.LA(1);

						if ((LA135_1==LT))
						{
							alt135 = 1;
						}


						} finally { DebugExitDecision(135); }
						switch ( alt135 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:236:39: LT !
							{
							DebugLocation(236, 39);
							LT281=(IToken)Match(input,LT,Follow._LT_in_callExpression1467); if (state.failed) return retval;

							}
							break;

						default:
							goto loop135;
						}
					}

					loop135:
						;

					} finally { DebugExitSubRule(135); }

					DebugLocation(236, 42);
					PushFollow(Follow._callExpressionSuffix_in_callExpression1471);
					callExpressionSuffix282=callExpressionSuffix();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, callExpressionSuffix282.Tree);

					}
					break;

				default:
					goto loop136;
				}
			}

			loop136:
				;

			} finally { DebugExitSubRule(136); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("callExpression", 49);
			LeaveRule("callExpression", 49);
			LeaveRule_callExpression();
			if (state.backtracking > 0) { Memoize(input, 49, callExpression_StartIndex); }

		}
		DebugLocation(237, 1);
		} finally { DebugExitRule(GrammarFileName, "callExpression"); }
		return retval;

	}
	// $ANTLR end "callExpression"

	partial void EnterRule_callExpressionSuffix();
	partial void LeaveRule_callExpressionSuffix();
	// $ANTLR start "callExpressionSuffix"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:239:1: callExpressionSuffix : ( arguments | indexSuffix | propertyReferenceSuffix );
	[GrammarRule("callExpressionSuffix")]
	private AstParserRuleReturnScope<object, IToken> callExpressionSuffix()
	{
		EnterRule_callExpressionSuffix();
		EnterRule("callExpressionSuffix", 50);
		TraceIn("callExpressionSuffix", 50);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int callExpressionSuffix_StartIndex = input.Index;

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> arguments283 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> indexSuffix284 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> propertyReferenceSuffix285 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "callExpressionSuffix");
		DebugLocation(239, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 50)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:240:2: ( arguments | indexSuffix | propertyReferenceSuffix )
			int alt137=3;
			try { DebugEnterDecision(137, false);
			switch (input.LA(1))
			{
			case 39:
				{
				alt137 = 1;
				}
				break;
			case 69:
				{
				alt137 = 2;
				}
				break;
			case 50:
				{
				alt137 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 137, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(137); }
			switch (alt137)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:240:4: arguments
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(240, 4);
				PushFollow(Follow._arguments_in_callExpressionSuffix1485);
				arguments283=arguments();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, arguments283.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:241:4: indexSuffix
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(241, 4);
				PushFollow(Follow._indexSuffix_in_callExpressionSuffix1490);
				indexSuffix284=indexSuffix();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, indexSuffix284.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:242:4: propertyReferenceSuffix
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(242, 4);
				PushFollow(Follow._propertyReferenceSuffix_in_callExpressionSuffix1495);
				propertyReferenceSuffix285=propertyReferenceSuffix();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, propertyReferenceSuffix285.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("callExpressionSuffix", 50);
			LeaveRule("callExpressionSuffix", 50);
			LeaveRule_callExpressionSuffix();
			if (state.backtracking > 0) { Memoize(input, 50, callExpressionSuffix_StartIndex); }

		}
		DebugLocation(243, 1);
		} finally { DebugExitRule(GrammarFileName, "callExpressionSuffix"); }
		return retval;

	}
	// $ANTLR end "callExpressionSuffix"

	partial void EnterRule_arguments();
	partial void LeaveRule_arguments();
	// $ANTLR start "arguments"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:245:1: arguments : '(' ( ( LT !)* assignmentExpression ( ( LT !)* ',' ( LT !)* assignmentExpression )* )? ( LT !)* ')' ;
	[GrammarRule("arguments")]
	private AstParserRuleReturnScope<object, IToken> arguments()
	{
		EnterRule_arguments();
		EnterRule("arguments", 51);
		TraceIn("arguments", 51);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int arguments_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal286 = default(IToken);
		IToken LT287 = default(IToken);
		IToken LT289 = default(IToken);
		IToken char_literal290 = default(IToken);
		IToken LT291 = default(IToken);
		IToken LT293 = default(IToken);
		IToken char_literal294 = default(IToken);
		AstParserRuleReturnScope<object, IToken> assignmentExpression288 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpression292 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal286_tree = default(object);
		object LT287_tree = default(object);
		object LT289_tree = default(object);
		object char_literal290_tree = default(object);
		object LT291_tree = default(object);
		object LT293_tree = default(object);
		object char_literal294_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "arguments");
		DebugLocation(245, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 51)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:246:2: ( '(' ( ( LT !)* assignmentExpression ( ( LT !)* ',' ( LT !)* assignmentExpression )* )? ( LT !)* ')' )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:246:4: '(' ( ( LT !)* assignmentExpression ( ( LT !)* ',' ( LT !)* assignmentExpression )* )? ( LT !)* ')'
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(246, 4);
			char_literal286=(IToken)Match(input,39,Follow._39_in_arguments1506); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal286_tree = (object)adaptor.Create(char_literal286);
			adaptor.AddChild(root_0, char_literal286_tree);
			}
			DebugLocation(246, 8);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:246:8: ( ( LT !)* assignmentExpression ( ( LT !)* ',' ( LT !)* assignmentExpression )* )?
			int alt142=2;
			try { DebugEnterSubRule(142);
			try { DebugEnterDecision(142, false);
			try
			{
				alt142 = dfa142.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(142); }
			switch (alt142)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:246:9: ( LT !)* assignmentExpression ( ( LT !)* ',' ( LT !)* assignmentExpression )*
				{
				DebugLocation(246, 11);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:246:11: ( LT !)*
				try { DebugEnterSubRule(138);
				while (true)
				{
					int alt138=2;
					try { DebugEnterDecision(138, false);
					int LA138_1 = input.LA(1);

					if ((LA138_1==LT))
					{
						alt138 = 1;
					}


					} finally { DebugExitDecision(138); }
					switch ( alt138 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:246:11: LT !
						{
						DebugLocation(246, 11);
						LT287=(IToken)Match(input,LT,Follow._LT_in_arguments1509); if (state.failed) return retval;

						}
						break;

					default:
						goto loop138;
					}
				}

				loop138:
					;

				} finally { DebugExitSubRule(138); }

				DebugLocation(246, 14);
				PushFollow(Follow._assignmentExpression_in_arguments1513);
				assignmentExpression288=assignmentExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression288.Tree);
				DebugLocation(246, 35);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:246:35: ( ( LT !)* ',' ( LT !)* assignmentExpression )*
				try { DebugEnterSubRule(141);
				while (true)
				{
					int alt141=2;
					try { DebugEnterDecision(141, false);
					try
					{
						alt141 = dfa141.Predict(input);
					}
					catch (NoViableAltException nvae)
					{
						DebugRecognitionException(nvae);
						throw;
					}
					} finally { DebugExitDecision(141); }
					switch ( alt141 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:246:36: ( LT !)* ',' ( LT !)* assignmentExpression
						{
						DebugLocation(246, 38);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:246:38: ( LT !)*
						try { DebugEnterSubRule(139);
						while (true)
						{
							int alt139=2;
							try { DebugEnterDecision(139, false);
							int LA139_1 = input.LA(1);

							if ((LA139_1==LT))
							{
								alt139 = 1;
							}


							} finally { DebugExitDecision(139); }
							switch ( alt139 )
							{
							case 1:
								DebugEnterAlt(1);
								// C:\\DEVGIT\\typesharp\\TypeScript.g:246:38: LT !
								{
								DebugLocation(246, 38);
								LT289=(IToken)Match(input,LT,Follow._LT_in_arguments1516); if (state.failed) return retval;

								}
								break;

							default:
								goto loop139;
							}
						}

						loop139:
							;

						} finally { DebugExitSubRule(139); }

						DebugLocation(246, 41);
						char_literal290=(IToken)Match(input,46,Follow._46_in_arguments1520); if (state.failed) return retval;
						if (state.backtracking == 0) {
						char_literal290_tree = (object)adaptor.Create(char_literal290);
						adaptor.AddChild(root_0, char_literal290_tree);
						}
						DebugLocation(246, 47);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:246:47: ( LT !)*
						try { DebugEnterSubRule(140);
						while (true)
						{
							int alt140=2;
							try { DebugEnterDecision(140, false);
							int LA140_1 = input.LA(1);

							if ((LA140_1==LT))
							{
								alt140 = 1;
							}


							} finally { DebugExitDecision(140); }
							switch ( alt140 )
							{
							case 1:
								DebugEnterAlt(1);
								// C:\\DEVGIT\\typesharp\\TypeScript.g:246:47: LT !
								{
								DebugLocation(246, 47);
								LT291=(IToken)Match(input,LT,Follow._LT_in_arguments1522); if (state.failed) return retval;

								}
								break;

							default:
								goto loop140;
							}
						}

						loop140:
							;

						} finally { DebugExitSubRule(140); }

						DebugLocation(246, 50);
						PushFollow(Follow._assignmentExpression_in_arguments1526);
						assignmentExpression292=assignmentExpression();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression292.Tree);

						}
						break;

					default:
						goto loop141;
					}
				}

				loop141:
					;

				} finally { DebugExitSubRule(141); }


				}
				break;

			}
			} finally { DebugExitSubRule(142); }

			DebugLocation(246, 77);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:246:77: ( LT !)*
			try { DebugEnterSubRule(143);
			while (true)
			{
				int alt143=2;
				try { DebugEnterDecision(143, false);
				int LA143_1 = input.LA(1);

				if ((LA143_1==LT))
				{
					alt143 = 1;
				}


				} finally { DebugExitDecision(143); }
				switch ( alt143 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:246:77: LT !
					{
					DebugLocation(246, 77);
					LT293=(IToken)Match(input,LT,Follow._LT_in_arguments1532); if (state.failed) return retval;

					}
					break;

				default:
					goto loop143;
				}
			}

			loop143:
				;

			} finally { DebugExitSubRule(143); }

			DebugLocation(246, 80);
			char_literal294=(IToken)Match(input,40,Follow._40_in_arguments1536); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal294_tree = (object)adaptor.Create(char_literal294);
			adaptor.AddChild(root_0, char_literal294_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arguments", 51);
			LeaveRule("arguments", 51);
			LeaveRule_arguments();
			if (state.backtracking > 0) { Memoize(input, 51, arguments_StartIndex); }

		}
		DebugLocation(247, 1);
		} finally { DebugExitRule(GrammarFileName, "arguments"); }
		return retval;

	}
	// $ANTLR end "arguments"

	partial void EnterRule_indexSuffix();
	partial void LeaveRule_indexSuffix();
	// $ANTLR start "indexSuffix"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:249:1: indexSuffix : '[' ( LT !)* expression ( LT !)* ']' ;
	[GrammarRule("indexSuffix")]
	private AstParserRuleReturnScope<object, IToken> indexSuffix()
	{
		EnterRule_indexSuffix();
		EnterRule("indexSuffix", 52);
		TraceIn("indexSuffix", 52);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int indexSuffix_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal295 = default(IToken);
		IToken LT296 = default(IToken);
		IToken LT298 = default(IToken);
		IToken char_literal299 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression297 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal295_tree = default(object);
		object LT296_tree = default(object);
		object LT298_tree = default(object);
		object char_literal299_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "indexSuffix");
		DebugLocation(249, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 52)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:250:2: ( '[' ( LT !)* expression ( LT !)* ']' )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:250:4: '[' ( LT !)* expression ( LT !)* ']'
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(250, 4);
			char_literal295=(IToken)Match(input,69,Follow._69_in_indexSuffix1548); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal295_tree = (object)adaptor.Create(char_literal295);
			adaptor.AddChild(root_0, char_literal295_tree);
			}
			DebugLocation(250, 10);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:250:10: ( LT !)*
			try { DebugEnterSubRule(144);
			while (true)
			{
				int alt144=2;
				try { DebugEnterDecision(144, false);
				int LA144_1 = input.LA(1);

				if ((LA144_1==LT))
				{
					alt144 = 1;
				}


				} finally { DebugExitDecision(144); }
				switch ( alt144 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:250:10: LT !
					{
					DebugLocation(250, 10);
					LT296=(IToken)Match(input,LT,Follow._LT_in_indexSuffix1550); if (state.failed) return retval;

					}
					break;

				default:
					goto loop144;
				}
			}

			loop144:
				;

			} finally { DebugExitSubRule(144); }

			DebugLocation(250, 13);
			PushFollow(Follow._expression_in_indexSuffix1554);
			expression297=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression297.Tree);
			DebugLocation(250, 26);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:250:26: ( LT !)*
			try { DebugEnterSubRule(145);
			while (true)
			{
				int alt145=2;
				try { DebugEnterDecision(145, false);
				int LA145_1 = input.LA(1);

				if ((LA145_1==LT))
				{
					alt145 = 1;
				}


				} finally { DebugExitDecision(145); }
				switch ( alt145 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:250:26: LT !
					{
					DebugLocation(250, 26);
					LT298=(IToken)Match(input,LT,Follow._LT_in_indexSuffix1556); if (state.failed) return retval;

					}
					break;

				default:
					goto loop145;
				}
			}

			loop145:
				;

			} finally { DebugExitSubRule(145); }

			DebugLocation(250, 29);
			char_literal299=(IToken)Match(input,70,Follow._70_in_indexSuffix1560); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal299_tree = (object)adaptor.Create(char_literal299);
			adaptor.AddChild(root_0, char_literal299_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("indexSuffix", 52);
			LeaveRule("indexSuffix", 52);
			LeaveRule_indexSuffix();
			if (state.backtracking > 0) { Memoize(input, 52, indexSuffix_StartIndex); }

		}
		DebugLocation(251, 1);
		} finally { DebugExitRule(GrammarFileName, "indexSuffix"); }
		return retval;

	}
	// $ANTLR end "indexSuffix"

	partial void EnterRule_propertyReferenceSuffix();
	partial void LeaveRule_propertyReferenceSuffix();
	// $ANTLR start "propertyReferenceSuffix"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:253:1: propertyReferenceSuffix : '.' ( LT !)* Identifier ;
	[GrammarRule("propertyReferenceSuffix")]
	private AstParserRuleReturnScope<object, IToken> propertyReferenceSuffix()
	{
		EnterRule_propertyReferenceSuffix();
		EnterRule("propertyReferenceSuffix", 53);
		TraceIn("propertyReferenceSuffix", 53);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int propertyReferenceSuffix_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal300 = default(IToken);
		IToken LT301 = default(IToken);
		IToken Identifier302 = default(IToken);

		object char_literal300_tree = default(object);
		object LT301_tree = default(object);
		object Identifier302_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "propertyReferenceSuffix");
		DebugLocation(253, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 53)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:254:2: ( '.' ( LT !)* Identifier )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:254:4: '.' ( LT !)* Identifier
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(254, 4);
			char_literal300=(IToken)Match(input,50,Follow._50_in_propertyReferenceSuffix1573); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal300_tree = (object)adaptor.Create(char_literal300);
			adaptor.AddChild(root_0, char_literal300_tree);
			}
			DebugLocation(254, 10);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:254:10: ( LT !)*
			try { DebugEnterSubRule(146);
			while (true)
			{
				int alt146=2;
				try { DebugEnterDecision(146, false);
				int LA146_1 = input.LA(1);

				if ((LA146_1==LT))
				{
					alt146 = 1;
				}


				} finally { DebugExitDecision(146); }
				switch ( alt146 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:254:10: LT !
					{
					DebugLocation(254, 10);
					LT301=(IToken)Match(input,LT,Follow._LT_in_propertyReferenceSuffix1575); if (state.failed) return retval;

					}
					break;

				default:
					goto loop146;
				}
			}

			loop146:
				;

			} finally { DebugExitSubRule(146); }

			DebugLocation(254, 13);
			Identifier302=(IToken)Match(input,Identifier,Follow._Identifier_in_propertyReferenceSuffix1579); if (state.failed) return retval;
			if (state.backtracking == 0) {
			Identifier302_tree = (object)adaptor.Create(Identifier302);
			adaptor.AddChild(root_0, Identifier302_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertyReferenceSuffix", 53);
			LeaveRule("propertyReferenceSuffix", 53);
			LeaveRule_propertyReferenceSuffix();
			if (state.backtracking > 0) { Memoize(input, 53, propertyReferenceSuffix_StartIndex); }

		}
		DebugLocation(255, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyReferenceSuffix"); }
		return retval;

	}
	// $ANTLR end "propertyReferenceSuffix"

	partial void EnterRule_assignmentOperator();
	partial void LeaveRule_assignmentOperator();
	// $ANTLR start "assignmentOperator"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:257:1: assignmentOperator : ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '>>>=' | '&=' | '^=' | '|=' );
	[GrammarRule("assignmentOperator")]
	private AstParserRuleReturnScope<object, IToken> assignmentOperator()
	{
		EnterRule_assignmentOperator();
		EnterRule("assignmentOperator", 54);
		TraceIn("assignmentOperator", 54);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int assignmentOperator_StartIndex = input.Index;

		object root_0 = default(object);

		IToken set303 = default(IToken);

		object set303_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "assignmentOperator");
		DebugLocation(257, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 54)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:258:2: ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '>>>=' | '&=' | '^=' | '|=' )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(258, 2);

			set303=(IToken)input.LT(1);
			if (input.LA(1)==35||input.LA(1)==38||input.LA(1)==42||input.LA(1)==45||input.LA(1)==49||input.LA(1)==52||input.LA(1)==57||input.LA(1)==59||input.LA(1)==65||input.LA(1)==67||input.LA(1)==72||input.LA(1)==103)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set303));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignmentOperator", 54);
			LeaveRule("assignmentOperator", 54);
			LeaveRule_assignmentOperator();
			if (state.backtracking > 0) { Memoize(input, 54, assignmentOperator_StartIndex); }

		}
		DebugLocation(259, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentOperator"); }
		return retval;

	}
	// $ANTLR end "assignmentOperator"

	partial void EnterRule_conditionalExpression();
	partial void LeaveRule_conditionalExpression();
	// $ANTLR start "conditionalExpression"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:261:1: conditionalExpression : logicalORExpression ( ( LT !)* '?' ( LT !)* assignmentExpression ( LT !)* ':' ( LT !)* assignmentExpression )? ;
	[GrammarRule("conditionalExpression")]
	private AstParserRuleReturnScope<object, IToken> conditionalExpression()
	{
		EnterRule_conditionalExpression();
		EnterRule("conditionalExpression", 55);
		TraceIn("conditionalExpression", 55);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int conditionalExpression_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT305 = default(IToken);
		IToken char_literal306 = default(IToken);
		IToken LT307 = default(IToken);
		IToken LT309 = default(IToken);
		IToken char_literal310 = default(IToken);
		IToken LT311 = default(IToken);
		AstParserRuleReturnScope<object, IToken> logicalORExpression304 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpression308 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpression312 = default(AstParserRuleReturnScope<object, IToken>);

		object LT305_tree = default(object);
		object char_literal306_tree = default(object);
		object LT307_tree = default(object);
		object LT309_tree = default(object);
		object char_literal310_tree = default(object);
		object LT311_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "conditionalExpression");
		DebugLocation(261, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 55)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:262:2: ( logicalORExpression ( ( LT !)* '?' ( LT !)* assignmentExpression ( LT !)* ':' ( LT !)* assignmentExpression )? )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:262:4: logicalORExpression ( ( LT !)* '?' ( LT !)* assignmentExpression ( LT !)* ':' ( LT !)* assignmentExpression )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(262, 4);
			PushFollow(Follow._logicalORExpression_in_conditionalExpression1646);
			logicalORExpression304=logicalORExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, logicalORExpression304.Tree);
			DebugLocation(262, 24);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:262:24: ( ( LT !)* '?' ( LT !)* assignmentExpression ( LT !)* ':' ( LT !)* assignmentExpression )?
			int alt151=2;
			try { DebugEnterSubRule(151);
			try { DebugEnterDecision(151, false);
			try
			{
				alt151 = dfa151.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(151); }
			switch (alt151)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:262:25: ( LT !)* '?' ( LT !)* assignmentExpression ( LT !)* ':' ( LT !)* assignmentExpression
				{
				DebugLocation(262, 27);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:262:27: ( LT !)*
				try { DebugEnterSubRule(147);
				while (true)
				{
					int alt147=2;
					try { DebugEnterDecision(147, false);
					int LA147_1 = input.LA(1);

					if ((LA147_1==LT))
					{
						alt147 = 1;
					}


					} finally { DebugExitDecision(147); }
					switch ( alt147 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:262:27: LT !
						{
						DebugLocation(262, 27);
						LT305=(IToken)Match(input,LT,Follow._LT_in_conditionalExpression1649); if (state.failed) return retval;

						}
						break;

					default:
						goto loop147;
					}
				}

				loop147:
					;

				} finally { DebugExitSubRule(147); }

				DebugLocation(262, 30);
				char_literal306=(IToken)Match(input,68,Follow._68_in_conditionalExpression1653); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal306_tree = (object)adaptor.Create(char_literal306);
				adaptor.AddChild(root_0, char_literal306_tree);
				}
				DebugLocation(262, 36);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:262:36: ( LT !)*
				try { DebugEnterSubRule(148);
				while (true)
				{
					int alt148=2;
					try { DebugEnterDecision(148, false);
					int LA148_1 = input.LA(1);

					if ((LA148_1==LT))
					{
						alt148 = 1;
					}


					} finally { DebugExitDecision(148); }
					switch ( alt148 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:262:36: LT !
						{
						DebugLocation(262, 36);
						LT307=(IToken)Match(input,LT,Follow._LT_in_conditionalExpression1655); if (state.failed) return retval;

						}
						break;

					default:
						goto loop148;
					}
				}

				loop148:
					;

				} finally { DebugExitSubRule(148); }

				DebugLocation(262, 39);
				PushFollow(Follow._assignmentExpression_in_conditionalExpression1659);
				assignmentExpression308=assignmentExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression308.Tree);
				DebugLocation(262, 62);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:262:62: ( LT !)*
				try { DebugEnterSubRule(149);
				while (true)
				{
					int alt149=2;
					try { DebugEnterDecision(149, false);
					int LA149_1 = input.LA(1);

					if ((LA149_1==LT))
					{
						alt149 = 1;
					}


					} finally { DebugExitDecision(149); }
					switch ( alt149 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:262:62: LT !
						{
						DebugLocation(262, 62);
						LT309=(IToken)Match(input,LT,Follow._LT_in_conditionalExpression1661); if (state.failed) return retval;

						}
						break;

					default:
						goto loop149;
					}
				}

				loop149:
					;

				} finally { DebugExitSubRule(149); }

				DebugLocation(262, 65);
				char_literal310=(IToken)Match(input,53,Follow._53_in_conditionalExpression1665); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal310_tree = (object)adaptor.Create(char_literal310);
				adaptor.AddChild(root_0, char_literal310_tree);
				}
				DebugLocation(262, 71);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:262:71: ( LT !)*
				try { DebugEnterSubRule(150);
				while (true)
				{
					int alt150=2;
					try { DebugEnterDecision(150, false);
					int LA150_1 = input.LA(1);

					if ((LA150_1==LT))
					{
						alt150 = 1;
					}


					} finally { DebugExitDecision(150); }
					switch ( alt150 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:262:71: LT !
						{
						DebugLocation(262, 71);
						LT311=(IToken)Match(input,LT,Follow._LT_in_conditionalExpression1667); if (state.failed) return retval;

						}
						break;

					default:
						goto loop150;
					}
				}

				loop150:
					;

				} finally { DebugExitSubRule(150); }

				DebugLocation(262, 74);
				PushFollow(Follow._assignmentExpression_in_conditionalExpression1671);
				assignmentExpression312=assignmentExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression312.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(151); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("conditionalExpression", 55);
			LeaveRule("conditionalExpression", 55);
			LeaveRule_conditionalExpression();
			if (state.backtracking > 0) { Memoize(input, 55, conditionalExpression_StartIndex); }

		}
		DebugLocation(263, 1);
		} finally { DebugExitRule(GrammarFileName, "conditionalExpression"); }
		return retval;

	}
	// $ANTLR end "conditionalExpression"

	partial void EnterRule_conditionalExpressionNoIn();
	partial void LeaveRule_conditionalExpressionNoIn();
	// $ANTLR start "conditionalExpressionNoIn"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:265:1: conditionalExpressionNoIn : logicalORExpressionNoIn ( ( LT !)* '?' ( LT !)* assignmentExpressionNoIn ( LT !)* ':' ( LT !)* assignmentExpressionNoIn )? ;
	[GrammarRule("conditionalExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> conditionalExpressionNoIn()
	{
		EnterRule_conditionalExpressionNoIn();
		EnterRule("conditionalExpressionNoIn", 56);
		TraceIn("conditionalExpressionNoIn", 56);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int conditionalExpressionNoIn_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT314 = default(IToken);
		IToken char_literal315 = default(IToken);
		IToken LT316 = default(IToken);
		IToken LT318 = default(IToken);
		IToken char_literal319 = default(IToken);
		IToken LT320 = default(IToken);
		AstParserRuleReturnScope<object, IToken> logicalORExpressionNoIn313 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpressionNoIn317 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpressionNoIn321 = default(AstParserRuleReturnScope<object, IToken>);

		object LT314_tree = default(object);
		object char_literal315_tree = default(object);
		object LT316_tree = default(object);
		object LT318_tree = default(object);
		object char_literal319_tree = default(object);
		object LT320_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "conditionalExpressionNoIn");
		DebugLocation(265, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 56)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:266:2: ( logicalORExpressionNoIn ( ( LT !)* '?' ( LT !)* assignmentExpressionNoIn ( LT !)* ':' ( LT !)* assignmentExpressionNoIn )? )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:266:4: logicalORExpressionNoIn ( ( LT !)* '?' ( LT !)* assignmentExpressionNoIn ( LT !)* ':' ( LT !)* assignmentExpressionNoIn )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(266, 4);
			PushFollow(Follow._logicalORExpressionNoIn_in_conditionalExpressionNoIn1684);
			logicalORExpressionNoIn313=logicalORExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, logicalORExpressionNoIn313.Tree);
			DebugLocation(266, 28);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:266:28: ( ( LT !)* '?' ( LT !)* assignmentExpressionNoIn ( LT !)* ':' ( LT !)* assignmentExpressionNoIn )?
			int alt156=2;
			try { DebugEnterSubRule(156);
			try { DebugEnterDecision(156, false);
			try
			{
				alt156 = dfa156.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(156); }
			switch (alt156)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:266:29: ( LT !)* '?' ( LT !)* assignmentExpressionNoIn ( LT !)* ':' ( LT !)* assignmentExpressionNoIn
				{
				DebugLocation(266, 31);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:266:31: ( LT !)*
				try { DebugEnterSubRule(152);
				while (true)
				{
					int alt152=2;
					try { DebugEnterDecision(152, false);
					int LA152_1 = input.LA(1);

					if ((LA152_1==LT))
					{
						alt152 = 1;
					}


					} finally { DebugExitDecision(152); }
					switch ( alt152 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:266:31: LT !
						{
						DebugLocation(266, 31);
						LT314=(IToken)Match(input,LT,Follow._LT_in_conditionalExpressionNoIn1687); if (state.failed) return retval;

						}
						break;

					default:
						goto loop152;
					}
				}

				loop152:
					;

				} finally { DebugExitSubRule(152); }

				DebugLocation(266, 34);
				char_literal315=(IToken)Match(input,68,Follow._68_in_conditionalExpressionNoIn1691); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal315_tree = (object)adaptor.Create(char_literal315);
				adaptor.AddChild(root_0, char_literal315_tree);
				}
				DebugLocation(266, 40);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:266:40: ( LT !)*
				try { DebugEnterSubRule(153);
				while (true)
				{
					int alt153=2;
					try { DebugEnterDecision(153, false);
					int LA153_1 = input.LA(1);

					if ((LA153_1==LT))
					{
						alt153 = 1;
					}


					} finally { DebugExitDecision(153); }
					switch ( alt153 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:266:40: LT !
						{
						DebugLocation(266, 40);
						LT316=(IToken)Match(input,LT,Follow._LT_in_conditionalExpressionNoIn1693); if (state.failed) return retval;

						}
						break;

					default:
						goto loop153;
					}
				}

				loop153:
					;

				} finally { DebugExitSubRule(153); }

				DebugLocation(266, 43);
				PushFollow(Follow._assignmentExpressionNoIn_in_conditionalExpressionNoIn1697);
				assignmentExpressionNoIn317=assignmentExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpressionNoIn317.Tree);
				DebugLocation(266, 70);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:266:70: ( LT !)*
				try { DebugEnterSubRule(154);
				while (true)
				{
					int alt154=2;
					try { DebugEnterDecision(154, false);
					int LA154_1 = input.LA(1);

					if ((LA154_1==LT))
					{
						alt154 = 1;
					}


					} finally { DebugExitDecision(154); }
					switch ( alt154 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:266:70: LT !
						{
						DebugLocation(266, 70);
						LT318=(IToken)Match(input,LT,Follow._LT_in_conditionalExpressionNoIn1699); if (state.failed) return retval;

						}
						break;

					default:
						goto loop154;
					}
				}

				loop154:
					;

				} finally { DebugExitSubRule(154); }

				DebugLocation(266, 73);
				char_literal319=(IToken)Match(input,53,Follow._53_in_conditionalExpressionNoIn1703); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal319_tree = (object)adaptor.Create(char_literal319);
				adaptor.AddChild(root_0, char_literal319_tree);
				}
				DebugLocation(266, 79);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:266:79: ( LT !)*
				try { DebugEnterSubRule(155);
				while (true)
				{
					int alt155=2;
					try { DebugEnterDecision(155, false);
					int LA155_1 = input.LA(1);

					if ((LA155_1==LT))
					{
						alt155 = 1;
					}


					} finally { DebugExitDecision(155); }
					switch ( alt155 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:266:79: LT !
						{
						DebugLocation(266, 79);
						LT320=(IToken)Match(input,LT,Follow._LT_in_conditionalExpressionNoIn1705); if (state.failed) return retval;

						}
						break;

					default:
						goto loop155;
					}
				}

				loop155:
					;

				} finally { DebugExitSubRule(155); }

				DebugLocation(266, 82);
				PushFollow(Follow._assignmentExpressionNoIn_in_conditionalExpressionNoIn1709);
				assignmentExpressionNoIn321=assignmentExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpressionNoIn321.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(156); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("conditionalExpressionNoIn", 56);
			LeaveRule("conditionalExpressionNoIn", 56);
			LeaveRule_conditionalExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 56, conditionalExpressionNoIn_StartIndex); }

		}
		DebugLocation(267, 1);
		} finally { DebugExitRule(GrammarFileName, "conditionalExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "conditionalExpressionNoIn"

	partial void EnterRule_logicalORExpression();
	partial void LeaveRule_logicalORExpression();
	// $ANTLR start "logicalORExpression"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:269:1: logicalORExpression : logicalANDExpression ( ( LT !)* '||' ( LT !)* logicalANDExpression )* ;
	[GrammarRule("logicalORExpression")]
	private AstParserRuleReturnScope<object, IToken> logicalORExpression()
	{
		EnterRule_logicalORExpression();
		EnterRule("logicalORExpression", 57);
		TraceIn("logicalORExpression", 57);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int logicalORExpression_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT323 = default(IToken);
		IToken string_literal324 = default(IToken);
		IToken LT325 = default(IToken);
		AstParserRuleReturnScope<object, IToken> logicalANDExpression322 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> logicalANDExpression326 = default(AstParserRuleReturnScope<object, IToken>);

		object LT323_tree = default(object);
		object string_literal324_tree = default(object);
		object LT325_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "logicalORExpression");
		DebugLocation(269, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 57)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:270:2: ( logicalANDExpression ( ( LT !)* '||' ( LT !)* logicalANDExpression )* )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:270:4: logicalANDExpression ( ( LT !)* '||' ( LT !)* logicalANDExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(270, 4);
			PushFollow(Follow._logicalANDExpression_in_logicalORExpression1722);
			logicalANDExpression322=logicalANDExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, logicalANDExpression322.Tree);
			DebugLocation(270, 25);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:270:25: ( ( LT !)* '||' ( LT !)* logicalANDExpression )*
			try { DebugEnterSubRule(159);
			while (true)
			{
				int alt159=2;
				try { DebugEnterDecision(159, false);
				try
				{
					alt159 = dfa159.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(159); }
				switch ( alt159 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:270:26: ( LT !)* '||' ( LT !)* logicalANDExpression
					{
					DebugLocation(270, 28);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:270:28: ( LT !)*
					try { DebugEnterSubRule(157);
					while (true)
					{
						int alt157=2;
						try { DebugEnterDecision(157, false);
						int LA157_1 = input.LA(1);

						if ((LA157_1==LT))
						{
							alt157 = 1;
						}


						} finally { DebugExitDecision(157); }
						switch ( alt157 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:270:28: LT !
							{
							DebugLocation(270, 28);
							LT323=(IToken)Match(input,LT,Follow._LT_in_logicalORExpression1725); if (state.failed) return retval;

							}
							break;

						default:
							goto loop157;
						}
					}

					loop157:
						;

					} finally { DebugExitSubRule(157); }

					DebugLocation(270, 31);
					string_literal324=(IToken)Match(input,104,Follow._104_in_logicalORExpression1729); if (state.failed) return retval;
					if (state.backtracking == 0) {
					string_literal324_tree = (object)adaptor.Create(string_literal324);
					adaptor.AddChild(root_0, string_literal324_tree);
					}
					DebugLocation(270, 38);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:270:38: ( LT !)*
					try { DebugEnterSubRule(158);
					while (true)
					{
						int alt158=2;
						try { DebugEnterDecision(158, false);
						int LA158_1 = input.LA(1);

						if ((LA158_1==LT))
						{
							alt158 = 1;
						}


						} finally { DebugExitDecision(158); }
						switch ( alt158 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:270:38: LT !
							{
							DebugLocation(270, 38);
							LT325=(IToken)Match(input,LT,Follow._LT_in_logicalORExpression1731); if (state.failed) return retval;

							}
							break;

						default:
							goto loop158;
						}
					}

					loop158:
						;

					} finally { DebugExitSubRule(158); }

					DebugLocation(270, 41);
					PushFollow(Follow._logicalANDExpression_in_logicalORExpression1735);
					logicalANDExpression326=logicalANDExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, logicalANDExpression326.Tree);

					}
					break;

				default:
					goto loop159;
				}
			}

			loop159:
				;

			} finally { DebugExitSubRule(159); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalORExpression", 57);
			LeaveRule("logicalORExpression", 57);
			LeaveRule_logicalORExpression();
			if (state.backtracking > 0) { Memoize(input, 57, logicalORExpression_StartIndex); }

		}
		DebugLocation(271, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalORExpression"); }
		return retval;

	}
	// $ANTLR end "logicalORExpression"

	partial void EnterRule_logicalORExpressionNoIn();
	partial void LeaveRule_logicalORExpressionNoIn();
	// $ANTLR start "logicalORExpressionNoIn"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:273:1: logicalORExpressionNoIn : logicalANDExpressionNoIn ( ( LT !)* '||' ( LT !)* logicalANDExpressionNoIn )* ;
	[GrammarRule("logicalORExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> logicalORExpressionNoIn()
	{
		EnterRule_logicalORExpressionNoIn();
		EnterRule("logicalORExpressionNoIn", 58);
		TraceIn("logicalORExpressionNoIn", 58);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int logicalORExpressionNoIn_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT328 = default(IToken);
		IToken string_literal329 = default(IToken);
		IToken LT330 = default(IToken);
		AstParserRuleReturnScope<object, IToken> logicalANDExpressionNoIn327 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> logicalANDExpressionNoIn331 = default(AstParserRuleReturnScope<object, IToken>);

		object LT328_tree = default(object);
		object string_literal329_tree = default(object);
		object LT330_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "logicalORExpressionNoIn");
		DebugLocation(273, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 58)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:274:2: ( logicalANDExpressionNoIn ( ( LT !)* '||' ( LT !)* logicalANDExpressionNoIn )* )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:274:4: logicalANDExpressionNoIn ( ( LT !)* '||' ( LT !)* logicalANDExpressionNoIn )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(274, 4);
			PushFollow(Follow._logicalANDExpressionNoIn_in_logicalORExpressionNoIn1749);
			logicalANDExpressionNoIn327=logicalANDExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, logicalANDExpressionNoIn327.Tree);
			DebugLocation(274, 29);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:274:29: ( ( LT !)* '||' ( LT !)* logicalANDExpressionNoIn )*
			try { DebugEnterSubRule(162);
			while (true)
			{
				int alt162=2;
				try { DebugEnterDecision(162, false);
				try
				{
					alt162 = dfa162.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(162); }
				switch ( alt162 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:274:30: ( LT !)* '||' ( LT !)* logicalANDExpressionNoIn
					{
					DebugLocation(274, 32);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:274:32: ( LT !)*
					try { DebugEnterSubRule(160);
					while (true)
					{
						int alt160=2;
						try { DebugEnterDecision(160, false);
						int LA160_1 = input.LA(1);

						if ((LA160_1==LT))
						{
							alt160 = 1;
						}


						} finally { DebugExitDecision(160); }
						switch ( alt160 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:274:32: LT !
							{
							DebugLocation(274, 32);
							LT328=(IToken)Match(input,LT,Follow._LT_in_logicalORExpressionNoIn1752); if (state.failed) return retval;

							}
							break;

						default:
							goto loop160;
						}
					}

					loop160:
						;

					} finally { DebugExitSubRule(160); }

					DebugLocation(274, 35);
					string_literal329=(IToken)Match(input,104,Follow._104_in_logicalORExpressionNoIn1756); if (state.failed) return retval;
					if (state.backtracking == 0) {
					string_literal329_tree = (object)adaptor.Create(string_literal329);
					adaptor.AddChild(root_0, string_literal329_tree);
					}
					DebugLocation(274, 42);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:274:42: ( LT !)*
					try { DebugEnterSubRule(161);
					while (true)
					{
						int alt161=2;
						try { DebugEnterDecision(161, false);
						int LA161_1 = input.LA(1);

						if ((LA161_1==LT))
						{
							alt161 = 1;
						}


						} finally { DebugExitDecision(161); }
						switch ( alt161 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:274:42: LT !
							{
							DebugLocation(274, 42);
							LT330=(IToken)Match(input,LT,Follow._LT_in_logicalORExpressionNoIn1758); if (state.failed) return retval;

							}
							break;

						default:
							goto loop161;
						}
					}

					loop161:
						;

					} finally { DebugExitSubRule(161); }

					DebugLocation(274, 45);
					PushFollow(Follow._logicalANDExpressionNoIn_in_logicalORExpressionNoIn1762);
					logicalANDExpressionNoIn331=logicalANDExpressionNoIn();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, logicalANDExpressionNoIn331.Tree);

					}
					break;

				default:
					goto loop162;
				}
			}

			loop162:
				;

			} finally { DebugExitSubRule(162); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalORExpressionNoIn", 58);
			LeaveRule("logicalORExpressionNoIn", 58);
			LeaveRule_logicalORExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 58, logicalORExpressionNoIn_StartIndex); }

		}
		DebugLocation(275, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalORExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "logicalORExpressionNoIn"

	partial void EnterRule_logicalANDExpression();
	partial void LeaveRule_logicalANDExpression();
	// $ANTLR start "logicalANDExpression"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:277:1: logicalANDExpression : bitwiseORExpression ( ( LT !)* '&&' ( LT !)* bitwiseORExpression )* ;
	[GrammarRule("logicalANDExpression")]
	private AstParserRuleReturnScope<object, IToken> logicalANDExpression()
	{
		EnterRule_logicalANDExpression();
		EnterRule("logicalANDExpression", 59);
		TraceIn("logicalANDExpression", 59);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int logicalANDExpression_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT333 = default(IToken);
		IToken string_literal334 = default(IToken);
		IToken LT335 = default(IToken);
		AstParserRuleReturnScope<object, IToken> bitwiseORExpression332 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> bitwiseORExpression336 = default(AstParserRuleReturnScope<object, IToken>);

		object LT333_tree = default(object);
		object string_literal334_tree = default(object);
		object LT335_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "logicalANDExpression");
		DebugLocation(277, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 59)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:278:2: ( bitwiseORExpression ( ( LT !)* '&&' ( LT !)* bitwiseORExpression )* )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:278:4: bitwiseORExpression ( ( LT !)* '&&' ( LT !)* bitwiseORExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(278, 4);
			PushFollow(Follow._bitwiseORExpression_in_logicalANDExpression1776);
			bitwiseORExpression332=bitwiseORExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseORExpression332.Tree);
			DebugLocation(278, 24);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:278:24: ( ( LT !)* '&&' ( LT !)* bitwiseORExpression )*
			try { DebugEnterSubRule(165);
			while (true)
			{
				int alt165=2;
				try { DebugEnterDecision(165, false);
				try
				{
					alt165 = dfa165.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(165); }
				switch ( alt165 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:278:25: ( LT !)* '&&' ( LT !)* bitwiseORExpression
					{
					DebugLocation(278, 27);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:278:27: ( LT !)*
					try { DebugEnterSubRule(163);
					while (true)
					{
						int alt163=2;
						try { DebugEnterDecision(163, false);
						int LA163_1 = input.LA(1);

						if ((LA163_1==LT))
						{
							alt163 = 1;
						}


						} finally { DebugExitDecision(163); }
						switch ( alt163 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:278:27: LT !
							{
							DebugLocation(278, 27);
							LT333=(IToken)Match(input,LT,Follow._LT_in_logicalANDExpression1779); if (state.failed) return retval;

							}
							break;

						default:
							goto loop163;
						}
					}

					loop163:
						;

					} finally { DebugExitSubRule(163); }

					DebugLocation(278, 30);
					string_literal334=(IToken)Match(input,36,Follow._36_in_logicalANDExpression1783); if (state.failed) return retval;
					if (state.backtracking == 0) {
					string_literal334_tree = (object)adaptor.Create(string_literal334);
					adaptor.AddChild(root_0, string_literal334_tree);
					}
					DebugLocation(278, 37);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:278:37: ( LT !)*
					try { DebugEnterSubRule(164);
					while (true)
					{
						int alt164=2;
						try { DebugEnterDecision(164, false);
						int LA164_1 = input.LA(1);

						if ((LA164_1==LT))
						{
							alt164 = 1;
						}


						} finally { DebugExitDecision(164); }
						switch ( alt164 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:278:37: LT !
							{
							DebugLocation(278, 37);
							LT335=(IToken)Match(input,LT,Follow._LT_in_logicalANDExpression1785); if (state.failed) return retval;

							}
							break;

						default:
							goto loop164;
						}
					}

					loop164:
						;

					} finally { DebugExitSubRule(164); }

					DebugLocation(278, 40);
					PushFollow(Follow._bitwiseORExpression_in_logicalANDExpression1789);
					bitwiseORExpression336=bitwiseORExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseORExpression336.Tree);

					}
					break;

				default:
					goto loop165;
				}
			}

			loop165:
				;

			} finally { DebugExitSubRule(165); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalANDExpression", 59);
			LeaveRule("logicalANDExpression", 59);
			LeaveRule_logicalANDExpression();
			if (state.backtracking > 0) { Memoize(input, 59, logicalANDExpression_StartIndex); }

		}
		DebugLocation(279, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalANDExpression"); }
		return retval;

	}
	// $ANTLR end "logicalANDExpression"

	partial void EnterRule_logicalANDExpressionNoIn();
	partial void LeaveRule_logicalANDExpressionNoIn();
	// $ANTLR start "logicalANDExpressionNoIn"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:281:1: logicalANDExpressionNoIn : bitwiseORExpressionNoIn ( ( LT !)* '&&' ( LT !)* bitwiseORExpressionNoIn )* ;
	[GrammarRule("logicalANDExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> logicalANDExpressionNoIn()
	{
		EnterRule_logicalANDExpressionNoIn();
		EnterRule("logicalANDExpressionNoIn", 60);
		TraceIn("logicalANDExpressionNoIn", 60);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int logicalANDExpressionNoIn_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT338 = default(IToken);
		IToken string_literal339 = default(IToken);
		IToken LT340 = default(IToken);
		AstParserRuleReturnScope<object, IToken> bitwiseORExpressionNoIn337 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> bitwiseORExpressionNoIn341 = default(AstParserRuleReturnScope<object, IToken>);

		object LT338_tree = default(object);
		object string_literal339_tree = default(object);
		object LT340_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "logicalANDExpressionNoIn");
		DebugLocation(281, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 60)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:282:2: ( bitwiseORExpressionNoIn ( ( LT !)* '&&' ( LT !)* bitwiseORExpressionNoIn )* )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:282:4: bitwiseORExpressionNoIn ( ( LT !)* '&&' ( LT !)* bitwiseORExpressionNoIn )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(282, 4);
			PushFollow(Follow._bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn1803);
			bitwiseORExpressionNoIn337=bitwiseORExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseORExpressionNoIn337.Tree);
			DebugLocation(282, 28);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:282:28: ( ( LT !)* '&&' ( LT !)* bitwiseORExpressionNoIn )*
			try { DebugEnterSubRule(168);
			while (true)
			{
				int alt168=2;
				try { DebugEnterDecision(168, false);
				try
				{
					alt168 = dfa168.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(168); }
				switch ( alt168 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:282:29: ( LT !)* '&&' ( LT !)* bitwiseORExpressionNoIn
					{
					DebugLocation(282, 31);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:282:31: ( LT !)*
					try { DebugEnterSubRule(166);
					while (true)
					{
						int alt166=2;
						try { DebugEnterDecision(166, false);
						int LA166_1 = input.LA(1);

						if ((LA166_1==LT))
						{
							alt166 = 1;
						}


						} finally { DebugExitDecision(166); }
						switch ( alt166 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:282:31: LT !
							{
							DebugLocation(282, 31);
							LT338=(IToken)Match(input,LT,Follow._LT_in_logicalANDExpressionNoIn1806); if (state.failed) return retval;

							}
							break;

						default:
							goto loop166;
						}
					}

					loop166:
						;

					} finally { DebugExitSubRule(166); }

					DebugLocation(282, 34);
					string_literal339=(IToken)Match(input,36,Follow._36_in_logicalANDExpressionNoIn1810); if (state.failed) return retval;
					if (state.backtracking == 0) {
					string_literal339_tree = (object)adaptor.Create(string_literal339);
					adaptor.AddChild(root_0, string_literal339_tree);
					}
					DebugLocation(282, 41);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:282:41: ( LT !)*
					try { DebugEnterSubRule(167);
					while (true)
					{
						int alt167=2;
						try { DebugEnterDecision(167, false);
						int LA167_1 = input.LA(1);

						if ((LA167_1==LT))
						{
							alt167 = 1;
						}


						} finally { DebugExitDecision(167); }
						switch ( alt167 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:282:41: LT !
							{
							DebugLocation(282, 41);
							LT340=(IToken)Match(input,LT,Follow._LT_in_logicalANDExpressionNoIn1812); if (state.failed) return retval;

							}
							break;

						default:
							goto loop167;
						}
					}

					loop167:
						;

					} finally { DebugExitSubRule(167); }

					DebugLocation(282, 44);
					PushFollow(Follow._bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn1816);
					bitwiseORExpressionNoIn341=bitwiseORExpressionNoIn();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseORExpressionNoIn341.Tree);

					}
					break;

				default:
					goto loop168;
				}
			}

			loop168:
				;

			} finally { DebugExitSubRule(168); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalANDExpressionNoIn", 60);
			LeaveRule("logicalANDExpressionNoIn", 60);
			LeaveRule_logicalANDExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 60, logicalANDExpressionNoIn_StartIndex); }

		}
		DebugLocation(283, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalANDExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "logicalANDExpressionNoIn"

	partial void EnterRule_bitwiseORExpression();
	partial void LeaveRule_bitwiseORExpression();
	// $ANTLR start "bitwiseORExpression"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:285:1: bitwiseORExpression : bitwiseXORExpression ( ( LT !)* '|' ( LT !)* bitwiseXORExpression )* ;
	[GrammarRule("bitwiseORExpression")]
	private AstParserRuleReturnScope<object, IToken> bitwiseORExpression()
	{
		EnterRule_bitwiseORExpression();
		EnterRule("bitwiseORExpression", 61);
		TraceIn("bitwiseORExpression", 61);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int bitwiseORExpression_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT343 = default(IToken);
		IToken char_literal344 = default(IToken);
		IToken LT345 = default(IToken);
		AstParserRuleReturnScope<object, IToken> bitwiseXORExpression342 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> bitwiseXORExpression346 = default(AstParserRuleReturnScope<object, IToken>);

		object LT343_tree = default(object);
		object char_literal344_tree = default(object);
		object LT345_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "bitwiseORExpression");
		DebugLocation(285, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 61)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:286:2: ( bitwiseXORExpression ( ( LT !)* '|' ( LT !)* bitwiseXORExpression )* )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:286:4: bitwiseXORExpression ( ( LT !)* '|' ( LT !)* bitwiseXORExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(286, 4);
			PushFollow(Follow._bitwiseXORExpression_in_bitwiseORExpression1830);
			bitwiseXORExpression342=bitwiseXORExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseXORExpression342.Tree);
			DebugLocation(286, 25);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:286:25: ( ( LT !)* '|' ( LT !)* bitwiseXORExpression )*
			try { DebugEnterSubRule(171);
			while (true)
			{
				int alt171=2;
				try { DebugEnterDecision(171, false);
				try
				{
					alt171 = dfa171.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(171); }
				switch ( alt171 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:286:26: ( LT !)* '|' ( LT !)* bitwiseXORExpression
					{
					DebugLocation(286, 28);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:286:28: ( LT !)*
					try { DebugEnterSubRule(169);
					while (true)
					{
						int alt169=2;
						try { DebugEnterDecision(169, false);
						int LA169_1 = input.LA(1);

						if ((LA169_1==LT))
						{
							alt169 = 1;
						}


						} finally { DebugExitDecision(169); }
						switch ( alt169 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:286:28: LT !
							{
							DebugLocation(286, 28);
							LT343=(IToken)Match(input,LT,Follow._LT_in_bitwiseORExpression1833); if (state.failed) return retval;

							}
							break;

						default:
							goto loop169;
						}
					}

					loop169:
						;

					} finally { DebugExitSubRule(169); }

					DebugLocation(286, 31);
					char_literal344=(IToken)Match(input,102,Follow._102_in_bitwiseORExpression1837); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal344_tree = (object)adaptor.Create(char_literal344);
					adaptor.AddChild(root_0, char_literal344_tree);
					}
					DebugLocation(286, 37);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:286:37: ( LT !)*
					try { DebugEnterSubRule(170);
					while (true)
					{
						int alt170=2;
						try { DebugEnterDecision(170, false);
						int LA170_1 = input.LA(1);

						if ((LA170_1==LT))
						{
							alt170 = 1;
						}


						} finally { DebugExitDecision(170); }
						switch ( alt170 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:286:37: LT !
							{
							DebugLocation(286, 37);
							LT345=(IToken)Match(input,LT,Follow._LT_in_bitwiseORExpression1839); if (state.failed) return retval;

							}
							break;

						default:
							goto loop170;
						}
					}

					loop170:
						;

					} finally { DebugExitSubRule(170); }

					DebugLocation(286, 40);
					PushFollow(Follow._bitwiseXORExpression_in_bitwiseORExpression1843);
					bitwiseXORExpression346=bitwiseXORExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseXORExpression346.Tree);

					}
					break;

				default:
					goto loop171;
				}
			}

			loop171:
				;

			} finally { DebugExitSubRule(171); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseORExpression", 61);
			LeaveRule("bitwiseORExpression", 61);
			LeaveRule_bitwiseORExpression();
			if (state.backtracking > 0) { Memoize(input, 61, bitwiseORExpression_StartIndex); }

		}
		DebugLocation(287, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseORExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseORExpression"

	partial void EnterRule_bitwiseORExpressionNoIn();
	partial void LeaveRule_bitwiseORExpressionNoIn();
	// $ANTLR start "bitwiseORExpressionNoIn"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:289:1: bitwiseORExpressionNoIn : bitwiseXORExpressionNoIn ( ( LT !)* '|' ( LT !)* bitwiseXORExpressionNoIn )* ;
	[GrammarRule("bitwiseORExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> bitwiseORExpressionNoIn()
	{
		EnterRule_bitwiseORExpressionNoIn();
		EnterRule("bitwiseORExpressionNoIn", 62);
		TraceIn("bitwiseORExpressionNoIn", 62);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int bitwiseORExpressionNoIn_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT348 = default(IToken);
		IToken char_literal349 = default(IToken);
		IToken LT350 = default(IToken);
		AstParserRuleReturnScope<object, IToken> bitwiseXORExpressionNoIn347 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> bitwiseXORExpressionNoIn351 = default(AstParserRuleReturnScope<object, IToken>);

		object LT348_tree = default(object);
		object char_literal349_tree = default(object);
		object LT350_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "bitwiseORExpressionNoIn");
		DebugLocation(289, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 62)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:290:2: ( bitwiseXORExpressionNoIn ( ( LT !)* '|' ( LT !)* bitwiseXORExpressionNoIn )* )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:290:4: bitwiseXORExpressionNoIn ( ( LT !)* '|' ( LT !)* bitwiseXORExpressionNoIn )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(290, 4);
			PushFollow(Follow._bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn1857);
			bitwiseXORExpressionNoIn347=bitwiseXORExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseXORExpressionNoIn347.Tree);
			DebugLocation(290, 29);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:290:29: ( ( LT !)* '|' ( LT !)* bitwiseXORExpressionNoIn )*
			try { DebugEnterSubRule(174);
			while (true)
			{
				int alt174=2;
				try { DebugEnterDecision(174, false);
				try
				{
					alt174 = dfa174.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(174); }
				switch ( alt174 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:290:30: ( LT !)* '|' ( LT !)* bitwiseXORExpressionNoIn
					{
					DebugLocation(290, 32);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:290:32: ( LT !)*
					try { DebugEnterSubRule(172);
					while (true)
					{
						int alt172=2;
						try { DebugEnterDecision(172, false);
						int LA172_1 = input.LA(1);

						if ((LA172_1==LT))
						{
							alt172 = 1;
						}


						} finally { DebugExitDecision(172); }
						switch ( alt172 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:290:32: LT !
							{
							DebugLocation(290, 32);
							LT348=(IToken)Match(input,LT,Follow._LT_in_bitwiseORExpressionNoIn1860); if (state.failed) return retval;

							}
							break;

						default:
							goto loop172;
						}
					}

					loop172:
						;

					} finally { DebugExitSubRule(172); }

					DebugLocation(290, 35);
					char_literal349=(IToken)Match(input,102,Follow._102_in_bitwiseORExpressionNoIn1864); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal349_tree = (object)adaptor.Create(char_literal349);
					adaptor.AddChild(root_0, char_literal349_tree);
					}
					DebugLocation(290, 41);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:290:41: ( LT !)*
					try { DebugEnterSubRule(173);
					while (true)
					{
						int alt173=2;
						try { DebugEnterDecision(173, false);
						int LA173_1 = input.LA(1);

						if ((LA173_1==LT))
						{
							alt173 = 1;
						}


						} finally { DebugExitDecision(173); }
						switch ( alt173 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:290:41: LT !
							{
							DebugLocation(290, 41);
							LT350=(IToken)Match(input,LT,Follow._LT_in_bitwiseORExpressionNoIn1866); if (state.failed) return retval;

							}
							break;

						default:
							goto loop173;
						}
					}

					loop173:
						;

					} finally { DebugExitSubRule(173); }

					DebugLocation(290, 44);
					PushFollow(Follow._bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn1870);
					bitwiseXORExpressionNoIn351=bitwiseXORExpressionNoIn();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseXORExpressionNoIn351.Tree);

					}
					break;

				default:
					goto loop174;
				}
			}

			loop174:
				;

			} finally { DebugExitSubRule(174); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseORExpressionNoIn", 62);
			LeaveRule("bitwiseORExpressionNoIn", 62);
			LeaveRule_bitwiseORExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 62, bitwiseORExpressionNoIn_StartIndex); }

		}
		DebugLocation(291, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseORExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "bitwiseORExpressionNoIn"

	partial void EnterRule_bitwiseXORExpression();
	partial void LeaveRule_bitwiseXORExpression();
	// $ANTLR start "bitwiseXORExpression"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:293:1: bitwiseXORExpression : bitwiseANDExpression ( ( LT !)* '^' ( LT !)* bitwiseANDExpression )* ;
	[GrammarRule("bitwiseXORExpression")]
	private AstParserRuleReturnScope<object, IToken> bitwiseXORExpression()
	{
		EnterRule_bitwiseXORExpression();
		EnterRule("bitwiseXORExpression", 63);
		TraceIn("bitwiseXORExpression", 63);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int bitwiseXORExpression_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT353 = default(IToken);
		IToken char_literal354 = default(IToken);
		IToken LT355 = default(IToken);
		AstParserRuleReturnScope<object, IToken> bitwiseANDExpression352 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> bitwiseANDExpression356 = default(AstParserRuleReturnScope<object, IToken>);

		object LT353_tree = default(object);
		object char_literal354_tree = default(object);
		object LT355_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "bitwiseXORExpression");
		DebugLocation(293, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 63)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:294:2: ( bitwiseANDExpression ( ( LT !)* '^' ( LT !)* bitwiseANDExpression )* )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:294:4: bitwiseANDExpression ( ( LT !)* '^' ( LT !)* bitwiseANDExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(294, 4);
			PushFollow(Follow._bitwiseANDExpression_in_bitwiseXORExpression1884);
			bitwiseANDExpression352=bitwiseANDExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseANDExpression352.Tree);
			DebugLocation(294, 25);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:294:25: ( ( LT !)* '^' ( LT !)* bitwiseANDExpression )*
			try { DebugEnterSubRule(177);
			while (true)
			{
				int alt177=2;
				try { DebugEnterDecision(177, false);
				try
				{
					alt177 = dfa177.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(177); }
				switch ( alt177 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:294:26: ( LT !)* '^' ( LT !)* bitwiseANDExpression
					{
					DebugLocation(294, 28);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:294:28: ( LT !)*
					try { DebugEnterSubRule(175);
					while (true)
					{
						int alt175=2;
						try { DebugEnterDecision(175, false);
						int LA175_1 = input.LA(1);

						if ((LA175_1==LT))
						{
							alt175 = 1;
						}


						} finally { DebugExitDecision(175); }
						switch ( alt175 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:294:28: LT !
							{
							DebugLocation(294, 28);
							LT353=(IToken)Match(input,LT,Follow._LT_in_bitwiseXORExpression1887); if (state.failed) return retval;

							}
							break;

						default:
							goto loop175;
						}
					}

					loop175:
						;

					} finally { DebugExitSubRule(175); }

					DebugLocation(294, 31);
					char_literal354=(IToken)Match(input,71,Follow._71_in_bitwiseXORExpression1891); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal354_tree = (object)adaptor.Create(char_literal354);
					adaptor.AddChild(root_0, char_literal354_tree);
					}
					DebugLocation(294, 37);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:294:37: ( LT !)*
					try { DebugEnterSubRule(176);
					while (true)
					{
						int alt176=2;
						try { DebugEnterDecision(176, false);
						int LA176_1 = input.LA(1);

						if ((LA176_1==LT))
						{
							alt176 = 1;
						}


						} finally { DebugExitDecision(176); }
						switch ( alt176 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:294:37: LT !
							{
							DebugLocation(294, 37);
							LT355=(IToken)Match(input,LT,Follow._LT_in_bitwiseXORExpression1893); if (state.failed) return retval;

							}
							break;

						default:
							goto loop176;
						}
					}

					loop176:
						;

					} finally { DebugExitSubRule(176); }

					DebugLocation(294, 40);
					PushFollow(Follow._bitwiseANDExpression_in_bitwiseXORExpression1897);
					bitwiseANDExpression356=bitwiseANDExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseANDExpression356.Tree);

					}
					break;

				default:
					goto loop177;
				}
			}

			loop177:
				;

			} finally { DebugExitSubRule(177); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseXORExpression", 63);
			LeaveRule("bitwiseXORExpression", 63);
			LeaveRule_bitwiseXORExpression();
			if (state.backtracking > 0) { Memoize(input, 63, bitwiseXORExpression_StartIndex); }

		}
		DebugLocation(295, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseXORExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseXORExpression"

	partial void EnterRule_bitwiseXORExpressionNoIn();
	partial void LeaveRule_bitwiseXORExpressionNoIn();
	// $ANTLR start "bitwiseXORExpressionNoIn"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:297:1: bitwiseXORExpressionNoIn : bitwiseANDExpressionNoIn ( ( LT !)* '^' ( LT !)* bitwiseANDExpressionNoIn )* ;
	[GrammarRule("bitwiseXORExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> bitwiseXORExpressionNoIn()
	{
		EnterRule_bitwiseXORExpressionNoIn();
		EnterRule("bitwiseXORExpressionNoIn", 64);
		TraceIn("bitwiseXORExpressionNoIn", 64);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int bitwiseXORExpressionNoIn_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT358 = default(IToken);
		IToken char_literal359 = default(IToken);
		IToken LT360 = default(IToken);
		AstParserRuleReturnScope<object, IToken> bitwiseANDExpressionNoIn357 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> bitwiseANDExpressionNoIn361 = default(AstParserRuleReturnScope<object, IToken>);

		object LT358_tree = default(object);
		object char_literal359_tree = default(object);
		object LT360_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "bitwiseXORExpressionNoIn");
		DebugLocation(297, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 64)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:298:2: ( bitwiseANDExpressionNoIn ( ( LT !)* '^' ( LT !)* bitwiseANDExpressionNoIn )* )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:298:4: bitwiseANDExpressionNoIn ( ( LT !)* '^' ( LT !)* bitwiseANDExpressionNoIn )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(298, 4);
			PushFollow(Follow._bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn1911);
			bitwiseANDExpressionNoIn357=bitwiseANDExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseANDExpressionNoIn357.Tree);
			DebugLocation(298, 29);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:298:29: ( ( LT !)* '^' ( LT !)* bitwiseANDExpressionNoIn )*
			try { DebugEnterSubRule(180);
			while (true)
			{
				int alt180=2;
				try { DebugEnterDecision(180, false);
				try
				{
					alt180 = dfa180.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(180); }
				switch ( alt180 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:298:30: ( LT !)* '^' ( LT !)* bitwiseANDExpressionNoIn
					{
					DebugLocation(298, 32);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:298:32: ( LT !)*
					try { DebugEnterSubRule(178);
					while (true)
					{
						int alt178=2;
						try { DebugEnterDecision(178, false);
						int LA178_1 = input.LA(1);

						if ((LA178_1==LT))
						{
							alt178 = 1;
						}


						} finally { DebugExitDecision(178); }
						switch ( alt178 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:298:32: LT !
							{
							DebugLocation(298, 32);
							LT358=(IToken)Match(input,LT,Follow._LT_in_bitwiseXORExpressionNoIn1914); if (state.failed) return retval;

							}
							break;

						default:
							goto loop178;
						}
					}

					loop178:
						;

					} finally { DebugExitSubRule(178); }

					DebugLocation(298, 35);
					char_literal359=(IToken)Match(input,71,Follow._71_in_bitwiseXORExpressionNoIn1918); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal359_tree = (object)adaptor.Create(char_literal359);
					adaptor.AddChild(root_0, char_literal359_tree);
					}
					DebugLocation(298, 41);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:298:41: ( LT !)*
					try { DebugEnterSubRule(179);
					while (true)
					{
						int alt179=2;
						try { DebugEnterDecision(179, false);
						int LA179_1 = input.LA(1);

						if ((LA179_1==LT))
						{
							alt179 = 1;
						}


						} finally { DebugExitDecision(179); }
						switch ( alt179 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:298:41: LT !
							{
							DebugLocation(298, 41);
							LT360=(IToken)Match(input,LT,Follow._LT_in_bitwiseXORExpressionNoIn1920); if (state.failed) return retval;

							}
							break;

						default:
							goto loop179;
						}
					}

					loop179:
						;

					} finally { DebugExitSubRule(179); }

					DebugLocation(298, 44);
					PushFollow(Follow._bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn1924);
					bitwiseANDExpressionNoIn361=bitwiseANDExpressionNoIn();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseANDExpressionNoIn361.Tree);

					}
					break;

				default:
					goto loop180;
				}
			}

			loop180:
				;

			} finally { DebugExitSubRule(180); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseXORExpressionNoIn", 64);
			LeaveRule("bitwiseXORExpressionNoIn", 64);
			LeaveRule_bitwiseXORExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 64, bitwiseXORExpressionNoIn_StartIndex); }

		}
		DebugLocation(299, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseXORExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "bitwiseXORExpressionNoIn"

	partial void EnterRule_bitwiseANDExpression();
	partial void LeaveRule_bitwiseANDExpression();
	// $ANTLR start "bitwiseANDExpression"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:301:1: bitwiseANDExpression : equalityExpression ( ( LT !)* '&' ( LT !)* equalityExpression )* ;
	[GrammarRule("bitwiseANDExpression")]
	private AstParserRuleReturnScope<object, IToken> bitwiseANDExpression()
	{
		EnterRule_bitwiseANDExpression();
		EnterRule("bitwiseANDExpression", 65);
		TraceIn("bitwiseANDExpression", 65);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int bitwiseANDExpression_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT363 = default(IToken);
		IToken char_literal364 = default(IToken);
		IToken LT365 = default(IToken);
		AstParserRuleReturnScope<object, IToken> equalityExpression362 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> equalityExpression366 = default(AstParserRuleReturnScope<object, IToken>);

		object LT363_tree = default(object);
		object char_literal364_tree = default(object);
		object LT365_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "bitwiseANDExpression");
		DebugLocation(301, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 65)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:302:2: ( equalityExpression ( ( LT !)* '&' ( LT !)* equalityExpression )* )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:302:4: equalityExpression ( ( LT !)* '&' ( LT !)* equalityExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(302, 4);
			PushFollow(Follow._equalityExpression_in_bitwiseANDExpression1938);
			equalityExpression362=equalityExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, equalityExpression362.Tree);
			DebugLocation(302, 23);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:302:23: ( ( LT !)* '&' ( LT !)* equalityExpression )*
			try { DebugEnterSubRule(183);
			while (true)
			{
				int alt183=2;
				try { DebugEnterDecision(183, false);
				try
				{
					alt183 = dfa183.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(183); }
				switch ( alt183 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:302:24: ( LT !)* '&' ( LT !)* equalityExpression
					{
					DebugLocation(302, 26);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:302:26: ( LT !)*
					try { DebugEnterSubRule(181);
					while (true)
					{
						int alt181=2;
						try { DebugEnterDecision(181, false);
						int LA181_1 = input.LA(1);

						if ((LA181_1==LT))
						{
							alt181 = 1;
						}


						} finally { DebugExitDecision(181); }
						switch ( alt181 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:302:26: LT !
							{
							DebugLocation(302, 26);
							LT363=(IToken)Match(input,LT,Follow._LT_in_bitwiseANDExpression1941); if (state.failed) return retval;

							}
							break;

						default:
							goto loop181;
						}
					}

					loop181:
						;

					} finally { DebugExitSubRule(181); }

					DebugLocation(302, 29);
					char_literal364=(IToken)Match(input,37,Follow._37_in_bitwiseANDExpression1945); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal364_tree = (object)adaptor.Create(char_literal364);
					adaptor.AddChild(root_0, char_literal364_tree);
					}
					DebugLocation(302, 35);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:302:35: ( LT !)*
					try { DebugEnterSubRule(182);
					while (true)
					{
						int alt182=2;
						try { DebugEnterDecision(182, false);
						int LA182_1 = input.LA(1);

						if ((LA182_1==LT))
						{
							alt182 = 1;
						}


						} finally { DebugExitDecision(182); }
						switch ( alt182 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:302:35: LT !
							{
							DebugLocation(302, 35);
							LT365=(IToken)Match(input,LT,Follow._LT_in_bitwiseANDExpression1947); if (state.failed) return retval;

							}
							break;

						default:
							goto loop182;
						}
					}

					loop182:
						;

					} finally { DebugExitSubRule(182); }

					DebugLocation(302, 38);
					PushFollow(Follow._equalityExpression_in_bitwiseANDExpression1951);
					equalityExpression366=equalityExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, equalityExpression366.Tree);

					}
					break;

				default:
					goto loop183;
				}
			}

			loop183:
				;

			} finally { DebugExitSubRule(183); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseANDExpression", 65);
			LeaveRule("bitwiseANDExpression", 65);
			LeaveRule_bitwiseANDExpression();
			if (state.backtracking > 0) { Memoize(input, 65, bitwiseANDExpression_StartIndex); }

		}
		DebugLocation(303, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseANDExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseANDExpression"

	partial void EnterRule_bitwiseANDExpressionNoIn();
	partial void LeaveRule_bitwiseANDExpressionNoIn();
	// $ANTLR start "bitwiseANDExpressionNoIn"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:305:1: bitwiseANDExpressionNoIn : equalityExpressionNoIn ( ( LT !)* '&' ( LT !)* equalityExpressionNoIn )* ;
	[GrammarRule("bitwiseANDExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> bitwiseANDExpressionNoIn()
	{
		EnterRule_bitwiseANDExpressionNoIn();
		EnterRule("bitwiseANDExpressionNoIn", 66);
		TraceIn("bitwiseANDExpressionNoIn", 66);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int bitwiseANDExpressionNoIn_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT368 = default(IToken);
		IToken char_literal369 = default(IToken);
		IToken LT370 = default(IToken);
		AstParserRuleReturnScope<object, IToken> equalityExpressionNoIn367 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> equalityExpressionNoIn371 = default(AstParserRuleReturnScope<object, IToken>);

		object LT368_tree = default(object);
		object char_literal369_tree = default(object);
		object LT370_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "bitwiseANDExpressionNoIn");
		DebugLocation(305, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 66)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:306:2: ( equalityExpressionNoIn ( ( LT !)* '&' ( LT !)* equalityExpressionNoIn )* )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:306:4: equalityExpressionNoIn ( ( LT !)* '&' ( LT !)* equalityExpressionNoIn )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(306, 4);
			PushFollow(Follow._equalityExpressionNoIn_in_bitwiseANDExpressionNoIn1965);
			equalityExpressionNoIn367=equalityExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, equalityExpressionNoIn367.Tree);
			DebugLocation(306, 27);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:306:27: ( ( LT !)* '&' ( LT !)* equalityExpressionNoIn )*
			try { DebugEnterSubRule(186);
			while (true)
			{
				int alt186=2;
				try { DebugEnterDecision(186, false);
				try
				{
					alt186 = dfa186.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(186); }
				switch ( alt186 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:306:28: ( LT !)* '&' ( LT !)* equalityExpressionNoIn
					{
					DebugLocation(306, 30);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:306:30: ( LT !)*
					try { DebugEnterSubRule(184);
					while (true)
					{
						int alt184=2;
						try { DebugEnterDecision(184, false);
						int LA184_1 = input.LA(1);

						if ((LA184_1==LT))
						{
							alt184 = 1;
						}


						} finally { DebugExitDecision(184); }
						switch ( alt184 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:306:30: LT !
							{
							DebugLocation(306, 30);
							LT368=(IToken)Match(input,LT,Follow._LT_in_bitwiseANDExpressionNoIn1968); if (state.failed) return retval;

							}
							break;

						default:
							goto loop184;
						}
					}

					loop184:
						;

					} finally { DebugExitSubRule(184); }

					DebugLocation(306, 33);
					char_literal369=(IToken)Match(input,37,Follow._37_in_bitwiseANDExpressionNoIn1972); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal369_tree = (object)adaptor.Create(char_literal369);
					adaptor.AddChild(root_0, char_literal369_tree);
					}
					DebugLocation(306, 39);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:306:39: ( LT !)*
					try { DebugEnterSubRule(185);
					while (true)
					{
						int alt185=2;
						try { DebugEnterDecision(185, false);
						int LA185_1 = input.LA(1);

						if ((LA185_1==LT))
						{
							alt185 = 1;
						}


						} finally { DebugExitDecision(185); }
						switch ( alt185 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:306:39: LT !
							{
							DebugLocation(306, 39);
							LT370=(IToken)Match(input,LT,Follow._LT_in_bitwiseANDExpressionNoIn1974); if (state.failed) return retval;

							}
							break;

						default:
							goto loop185;
						}
					}

					loop185:
						;

					} finally { DebugExitSubRule(185); }

					DebugLocation(306, 42);
					PushFollow(Follow._equalityExpressionNoIn_in_bitwiseANDExpressionNoIn1978);
					equalityExpressionNoIn371=equalityExpressionNoIn();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, equalityExpressionNoIn371.Tree);

					}
					break;

				default:
					goto loop186;
				}
			}

			loop186:
				;

			} finally { DebugExitSubRule(186); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseANDExpressionNoIn", 66);
			LeaveRule("bitwiseANDExpressionNoIn", 66);
			LeaveRule_bitwiseANDExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 66, bitwiseANDExpressionNoIn_StartIndex); }

		}
		DebugLocation(307, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseANDExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "bitwiseANDExpressionNoIn"

	partial void EnterRule_equalityExpression();
	partial void LeaveRule_equalityExpression();
	// $ANTLR start "equalityExpression"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:309:1: equalityExpression : relationalExpression ( ( LT !)* ( '==' | '!=' | '===' | '!==' ) ( LT !)* relationalExpression )* ;
	[GrammarRule("equalityExpression")]
	private AstParserRuleReturnScope<object, IToken> equalityExpression()
	{
		EnterRule_equalityExpression();
		EnterRule("equalityExpression", 67);
		TraceIn("equalityExpression", 67);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int equalityExpression_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT373 = default(IToken);
		IToken set374 = default(IToken);
		IToken LT375 = default(IToken);
		AstParserRuleReturnScope<object, IToken> relationalExpression372 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> relationalExpression376 = default(AstParserRuleReturnScope<object, IToken>);

		object LT373_tree = default(object);
		object set374_tree = default(object);
		object LT375_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "equalityExpression");
		DebugLocation(309, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 67)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:310:2: ( relationalExpression ( ( LT !)* ( '==' | '!=' | '===' | '!==' ) ( LT !)* relationalExpression )* )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:310:4: relationalExpression ( ( LT !)* ( '==' | '!=' | '===' | '!==' ) ( LT !)* relationalExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(310, 4);
			PushFollow(Follow._relationalExpression_in_equalityExpression1992);
			relationalExpression372=relationalExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, relationalExpression372.Tree);
			DebugLocation(310, 25);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:310:25: ( ( LT !)* ( '==' | '!=' | '===' | '!==' ) ( LT !)* relationalExpression )*
			try { DebugEnterSubRule(189);
			while (true)
			{
				int alt189=2;
				try { DebugEnterDecision(189, false);
				try
				{
					alt189 = dfa189.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(189); }
				switch ( alt189 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:310:26: ( LT !)* ( '==' | '!=' | '===' | '!==' ) ( LT !)* relationalExpression
					{
					DebugLocation(310, 28);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:310:28: ( LT !)*
					try { DebugEnterSubRule(187);
					while (true)
					{
						int alt187=2;
						try { DebugEnterDecision(187, false);
						int LA187_1 = input.LA(1);

						if ((LA187_1==LT))
						{
							alt187 = 1;
						}


						} finally { DebugExitDecision(187); }
						switch ( alt187 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:310:28: LT !
							{
							DebugLocation(310, 28);
							LT373=(IToken)Match(input,LT,Follow._LT_in_equalityExpression1995); if (state.failed) return retval;

							}
							break;

						default:
							goto loop187;
						}
					}

					loop187:
						;

					} finally { DebugExitSubRule(187); }

					DebugLocation(310, 31);

					set374=(IToken)input.LT(1);
					if ((input.LA(1)>=32 && input.LA(1)<=33)||(input.LA(1)>=60 && input.LA(1)<=61))
					{
						input.Consume();
						if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set374));
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(310, 63);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:310:63: ( LT !)*
					try { DebugEnterSubRule(188);
					while (true)
					{
						int alt188=2;
						try { DebugEnterDecision(188, false);
						int LA188_1 = input.LA(1);

						if ((LA188_1==LT))
						{
							alt188 = 1;
						}


						} finally { DebugExitDecision(188); }
						switch ( alt188 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:310:63: LT !
							{
							DebugLocation(310, 63);
							LT375=(IToken)Match(input,LT,Follow._LT_in_equalityExpression2015); if (state.failed) return retval;

							}
							break;

						default:
							goto loop188;
						}
					}

					loop188:
						;

					} finally { DebugExitSubRule(188); }

					DebugLocation(310, 66);
					PushFollow(Follow._relationalExpression_in_equalityExpression2019);
					relationalExpression376=relationalExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, relationalExpression376.Tree);

					}
					break;

				default:
					goto loop189;
				}
			}

			loop189:
				;

			} finally { DebugExitSubRule(189); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("equalityExpression", 67);
			LeaveRule("equalityExpression", 67);
			LeaveRule_equalityExpression();
			if (state.backtracking > 0) { Memoize(input, 67, equalityExpression_StartIndex); }

		}
		DebugLocation(311, 1);
		} finally { DebugExitRule(GrammarFileName, "equalityExpression"); }
		return retval;

	}
	// $ANTLR end "equalityExpression"

	partial void EnterRule_equalityExpressionNoIn();
	partial void LeaveRule_equalityExpressionNoIn();
	// $ANTLR start "equalityExpressionNoIn"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:313:1: equalityExpressionNoIn : relationalExpressionNoIn ( ( LT !)* ( '==' | '!=' | '===' | '!==' ) ( LT !)* relationalExpressionNoIn )* ;
	[GrammarRule("equalityExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> equalityExpressionNoIn()
	{
		EnterRule_equalityExpressionNoIn();
		EnterRule("equalityExpressionNoIn", 68);
		TraceIn("equalityExpressionNoIn", 68);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int equalityExpressionNoIn_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT378 = default(IToken);
		IToken set379 = default(IToken);
		IToken LT380 = default(IToken);
		AstParserRuleReturnScope<object, IToken> relationalExpressionNoIn377 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> relationalExpressionNoIn381 = default(AstParserRuleReturnScope<object, IToken>);

		object LT378_tree = default(object);
		object set379_tree = default(object);
		object LT380_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "equalityExpressionNoIn");
		DebugLocation(313, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 68)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:314:2: ( relationalExpressionNoIn ( ( LT !)* ( '==' | '!=' | '===' | '!==' ) ( LT !)* relationalExpressionNoIn )* )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:314:4: relationalExpressionNoIn ( ( LT !)* ( '==' | '!=' | '===' | '!==' ) ( LT !)* relationalExpressionNoIn )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(314, 4);
			PushFollow(Follow._relationalExpressionNoIn_in_equalityExpressionNoIn2032);
			relationalExpressionNoIn377=relationalExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, relationalExpressionNoIn377.Tree);
			DebugLocation(314, 29);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:314:29: ( ( LT !)* ( '==' | '!=' | '===' | '!==' ) ( LT !)* relationalExpressionNoIn )*
			try { DebugEnterSubRule(192);
			while (true)
			{
				int alt192=2;
				try { DebugEnterDecision(192, false);
				try
				{
					alt192 = dfa192.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(192); }
				switch ( alt192 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:314:30: ( LT !)* ( '==' | '!=' | '===' | '!==' ) ( LT !)* relationalExpressionNoIn
					{
					DebugLocation(314, 32);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:314:32: ( LT !)*
					try { DebugEnterSubRule(190);
					while (true)
					{
						int alt190=2;
						try { DebugEnterDecision(190, false);
						int LA190_1 = input.LA(1);

						if ((LA190_1==LT))
						{
							alt190 = 1;
						}


						} finally { DebugExitDecision(190); }
						switch ( alt190 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:314:32: LT !
							{
							DebugLocation(314, 32);
							LT378=(IToken)Match(input,LT,Follow._LT_in_equalityExpressionNoIn2035); if (state.failed) return retval;

							}
							break;

						default:
							goto loop190;
						}
					}

					loop190:
						;

					} finally { DebugExitSubRule(190); }

					DebugLocation(314, 35);

					set379=(IToken)input.LT(1);
					if ((input.LA(1)>=32 && input.LA(1)<=33)||(input.LA(1)>=60 && input.LA(1)<=61))
					{
						input.Consume();
						if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set379));
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(314, 67);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:314:67: ( LT !)*
					try { DebugEnterSubRule(191);
					while (true)
					{
						int alt191=2;
						try { DebugEnterDecision(191, false);
						int LA191_1 = input.LA(1);

						if ((LA191_1==LT))
						{
							alt191 = 1;
						}


						} finally { DebugExitDecision(191); }
						switch ( alt191 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:314:67: LT !
							{
							DebugLocation(314, 67);
							LT380=(IToken)Match(input,LT,Follow._LT_in_equalityExpressionNoIn2055); if (state.failed) return retval;

							}
							break;

						default:
							goto loop191;
						}
					}

					loop191:
						;

					} finally { DebugExitSubRule(191); }

					DebugLocation(314, 70);
					PushFollow(Follow._relationalExpressionNoIn_in_equalityExpressionNoIn2059);
					relationalExpressionNoIn381=relationalExpressionNoIn();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, relationalExpressionNoIn381.Tree);

					}
					break;

				default:
					goto loop192;
				}
			}

			loop192:
				;

			} finally { DebugExitSubRule(192); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("equalityExpressionNoIn", 68);
			LeaveRule("equalityExpressionNoIn", 68);
			LeaveRule_equalityExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 68, equalityExpressionNoIn_StartIndex); }

		}
		DebugLocation(315, 1);
		} finally { DebugExitRule(GrammarFileName, "equalityExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "equalityExpressionNoIn"

	partial void EnterRule_relationalExpression();
	partial void LeaveRule_relationalExpression();
	// $ANTLR start "relationalExpression"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:317:1: relationalExpression : shiftExpression ( ( LT !)* ( '<' | '>' | '<=' | '>=' | 'instanceof' | 'in' ) ( LT !)* shiftExpression )* ;
	[GrammarRule("relationalExpression")]
	private AstParserRuleReturnScope<object, IToken> relationalExpression()
	{
		EnterRule_relationalExpression();
		EnterRule("relationalExpression", 69);
		TraceIn("relationalExpression", 69);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int relationalExpression_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT383 = default(IToken);
		IToken set384 = default(IToken);
		IToken LT385 = default(IToken);
		AstParserRuleReturnScope<object, IToken> shiftExpression382 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> shiftExpression386 = default(AstParserRuleReturnScope<object, IToken>);

		object LT383_tree = default(object);
		object set384_tree = default(object);
		object LT385_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "relationalExpression");
		DebugLocation(317, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 69)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:318:2: ( shiftExpression ( ( LT !)* ( '<' | '>' | '<=' | '>=' | 'instanceof' | 'in' ) ( LT !)* shiftExpression )* )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:318:4: shiftExpression ( ( LT !)* ( '<' | '>' | '<=' | '>=' | 'instanceof' | 'in' ) ( LT !)* shiftExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(318, 4);
			PushFollow(Follow._shiftExpression_in_relationalExpression2073);
			shiftExpression382=shiftExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, shiftExpression382.Tree);
			DebugLocation(318, 20);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:318:20: ( ( LT !)* ( '<' | '>' | '<=' | '>=' | 'instanceof' | 'in' ) ( LT !)* shiftExpression )*
			try { DebugEnterSubRule(195);
			while (true)
			{
				int alt195=2;
				try { DebugEnterDecision(195, false);
				try
				{
					alt195 = dfa195.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(195); }
				switch ( alt195 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:318:21: ( LT !)* ( '<' | '>' | '<=' | '>=' | 'instanceof' | 'in' ) ( LT !)* shiftExpression
					{
					DebugLocation(318, 23);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:318:23: ( LT !)*
					try { DebugEnterSubRule(193);
					while (true)
					{
						int alt193=2;
						try { DebugEnterDecision(193, false);
						int LA193_1 = input.LA(1);

						if ((LA193_1==LT))
						{
							alt193 = 1;
						}


						} finally { DebugExitDecision(193); }
						switch ( alt193 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:318:23: LT !
							{
							DebugLocation(318, 23);
							LT383=(IToken)Match(input,LT,Follow._LT_in_relationalExpression2076); if (state.failed) return retval;

							}
							break;

						default:
							goto loop193;
						}
					}

					loop193:
						;

					} finally { DebugExitSubRule(193); }

					DebugLocation(318, 26);

					set384=(IToken)input.LT(1);
					if (input.LA(1)==55||input.LA(1)==58||(input.LA(1)>=62 && input.LA(1)<=63)||(input.LA(1)>=86 && input.LA(1)<=87))
					{
						input.Consume();
						if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set384));
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(318, 76);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:318:76: ( LT !)*
					try { DebugEnterSubRule(194);
					while (true)
					{
						int alt194=2;
						try { DebugEnterDecision(194, false);
						int LA194_1 = input.LA(1);

						if ((LA194_1==LT))
						{
							alt194 = 1;
						}


						} finally { DebugExitDecision(194); }
						switch ( alt194 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:318:76: LT !
							{
							DebugLocation(318, 76);
							LT385=(IToken)Match(input,LT,Follow._LT_in_relationalExpression2104); if (state.failed) return retval;

							}
							break;

						default:
							goto loop194;
						}
					}

					loop194:
						;

					} finally { DebugExitSubRule(194); }

					DebugLocation(318, 79);
					PushFollow(Follow._shiftExpression_in_relationalExpression2108);
					shiftExpression386=shiftExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, shiftExpression386.Tree);

					}
					break;

				default:
					goto loop195;
				}
			}

			loop195:
				;

			} finally { DebugExitSubRule(195); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relationalExpression", 69);
			LeaveRule("relationalExpression", 69);
			LeaveRule_relationalExpression();
			if (state.backtracking > 0) { Memoize(input, 69, relationalExpression_StartIndex); }

		}
		DebugLocation(319, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalExpression"); }
		return retval;

	}
	// $ANTLR end "relationalExpression"

	partial void EnterRule_relationalExpressionNoIn();
	partial void LeaveRule_relationalExpressionNoIn();
	// $ANTLR start "relationalExpressionNoIn"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:321:1: relationalExpressionNoIn : shiftExpression ( ( LT !)* ( '<' | '>' | '<=' | '>=' | 'instanceof' ) ( LT !)* shiftExpression )* ;
	[GrammarRule("relationalExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> relationalExpressionNoIn()
	{
		EnterRule_relationalExpressionNoIn();
		EnterRule("relationalExpressionNoIn", 70);
		TraceIn("relationalExpressionNoIn", 70);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int relationalExpressionNoIn_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT388 = default(IToken);
		IToken set389 = default(IToken);
		IToken LT390 = default(IToken);
		AstParserRuleReturnScope<object, IToken> shiftExpression387 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> shiftExpression391 = default(AstParserRuleReturnScope<object, IToken>);

		object LT388_tree = default(object);
		object set389_tree = default(object);
		object LT390_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "relationalExpressionNoIn");
		DebugLocation(321, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 70)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:322:2: ( shiftExpression ( ( LT !)* ( '<' | '>' | '<=' | '>=' | 'instanceof' ) ( LT !)* shiftExpression )* )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:322:4: shiftExpression ( ( LT !)* ( '<' | '>' | '<=' | '>=' | 'instanceof' ) ( LT !)* shiftExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(322, 4);
			PushFollow(Follow._shiftExpression_in_relationalExpressionNoIn2121);
			shiftExpression387=shiftExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, shiftExpression387.Tree);
			DebugLocation(322, 20);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:322:20: ( ( LT !)* ( '<' | '>' | '<=' | '>=' | 'instanceof' ) ( LT !)* shiftExpression )*
			try { DebugEnterSubRule(198);
			while (true)
			{
				int alt198=2;
				try { DebugEnterDecision(198, false);
				try
				{
					alt198 = dfa198.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(198); }
				switch ( alt198 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:322:21: ( LT !)* ( '<' | '>' | '<=' | '>=' | 'instanceof' ) ( LT !)* shiftExpression
					{
					DebugLocation(322, 23);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:322:23: ( LT !)*
					try { DebugEnterSubRule(196);
					while (true)
					{
						int alt196=2;
						try { DebugEnterDecision(196, false);
						int LA196_1 = input.LA(1);

						if ((LA196_1==LT))
						{
							alt196 = 1;
						}


						} finally { DebugExitDecision(196); }
						switch ( alt196 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:322:23: LT !
							{
							DebugLocation(322, 23);
							LT388=(IToken)Match(input,LT,Follow._LT_in_relationalExpressionNoIn2124); if (state.failed) return retval;

							}
							break;

						default:
							goto loop196;
						}
					}

					loop196:
						;

					} finally { DebugExitSubRule(196); }

					DebugLocation(322, 26);

					set389=(IToken)input.LT(1);
					if (input.LA(1)==55||input.LA(1)==58||(input.LA(1)>=62 && input.LA(1)<=63)||input.LA(1)==87)
					{
						input.Consume();
						if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set389));
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(322, 69);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:322:69: ( LT !)*
					try { DebugEnterSubRule(197);
					while (true)
					{
						int alt197=2;
						try { DebugEnterDecision(197, false);
						int LA197_1 = input.LA(1);

						if ((LA197_1==LT))
						{
							alt197 = 1;
						}


						} finally { DebugExitDecision(197); }
						switch ( alt197 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:322:69: LT !
							{
							DebugLocation(322, 69);
							LT390=(IToken)Match(input,LT,Follow._LT_in_relationalExpressionNoIn2148); if (state.failed) return retval;

							}
							break;

						default:
							goto loop197;
						}
					}

					loop197:
						;

					} finally { DebugExitSubRule(197); }

					DebugLocation(322, 72);
					PushFollow(Follow._shiftExpression_in_relationalExpressionNoIn2152);
					shiftExpression391=shiftExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, shiftExpression391.Tree);

					}
					break;

				default:
					goto loop198;
				}
			}

			loop198:
				;

			} finally { DebugExitSubRule(198); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relationalExpressionNoIn", 70);
			LeaveRule("relationalExpressionNoIn", 70);
			LeaveRule_relationalExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 70, relationalExpressionNoIn_StartIndex); }

		}
		DebugLocation(323, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "relationalExpressionNoIn"

	partial void EnterRule_shiftExpression();
	partial void LeaveRule_shiftExpression();
	// $ANTLR start "shiftExpression"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:325:1: shiftExpression : additiveExpression ( ( LT !)* ( '<<' | '>>' | '>>>' ) ( LT !)* additiveExpression )* ;
	[GrammarRule("shiftExpression")]
	private AstParserRuleReturnScope<object, IToken> shiftExpression()
	{
		EnterRule_shiftExpression();
		EnterRule("shiftExpression", 71);
		TraceIn("shiftExpression", 71);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int shiftExpression_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT393 = default(IToken);
		IToken set394 = default(IToken);
		IToken LT395 = default(IToken);
		AstParserRuleReturnScope<object, IToken> additiveExpression392 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> additiveExpression396 = default(AstParserRuleReturnScope<object, IToken>);

		object LT393_tree = default(object);
		object set394_tree = default(object);
		object LT395_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "shiftExpression");
		DebugLocation(325, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 71)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:326:2: ( additiveExpression ( ( LT !)* ( '<<' | '>>' | '>>>' ) ( LT !)* additiveExpression )* )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:326:4: additiveExpression ( ( LT !)* ( '<<' | '>>' | '>>>' ) ( LT !)* additiveExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(326, 4);
			PushFollow(Follow._additiveExpression_in_shiftExpression2165);
			additiveExpression392=additiveExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, additiveExpression392.Tree);
			DebugLocation(326, 23);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:326:23: ( ( LT !)* ( '<<' | '>>' | '>>>' ) ( LT !)* additiveExpression )*
			try { DebugEnterSubRule(201);
			while (true)
			{
				int alt201=2;
				try { DebugEnterDecision(201, false);
				try
				{
					alt201 = dfa201.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(201); }
				switch ( alt201 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:326:24: ( LT !)* ( '<<' | '>>' | '>>>' ) ( LT !)* additiveExpression
					{
					DebugLocation(326, 26);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:326:26: ( LT !)*
					try { DebugEnterSubRule(199);
					while (true)
					{
						int alt199=2;
						try { DebugEnterDecision(199, false);
						int LA199_1 = input.LA(1);

						if ((LA199_1==LT))
						{
							alt199 = 1;
						}


						} finally { DebugExitDecision(199); }
						switch ( alt199 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:326:26: LT !
							{
							DebugLocation(326, 26);
							LT393=(IToken)Match(input,LT,Follow._LT_in_shiftExpression2168); if (state.failed) return retval;

							}
							break;

						default:
							goto loop199;
						}
					}

					loop199:
						;

					} finally { DebugExitSubRule(199); }

					DebugLocation(326, 29);

					set394=(IToken)input.LT(1);
					if (input.LA(1)==56||input.LA(1)==64||input.LA(1)==66)
					{
						input.Consume();
						if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set394));
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(326, 53);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:326:53: ( LT !)*
					try { DebugEnterSubRule(200);
					while (true)
					{
						int alt200=2;
						try { DebugEnterDecision(200, false);
						int LA200_1 = input.LA(1);

						if ((LA200_1==LT))
						{
							alt200 = 1;
						}


						} finally { DebugExitDecision(200); }
						switch ( alt200 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:326:53: LT !
							{
							DebugLocation(326, 53);
							LT395=(IToken)Match(input,LT,Follow._LT_in_shiftExpression2184); if (state.failed) return retval;

							}
							break;

						default:
							goto loop200;
						}
					}

					loop200:
						;

					} finally { DebugExitSubRule(200); }

					DebugLocation(326, 56);
					PushFollow(Follow._additiveExpression_in_shiftExpression2188);
					additiveExpression396=additiveExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, additiveExpression396.Tree);

					}
					break;

				default:
					goto loop201;
				}
			}

			loop201:
				;

			} finally { DebugExitSubRule(201); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("shiftExpression", 71);
			LeaveRule("shiftExpression", 71);
			LeaveRule_shiftExpression();
			if (state.backtracking > 0) { Memoize(input, 71, shiftExpression_StartIndex); }

		}
		DebugLocation(327, 1);
		} finally { DebugExitRule(GrammarFileName, "shiftExpression"); }
		return retval;

	}
	// $ANTLR end "shiftExpression"

	partial void EnterRule_additiveExpression();
	partial void LeaveRule_additiveExpression();
	// $ANTLR start "additiveExpression"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:329:1: additiveExpression : multiplicativeExpression ( ( LT !)* ( '+' | '-' ) ( LT !)* multiplicativeExpression )* ;
	[GrammarRule("additiveExpression")]
	private AstParserRuleReturnScope<object, IToken> additiveExpression()
	{
		EnterRule_additiveExpression();
		EnterRule("additiveExpression", 72);
		TraceIn("additiveExpression", 72);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int additiveExpression_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT398 = default(IToken);
		IToken set399 = default(IToken);
		IToken LT400 = default(IToken);
		AstParserRuleReturnScope<object, IToken> multiplicativeExpression397 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> multiplicativeExpression401 = default(AstParserRuleReturnScope<object, IToken>);

		object LT398_tree = default(object);
		object set399_tree = default(object);
		object LT400_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "additiveExpression");
		DebugLocation(329, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 72)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:330:2: ( multiplicativeExpression ( ( LT !)* ( '+' | '-' ) ( LT !)* multiplicativeExpression )* )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:330:4: multiplicativeExpression ( ( LT !)* ( '+' | '-' ) ( LT !)* multiplicativeExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(330, 4);
			PushFollow(Follow._multiplicativeExpression_in_additiveExpression2201);
			multiplicativeExpression397=multiplicativeExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, multiplicativeExpression397.Tree);
			DebugLocation(330, 29);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:330:29: ( ( LT !)* ( '+' | '-' ) ( LT !)* multiplicativeExpression )*
			try { DebugEnterSubRule(204);
			while (true)
			{
				int alt204=2;
				try { DebugEnterDecision(204, false);
				int LA204_1 = input.LA(1);

				if ((LA204_1==LT))
				{
					int LA204_2 = input.LA(2);

					if ((EvaluatePredicate(synpred256_TypeScript_fragment)))
					{
						alt204 = 1;
					}


				}
				else if ((LA204_1==43||LA204_1==47))
				{
					alt204 = 1;
				}


				} finally { DebugExitDecision(204); }
				switch ( alt204 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:330:30: ( LT !)* ( '+' | '-' ) ( LT !)* multiplicativeExpression
					{
					DebugLocation(330, 32);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:330:32: ( LT !)*
					try { DebugEnterSubRule(202);
					while (true)
					{
						int alt202=2;
						try { DebugEnterDecision(202, false);
						int LA202_1 = input.LA(1);

						if ((LA202_1==LT))
						{
							alt202 = 1;
						}


						} finally { DebugExitDecision(202); }
						switch ( alt202 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:330:32: LT !
							{
							DebugLocation(330, 32);
							LT398=(IToken)Match(input,LT,Follow._LT_in_additiveExpression2204); if (state.failed) return retval;

							}
							break;

						default:
							goto loop202;
						}
					}

					loop202:
						;

					} finally { DebugExitSubRule(202); }

					DebugLocation(330, 35);

					set399=(IToken)input.LT(1);
					if (input.LA(1)==43||input.LA(1)==47)
					{
						input.Consume();
						if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set399));
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(330, 49);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:330:49: ( LT !)*
					try { DebugEnterSubRule(203);
					while (true)
					{
						int alt203=2;
						try { DebugEnterDecision(203, false);
						int LA203_1 = input.LA(1);

						if ((LA203_1==LT))
						{
							alt203 = 1;
						}


						} finally { DebugExitDecision(203); }
						switch ( alt203 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:330:49: LT !
							{
							DebugLocation(330, 49);
							LT400=(IToken)Match(input,LT,Follow._LT_in_additiveExpression2216); if (state.failed) return retval;

							}
							break;

						default:
							goto loop203;
						}
					}

					loop203:
						;

					} finally { DebugExitSubRule(203); }

					DebugLocation(330, 52);
					PushFollow(Follow._multiplicativeExpression_in_additiveExpression2220);
					multiplicativeExpression401=multiplicativeExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, multiplicativeExpression401.Tree);

					}
					break;

				default:
					goto loop204;
				}
			}

			loop204:
				;

			} finally { DebugExitSubRule(204); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("additiveExpression", 72);
			LeaveRule("additiveExpression", 72);
			LeaveRule_additiveExpression();
			if (state.backtracking > 0) { Memoize(input, 72, additiveExpression_StartIndex); }

		}
		DebugLocation(331, 1);
		} finally { DebugExitRule(GrammarFileName, "additiveExpression"); }
		return retval;

	}
	// $ANTLR end "additiveExpression"

	partial void EnterRule_multiplicativeExpression();
	partial void LeaveRule_multiplicativeExpression();
	// $ANTLR start "multiplicativeExpression"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:333:1: multiplicativeExpression : unaryExpression ( ( LT !)* ( '*' | '/' | '%' ) ( LT !)* unaryExpression )* ;
	[GrammarRule("multiplicativeExpression")]
	private AstParserRuleReturnScope<object, IToken> multiplicativeExpression()
	{
		EnterRule_multiplicativeExpression();
		EnterRule("multiplicativeExpression", 73);
		TraceIn("multiplicativeExpression", 73);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int multiplicativeExpression_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT403 = default(IToken);
		IToken set404 = default(IToken);
		IToken LT405 = default(IToken);
		AstParserRuleReturnScope<object, IToken> unaryExpression402 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> unaryExpression406 = default(AstParserRuleReturnScope<object, IToken>);

		object LT403_tree = default(object);
		object set404_tree = default(object);
		object LT405_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "multiplicativeExpression");
		DebugLocation(333, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 73)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:334:2: ( unaryExpression ( ( LT !)* ( '*' | '/' | '%' ) ( LT !)* unaryExpression )* )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:334:4: unaryExpression ( ( LT !)* ( '*' | '/' | '%' ) ( LT !)* unaryExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(334, 4);
			PushFollow(Follow._unaryExpression_in_multiplicativeExpression2233);
			unaryExpression402=unaryExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpression402.Tree);
			DebugLocation(334, 20);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:334:20: ( ( LT !)* ( '*' | '/' | '%' ) ( LT !)* unaryExpression )*
			try { DebugEnterSubRule(207);
			while (true)
			{
				int alt207=2;
				try { DebugEnterDecision(207, false);
				try
				{
					alt207 = dfa207.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(207); }
				switch ( alt207 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:334:21: ( LT !)* ( '*' | '/' | '%' ) ( LT !)* unaryExpression
					{
					DebugLocation(334, 23);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:334:23: ( LT !)*
					try { DebugEnterSubRule(205);
					while (true)
					{
						int alt205=2;
						try { DebugEnterDecision(205, false);
						int LA205_1 = input.LA(1);

						if ((LA205_1==LT))
						{
							alt205 = 1;
						}


						} finally { DebugExitDecision(205); }
						switch ( alt205 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:334:23: LT !
							{
							DebugLocation(334, 23);
							LT403=(IToken)Match(input,LT,Follow._LT_in_multiplicativeExpression2236); if (state.failed) return retval;

							}
							break;

						default:
							goto loop205;
						}
					}

					loop205:
						;

					} finally { DebugExitSubRule(205); }

					DebugLocation(334, 26);

					set404=(IToken)input.LT(1);
					if (input.LA(1)==34||input.LA(1)==41||input.LA(1)==51)
					{
						input.Consume();
						if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set404));
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(334, 46);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:334:46: ( LT !)*
					try { DebugEnterSubRule(206);
					while (true)
					{
						int alt206=2;
						try { DebugEnterDecision(206, false);
						int LA206_1 = input.LA(1);

						if ((LA206_1==LT))
						{
							alt206 = 1;
						}


						} finally { DebugExitDecision(206); }
						switch ( alt206 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:334:46: LT !
							{
							DebugLocation(334, 46);
							LT405=(IToken)Match(input,LT,Follow._LT_in_multiplicativeExpression2252); if (state.failed) return retval;

							}
							break;

						default:
							goto loop206;
						}
					}

					loop206:
						;

					} finally { DebugExitSubRule(206); }

					DebugLocation(334, 49);
					PushFollow(Follow._unaryExpression_in_multiplicativeExpression2256);
					unaryExpression406=unaryExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpression406.Tree);

					}
					break;

				default:
					goto loop207;
				}
			}

			loop207:
				;

			} finally { DebugExitSubRule(207); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multiplicativeExpression", 73);
			LeaveRule("multiplicativeExpression", 73);
			LeaveRule_multiplicativeExpression();
			if (state.backtracking > 0) { Memoize(input, 73, multiplicativeExpression_StartIndex); }

		}
		DebugLocation(335, 1);
		} finally { DebugExitRule(GrammarFileName, "multiplicativeExpression"); }
		return retval;

	}
	// $ANTLR end "multiplicativeExpression"

	partial void EnterRule_unaryExpression();
	partial void LeaveRule_unaryExpression();
	// $ANTLR start "unaryExpression"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:337:1: unaryExpression : ( postfixExpression | ( 'delete' | 'void' | 'typeof' | '++' | '--' | '+' | '-' | '~' | '!' ) unaryExpression );
	[GrammarRule("unaryExpression")]
	private AstParserRuleReturnScope<object, IToken> unaryExpression()
	{
		EnterRule_unaryExpression();
		EnterRule("unaryExpression", 74);
		TraceIn("unaryExpression", 74);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int unaryExpression_StartIndex = input.Index;

		object root_0 = default(object);

		IToken set408 = default(IToken);
		AstParserRuleReturnScope<object, IToken> postfixExpression407 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> unaryExpression409 = default(AstParserRuleReturnScope<object, IToken>);

		object set408_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "unaryExpression");
		DebugLocation(337, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 74)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:338:2: ( postfixExpression | ( 'delete' | 'void' | 'typeof' | '++' | '--' | '+' | '-' | '~' | '!' ) unaryExpression )
			int alt208=2;
			try { DebugEnterDecision(208, false);
			int LA208_1 = input.LA(1);

			if ((LA208_1==Identifier||LA208_1==NumericLiteral||LA208_1==StringLiteral||LA208_1==39||LA208_1==69||LA208_1==81||LA208_1==84||(LA208_1>=88 && LA208_1<=89)||LA208_1==92||LA208_1==94||LA208_1==101))
			{
				alt208 = 1;
			}
			else if ((LA208_1==31||(LA208_1>=43 && LA208_1<=44)||(LA208_1>=47 && LA208_1<=48)||LA208_1==78||LA208_1==96||LA208_1==98||LA208_1==106))
			{
				alt208 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 208, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(208); }
			switch (alt208)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:338:4: postfixExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(338, 4);
				PushFollow(Follow._postfixExpression_in_unaryExpression2269);
				postfixExpression407=postfixExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, postfixExpression407.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:339:4: ( 'delete' | 'void' | 'typeof' | '++' | '--' | '+' | '-' | '~' | '!' ) unaryExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(339, 4);

				set408=(IToken)input.LT(1);
				if (input.LA(1)==31||(input.LA(1)>=43 && input.LA(1)<=44)||(input.LA(1)>=47 && input.LA(1)<=48)||input.LA(1)==78||input.LA(1)==96||input.LA(1)==98||input.LA(1)==106)
				{
					input.Consume();
					if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set408));
					state.errorRecovery=false;state.failed=false;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(339, 73);
				PushFollow(Follow._unaryExpression_in_unaryExpression2310);
				unaryExpression409=unaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpression409.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unaryExpression", 74);
			LeaveRule("unaryExpression", 74);
			LeaveRule_unaryExpression();
			if (state.backtracking > 0) { Memoize(input, 74, unaryExpression_StartIndex); }

		}
		DebugLocation(340, 1);
		} finally { DebugExitRule(GrammarFileName, "unaryExpression"); }
		return retval;

	}
	// $ANTLR end "unaryExpression"

	partial void EnterRule_postfixExpression();
	partial void LeaveRule_postfixExpression();
	// $ANTLR start "postfixExpression"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:342:1: postfixExpression : leftHandSideExpression ( '++' | '--' )? ;
	[GrammarRule("postfixExpression")]
	private AstParserRuleReturnScope<object, IToken> postfixExpression()
	{
		EnterRule_postfixExpression();
		EnterRule("postfixExpression", 75);
		TraceIn("postfixExpression", 75);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int postfixExpression_StartIndex = input.Index;

		object root_0 = default(object);

		IToken set411 = default(IToken);
		AstParserRuleReturnScope<object, IToken> leftHandSideExpression410 = default(AstParserRuleReturnScope<object, IToken>);

		object set411_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "postfixExpression");
		DebugLocation(342, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 75)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:343:2: ( leftHandSideExpression ( '++' | '--' )? )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:343:4: leftHandSideExpression ( '++' | '--' )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(343, 4);
			PushFollow(Follow._leftHandSideExpression_in_postfixExpression2322);
			leftHandSideExpression410=leftHandSideExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, leftHandSideExpression410.Tree);
			DebugLocation(343, 27);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:343:27: ( '++' | '--' )?
			int alt209=2;
			try { DebugEnterSubRule(209);
			try { DebugEnterDecision(209, false);
			int LA209_1 = input.LA(1);

			if ((LA209_1==44||LA209_1==48))
			{
				alt209 = 1;
			}
			} finally { DebugExitDecision(209); }
			switch (alt209)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:
				{
				DebugLocation(343, 27);

				set411=(IToken)input.LT(1);
				if (input.LA(1)==44||input.LA(1)==48)
				{
					input.Consume();
					if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set411));
					state.errorRecovery=false;state.failed=false;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}


				}
				break;

			}
			} finally { DebugExitSubRule(209); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("postfixExpression", 75);
			LeaveRule("postfixExpression", 75);
			LeaveRule_postfixExpression();
			if (state.backtracking > 0) { Memoize(input, 75, postfixExpression_StartIndex); }

		}
		DebugLocation(344, 1);
		} finally { DebugExitRule(GrammarFileName, "postfixExpression"); }
		return retval;

	}
	// $ANTLR end "postfixExpression"

	partial void EnterRule_primaryExpression();
	partial void LeaveRule_primaryExpression();
	// $ANTLR start "primaryExpression"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:346:1: primaryExpression : ( 'this' | Identifier | literal | arrayLiteral | objectLiteral | '(' ( LT !)* expression ( LT !)* ')' );
	[GrammarRule("primaryExpression")]
	private AstParserRuleReturnScope<object, IToken> primaryExpression()
	{
		EnterRule_primaryExpression();
		EnterRule("primaryExpression", 76);
		TraceIn("primaryExpression", 76);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int primaryExpression_StartIndex = input.Index;

		object root_0 = default(object);

		IToken string_literal412 = default(IToken);
		IToken Identifier413 = default(IToken);
		IToken char_literal417 = default(IToken);
		IToken LT418 = default(IToken);
		IToken LT420 = default(IToken);
		IToken char_literal421 = default(IToken);
		AstParserRuleReturnScope<object, IToken> literal414 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> arrayLiteral415 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> objectLiteral416 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression419 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal412_tree = default(object);
		object Identifier413_tree = default(object);
		object char_literal417_tree = default(object);
		object LT418_tree = default(object);
		object LT420_tree = default(object);
		object char_literal421_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "primaryExpression");
		DebugLocation(346, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 76)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:347:2: ( 'this' | Identifier | literal | arrayLiteral | objectLiteral | '(' ( LT !)* expression ( LT !)* ')' )
			int alt212=6;
			try { DebugEnterDecision(212, false);
			switch (input.LA(1))
			{
			case 92:
				{
				alt212 = 1;
				}
				break;
			case Identifier:
				{
				alt212 = 2;
				}
				break;
			case NumericLiteral:
			case StringLiteral:
			case 81:
			case 89:
			case 94:
				{
				alt212 = 3;
				}
				break;
			case 69:
				{
				alt212 = 4;
				}
				break;
			case 101:
				{
				alt212 = 5;
				}
				break;
			case 39:
				{
				alt212 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 212, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(212); }
			switch (alt212)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:347:4: 'this'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(347, 4);
				string_literal412=(IToken)Match(input,92,Follow._92_in_primaryExpression2342); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal412_tree = (object)adaptor.Create(string_literal412);
				adaptor.AddChild(root_0, string_literal412_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:348:4: Identifier
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(348, 4);
				Identifier413=(IToken)Match(input,Identifier,Follow._Identifier_in_primaryExpression2347); if (state.failed) return retval;
				if (state.backtracking == 0) {
				Identifier413_tree = (object)adaptor.Create(Identifier413);
				adaptor.AddChild(root_0, Identifier413_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:349:4: literal
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(349, 4);
				PushFollow(Follow._literal_in_primaryExpression2352);
				literal414=literal();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, literal414.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:350:4: arrayLiteral
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(350, 4);
				PushFollow(Follow._arrayLiteral_in_primaryExpression2357);
				arrayLiteral415=arrayLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, arrayLiteral415.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:351:4: objectLiteral
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(351, 4);
				PushFollow(Follow._objectLiteral_in_primaryExpression2362);
				objectLiteral416=objectLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, objectLiteral416.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:352:4: '(' ( LT !)* expression ( LT !)* ')'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(352, 4);
				char_literal417=(IToken)Match(input,39,Follow._39_in_primaryExpression2367); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal417_tree = (object)adaptor.Create(char_literal417);
				adaptor.AddChild(root_0, char_literal417_tree);
				}
				DebugLocation(352, 10);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:352:10: ( LT !)*
				try { DebugEnterSubRule(210);
				while (true)
				{
					int alt210=2;
					try { DebugEnterDecision(210, false);
					int LA210_1 = input.LA(1);

					if ((LA210_1==LT))
					{
						alt210 = 1;
					}


					} finally { DebugExitDecision(210); }
					switch ( alt210 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:352:10: LT !
						{
						DebugLocation(352, 10);
						LT418=(IToken)Match(input,LT,Follow._LT_in_primaryExpression2369); if (state.failed) return retval;

						}
						break;

					default:
						goto loop210;
					}
				}

				loop210:
					;

				} finally { DebugExitSubRule(210); }

				DebugLocation(352, 13);
				PushFollow(Follow._expression_in_primaryExpression2373);
				expression419=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expression419.Tree);
				DebugLocation(352, 26);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:352:26: ( LT !)*
				try { DebugEnterSubRule(211);
				while (true)
				{
					int alt211=2;
					try { DebugEnterDecision(211, false);
					int LA211_1 = input.LA(1);

					if ((LA211_1==LT))
					{
						alt211 = 1;
					}


					} finally { DebugExitDecision(211); }
					switch ( alt211 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:352:26: LT !
						{
						DebugLocation(352, 26);
						LT420=(IToken)Match(input,LT,Follow._LT_in_primaryExpression2375); if (state.failed) return retval;

						}
						break;

					default:
						goto loop211;
					}
				}

				loop211:
					;

				} finally { DebugExitSubRule(211); }

				DebugLocation(352, 29);
				char_literal421=(IToken)Match(input,40,Follow._40_in_primaryExpression2379); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal421_tree = (object)adaptor.Create(char_literal421);
				adaptor.AddChild(root_0, char_literal421_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primaryExpression", 76);
			LeaveRule("primaryExpression", 76);
			LeaveRule_primaryExpression();
			if (state.backtracking > 0) { Memoize(input, 76, primaryExpression_StartIndex); }

		}
		DebugLocation(353, 1);
		} finally { DebugExitRule(GrammarFileName, "primaryExpression"); }
		return retval;

	}
	// $ANTLR end "primaryExpression"

	partial void EnterRule_arrayLiteral();
	partial void LeaveRule_arrayLiteral();
	// $ANTLR start "arrayLiteral"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:356:1: arrayLiteral : '[' ( LT !)* ( assignmentExpression )? ( ( LT !)* ',' ( ( LT !)* assignmentExpression )? )* ( LT !)* ']' ;
	[GrammarRule("arrayLiteral")]
	private AstParserRuleReturnScope<object, IToken> arrayLiteral()
	{
		EnterRule_arrayLiteral();
		EnterRule("arrayLiteral", 77);
		TraceIn("arrayLiteral", 77);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int arrayLiteral_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal422 = default(IToken);
		IToken LT423 = default(IToken);
		IToken LT425 = default(IToken);
		IToken char_literal426 = default(IToken);
		IToken LT427 = default(IToken);
		IToken LT429 = default(IToken);
		IToken char_literal430 = default(IToken);
		AstParserRuleReturnScope<object, IToken> assignmentExpression424 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpression428 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal422_tree = default(object);
		object LT423_tree = default(object);
		object LT425_tree = default(object);
		object char_literal426_tree = default(object);
		object LT427_tree = default(object);
		object LT429_tree = default(object);
		object char_literal430_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "arrayLiteral");
		DebugLocation(356, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 77)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:357:2: ( '[' ( LT !)* ( assignmentExpression )? ( ( LT !)* ',' ( ( LT !)* assignmentExpression )? )* ( LT !)* ']' )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:357:4: '[' ( LT !)* ( assignmentExpression )? ( ( LT !)* ',' ( ( LT !)* assignmentExpression )? )* ( LT !)* ']'
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(357, 4);
			char_literal422=(IToken)Match(input,69,Follow._69_in_arrayLiteral2392); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal422_tree = (object)adaptor.Create(char_literal422);
			adaptor.AddChild(root_0, char_literal422_tree);
			}
			DebugLocation(357, 10);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:357:10: ( LT !)*
			try { DebugEnterSubRule(213);
			while (true)
			{
				int alt213=2;
				try { DebugEnterDecision(213, false);
				int LA213_1 = input.LA(1);

				if ((LA213_1==LT))
				{
					int LA213_2 = input.LA(2);

					if ((EvaluatePredicate(synpred280_TypeScript_fragment)))
					{
						alt213 = 1;
					}


				}


				} finally { DebugExitDecision(213); }
				switch ( alt213 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:357:10: LT !
					{
					DebugLocation(357, 10);
					LT423=(IToken)Match(input,LT,Follow._LT_in_arrayLiteral2394); if (state.failed) return retval;

					}
					break;

				default:
					goto loop213;
				}
			}

			loop213:
				;

			} finally { DebugExitSubRule(213); }

			DebugLocation(357, 13);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:357:13: ( assignmentExpression )?
			int alt214=2;
			try { DebugEnterSubRule(214);
			try { DebugEnterDecision(214, false);
			int LA214_1 = input.LA(1);

			if ((LA214_1==Identifier||LA214_1==NumericLiteral||LA214_1==StringLiteral||LA214_1==31||LA214_1==39||(LA214_1>=43 && LA214_1<=44)||(LA214_1>=47 && LA214_1<=48)||LA214_1==69||LA214_1==78||LA214_1==81||LA214_1==84||(LA214_1>=88 && LA214_1<=89)||LA214_1==92||LA214_1==94||LA214_1==96||LA214_1==98||LA214_1==101||LA214_1==106))
			{
				alt214 = 1;
			}
			} finally { DebugExitDecision(214); }
			switch (alt214)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\DEVGIT\\typesharp\\TypeScript.g:357:13: assignmentExpression
				{
				DebugLocation(357, 13);
				PushFollow(Follow._assignmentExpression_in_arrayLiteral2398);
				assignmentExpression424=assignmentExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression424.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(214); }

			DebugLocation(357, 35);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:357:35: ( ( LT !)* ',' ( ( LT !)* assignmentExpression )? )*
			try { DebugEnterSubRule(218);
			while (true)
			{
				int alt218=2;
				try { DebugEnterDecision(218, false);
				try
				{
					alt218 = dfa218.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(218); }
				switch ( alt218 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:357:36: ( LT !)* ',' ( ( LT !)* assignmentExpression )?
					{
					DebugLocation(357, 38);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:357:38: ( LT !)*
					try { DebugEnterSubRule(215);
					while (true)
					{
						int alt215=2;
						try { DebugEnterDecision(215, false);
						int LA215_1 = input.LA(1);

						if ((LA215_1==LT))
						{
							alt215 = 1;
						}


						} finally { DebugExitDecision(215); }
						switch ( alt215 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:357:38: LT !
							{
							DebugLocation(357, 38);
							LT425=(IToken)Match(input,LT,Follow._LT_in_arrayLiteral2402); if (state.failed) return retval;

							}
							break;

						default:
							goto loop215;
						}
					}

					loop215:
						;

					} finally { DebugExitSubRule(215); }

					DebugLocation(357, 41);
					char_literal426=(IToken)Match(input,46,Follow._46_in_arrayLiteral2406); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal426_tree = (object)adaptor.Create(char_literal426);
					adaptor.AddChild(root_0, char_literal426_tree);
					}
					DebugLocation(357, 45);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:357:45: ( ( LT !)* assignmentExpression )?
					int alt217=2;
					try { DebugEnterSubRule(217);
					try { DebugEnterDecision(217, false);
					try
					{
						alt217 = dfa217.Predict(input);
					}
					catch (NoViableAltException nvae)
					{
						DebugRecognitionException(nvae);
						throw;
					}
					} finally { DebugExitDecision(217); }
					switch (alt217)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:357:46: ( LT !)* assignmentExpression
						{
						DebugLocation(357, 48);
						// C:\\DEVGIT\\typesharp\\TypeScript.g:357:48: ( LT !)*
						try { DebugEnterSubRule(216);
						while (true)
						{
							int alt216=2;
							try { DebugEnterDecision(216, false);
							int LA216_1 = input.LA(1);

							if ((LA216_1==LT))
							{
								alt216 = 1;
							}


							} finally { DebugExitDecision(216); }
							switch ( alt216 )
							{
							case 1:
								DebugEnterAlt(1);
								// C:\\DEVGIT\\typesharp\\TypeScript.g:357:48: LT !
								{
								DebugLocation(357, 48);
								LT427=(IToken)Match(input,LT,Follow._LT_in_arrayLiteral2409); if (state.failed) return retval;

								}
								break;

							default:
								goto loop216;
							}
						}

						loop216:
							;

						} finally { DebugExitSubRule(216); }

						DebugLocation(357, 51);
						PushFollow(Follow._assignmentExpression_in_arrayLiteral2413);
						assignmentExpression428=assignmentExpression();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression428.Tree);

						}
						break;

					}
					} finally { DebugExitSubRule(217); }


					}
					break;

				default:
					goto loop218;
				}
			}

			loop218:
				;

			} finally { DebugExitSubRule(218); }

			DebugLocation(357, 78);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:357:78: ( LT !)*
			try { DebugEnterSubRule(219);
			while (true)
			{
				int alt219=2;
				try { DebugEnterDecision(219, false);
				int LA219_1 = input.LA(1);

				if ((LA219_1==LT))
				{
					alt219 = 1;
				}


				} finally { DebugExitDecision(219); }
				switch ( alt219 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:357:78: LT !
					{
					DebugLocation(357, 78);
					LT429=(IToken)Match(input,LT,Follow._LT_in_arrayLiteral2419); if (state.failed) return retval;

					}
					break;

				default:
					goto loop219;
				}
			}

			loop219:
				;

			} finally { DebugExitSubRule(219); }

			DebugLocation(357, 81);
			char_literal430=(IToken)Match(input,70,Follow._70_in_arrayLiteral2423); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal430_tree = (object)adaptor.Create(char_literal430);
			adaptor.AddChild(root_0, char_literal430_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arrayLiteral", 77);
			LeaveRule("arrayLiteral", 77);
			LeaveRule_arrayLiteral();
			if (state.backtracking > 0) { Memoize(input, 77, arrayLiteral_StartIndex); }

		}
		DebugLocation(358, 1);
		} finally { DebugExitRule(GrammarFileName, "arrayLiteral"); }
		return retval;

	}
	// $ANTLR end "arrayLiteral"

	partial void EnterRule_objectLiteral();
	partial void LeaveRule_objectLiteral();
	// $ANTLR start "objectLiteral"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:361:1: objectLiteral : '{' ( LT !)* propertyNameAndValue ( ( LT !)* ',' ( LT !)* propertyNameAndValue )* ( LT !)* '}' ;
	[GrammarRule("objectLiteral")]
	private AstParserRuleReturnScope<object, IToken> objectLiteral()
	{
		EnterRule_objectLiteral();
		EnterRule("objectLiteral", 78);
		TraceIn("objectLiteral", 78);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int objectLiteral_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal431 = default(IToken);
		IToken LT432 = default(IToken);
		IToken LT434 = default(IToken);
		IToken char_literal435 = default(IToken);
		IToken LT436 = default(IToken);
		IToken LT438 = default(IToken);
		IToken char_literal439 = default(IToken);
		AstParserRuleReturnScope<object, IToken> propertyNameAndValue433 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> propertyNameAndValue437 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal431_tree = default(object);
		object LT432_tree = default(object);
		object LT434_tree = default(object);
		object char_literal435_tree = default(object);
		object LT436_tree = default(object);
		object LT438_tree = default(object);
		object char_literal439_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "objectLiteral");
		DebugLocation(361, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 78)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:362:2: ( '{' ( LT !)* propertyNameAndValue ( ( LT !)* ',' ( LT !)* propertyNameAndValue )* ( LT !)* '}' )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:362:4: '{' ( LT !)* propertyNameAndValue ( ( LT !)* ',' ( LT !)* propertyNameAndValue )* ( LT !)* '}'
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(362, 4);
			char_literal431=(IToken)Match(input,101,Follow._101_in_objectLiteral2442); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal431_tree = (object)adaptor.Create(char_literal431);
			adaptor.AddChild(root_0, char_literal431_tree);
			}
			DebugLocation(362, 10);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:362:10: ( LT !)*
			try { DebugEnterSubRule(220);
			while (true)
			{
				int alt220=2;
				try { DebugEnterDecision(220, false);
				int LA220_1 = input.LA(1);

				if ((LA220_1==LT))
				{
					alt220 = 1;
				}


				} finally { DebugExitDecision(220); }
				switch ( alt220 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:362:10: LT !
					{
					DebugLocation(362, 10);
					LT432=(IToken)Match(input,LT,Follow._LT_in_objectLiteral2444); if (state.failed) return retval;

					}
					break;

				default:
					goto loop220;
				}
			}

			loop220:
				;

			} finally { DebugExitSubRule(220); }

			DebugLocation(362, 13);
			PushFollow(Follow._propertyNameAndValue_in_objectLiteral2448);
			propertyNameAndValue433=propertyNameAndValue();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, propertyNameAndValue433.Tree);
			DebugLocation(362, 34);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:362:34: ( ( LT !)* ',' ( LT !)* propertyNameAndValue )*
			try { DebugEnterSubRule(223);
			while (true)
			{
				int alt223=2;
				try { DebugEnterDecision(223, false);
				try
				{
					alt223 = dfa223.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(223); }
				switch ( alt223 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:362:35: ( LT !)* ',' ( LT !)* propertyNameAndValue
					{
					DebugLocation(362, 37);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:362:37: ( LT !)*
					try { DebugEnterSubRule(221);
					while (true)
					{
						int alt221=2;
						try { DebugEnterDecision(221, false);
						int LA221_1 = input.LA(1);

						if ((LA221_1==LT))
						{
							alt221 = 1;
						}


						} finally { DebugExitDecision(221); }
						switch ( alt221 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:362:37: LT !
							{
							DebugLocation(362, 37);
							LT434=(IToken)Match(input,LT,Follow._LT_in_objectLiteral2451); if (state.failed) return retval;

							}
							break;

						default:
							goto loop221;
						}
					}

					loop221:
						;

					} finally { DebugExitSubRule(221); }

					DebugLocation(362, 40);
					char_literal435=(IToken)Match(input,46,Follow._46_in_objectLiteral2455); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal435_tree = (object)adaptor.Create(char_literal435);
					adaptor.AddChild(root_0, char_literal435_tree);
					}
					DebugLocation(362, 46);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:362:46: ( LT !)*
					try { DebugEnterSubRule(222);
					while (true)
					{
						int alt222=2;
						try { DebugEnterDecision(222, false);
						int LA222_1 = input.LA(1);

						if ((LA222_1==LT))
						{
							alt222 = 1;
						}


						} finally { DebugExitDecision(222); }
						switch ( alt222 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\DEVGIT\\typesharp\\TypeScript.g:362:46: LT !
							{
							DebugLocation(362, 46);
							LT436=(IToken)Match(input,LT,Follow._LT_in_objectLiteral2457); if (state.failed) return retval;

							}
							break;

						default:
							goto loop222;
						}
					}

					loop222:
						;

					} finally { DebugExitSubRule(222); }

					DebugLocation(362, 49);
					PushFollow(Follow._propertyNameAndValue_in_objectLiteral2461);
					propertyNameAndValue437=propertyNameAndValue();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, propertyNameAndValue437.Tree);

					}
					break;

				default:
					goto loop223;
				}
			}

			loop223:
				;

			} finally { DebugExitSubRule(223); }

			DebugLocation(362, 74);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:362:74: ( LT !)*
			try { DebugEnterSubRule(224);
			while (true)
			{
				int alt224=2;
				try { DebugEnterDecision(224, false);
				int LA224_1 = input.LA(1);

				if ((LA224_1==LT))
				{
					alt224 = 1;
				}


				} finally { DebugExitDecision(224); }
				switch ( alt224 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:362:74: LT !
					{
					DebugLocation(362, 74);
					LT438=(IToken)Match(input,LT,Follow._LT_in_objectLiteral2465); if (state.failed) return retval;

					}
					break;

				default:
					goto loop224;
				}
			}

			loop224:
				;

			} finally { DebugExitSubRule(224); }

			DebugLocation(362, 77);
			char_literal439=(IToken)Match(input,105,Follow._105_in_objectLiteral2469); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal439_tree = (object)adaptor.Create(char_literal439);
			adaptor.AddChild(root_0, char_literal439_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("objectLiteral", 78);
			LeaveRule("objectLiteral", 78);
			LeaveRule_objectLiteral();
			if (state.backtracking > 0) { Memoize(input, 78, objectLiteral_StartIndex); }

		}
		DebugLocation(363, 1);
		} finally { DebugExitRule(GrammarFileName, "objectLiteral"); }
		return retval;

	}
	// $ANTLR end "objectLiteral"

	partial void EnterRule_propertyNameAndValue();
	partial void LeaveRule_propertyNameAndValue();
	// $ANTLR start "propertyNameAndValue"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:365:1: propertyNameAndValue : propertyName ( LT !)* ':' ( LT !)* assignmentExpression ;
	[GrammarRule("propertyNameAndValue")]
	private AstParserRuleReturnScope<object, IToken> propertyNameAndValue()
	{
		EnterRule_propertyNameAndValue();
		EnterRule("propertyNameAndValue", 79);
		TraceIn("propertyNameAndValue", 79);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int propertyNameAndValue_StartIndex = input.Index;

		object root_0 = default(object);

		IToken LT441 = default(IToken);
		IToken char_literal442 = default(IToken);
		IToken LT443 = default(IToken);
		AstParserRuleReturnScope<object, IToken> propertyName440 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpression444 = default(AstParserRuleReturnScope<object, IToken>);

		object LT441_tree = default(object);
		object char_literal442_tree = default(object);
		object LT443_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "propertyNameAndValue");
		DebugLocation(365, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 79)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:366:2: ( propertyName ( LT !)* ':' ( LT !)* assignmentExpression )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:366:4: propertyName ( LT !)* ':' ( LT !)* assignmentExpression
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(366, 4);
			PushFollow(Follow._propertyName_in_propertyNameAndValue2481);
			propertyName440=propertyName();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, propertyName440.Tree);
			DebugLocation(366, 19);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:366:19: ( LT !)*
			try { DebugEnterSubRule(225);
			while (true)
			{
				int alt225=2;
				try { DebugEnterDecision(225, false);
				int LA225_1 = input.LA(1);

				if ((LA225_1==LT))
				{
					alt225 = 1;
				}


				} finally { DebugExitDecision(225); }
				switch ( alt225 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:366:19: LT !
					{
					DebugLocation(366, 19);
					LT441=(IToken)Match(input,LT,Follow._LT_in_propertyNameAndValue2483); if (state.failed) return retval;

					}
					break;

				default:
					goto loop225;
				}
			}

			loop225:
				;

			} finally { DebugExitSubRule(225); }

			DebugLocation(366, 22);
			char_literal442=(IToken)Match(input,53,Follow._53_in_propertyNameAndValue2487); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal442_tree = (object)adaptor.Create(char_literal442);
			adaptor.AddChild(root_0, char_literal442_tree);
			}
			DebugLocation(366, 28);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:366:28: ( LT !)*
			try { DebugEnterSubRule(226);
			while (true)
			{
				int alt226=2;
				try { DebugEnterDecision(226, false);
				int LA226_1 = input.LA(1);

				if ((LA226_1==LT))
				{
					alt226 = 1;
				}


				} finally { DebugExitDecision(226); }
				switch ( alt226 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:366:28: LT !
					{
					DebugLocation(366, 28);
					LT443=(IToken)Match(input,LT,Follow._LT_in_propertyNameAndValue2489); if (state.failed) return retval;

					}
					break;

				default:
					goto loop226;
				}
			}

			loop226:
				;

			} finally { DebugExitSubRule(226); }

			DebugLocation(366, 31);
			PushFollow(Follow._assignmentExpression_in_propertyNameAndValue2493);
			assignmentExpression444=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression444.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertyNameAndValue", 79);
			LeaveRule("propertyNameAndValue", 79);
			LeaveRule_propertyNameAndValue();
			if (state.backtracking > 0) { Memoize(input, 79, propertyNameAndValue_StartIndex); }

		}
		DebugLocation(367, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyNameAndValue"); }
		return retval;

	}
	// $ANTLR end "propertyNameAndValue"

	partial void EnterRule_propertyName();
	partial void LeaveRule_propertyName();
	// $ANTLR start "propertyName"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:369:1: propertyName : ( Identifier | StringLiteral | NumericLiteral );
	[GrammarRule("propertyName")]
	private AstParserRuleReturnScope<object, IToken> propertyName()
	{
		EnterRule_propertyName();
		EnterRule("propertyName", 80);
		TraceIn("propertyName", 80);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int propertyName_StartIndex = input.Index;

		object root_0 = default(object);

		IToken set445 = default(IToken);

		object set445_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "propertyName");
		DebugLocation(369, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 80)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:370:2: ( Identifier | StringLiteral | NumericLiteral )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(370, 2);

			set445=(IToken)input.LT(1);
			if (input.LA(1)==Identifier||input.LA(1)==NumericLiteral||input.LA(1)==StringLiteral)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set445));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertyName", 80);
			LeaveRule("propertyName", 80);
			LeaveRule_propertyName();
			if (state.backtracking > 0) { Memoize(input, 80, propertyName_StartIndex); }

		}
		DebugLocation(373, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyName"); }
		return retval;

	}
	// $ANTLR end "propertyName"

	partial void EnterRule_literal();
	partial void LeaveRule_literal();
	// $ANTLR start "literal"
	// C:\\DEVGIT\\typesharp\\TypeScript.g:376:1: literal : ( 'null' | 'true' | 'false' | StringLiteral | NumericLiteral );
	[GrammarRule("literal")]
	private AstParserRuleReturnScope<object, IToken> literal()
	{
		EnterRule_literal();
		EnterRule("literal", 81);
		TraceIn("literal", 81);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int literal_StartIndex = input.Index;

		object root_0 = default(object);

		IToken set446 = default(IToken);

		object set446_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "literal");
		DebugLocation(376, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 81)) { return retval; }

			// C:\\DEVGIT\\typesharp\\TypeScript.g:377:2: ( 'null' | 'true' | 'false' | StringLiteral | NumericLiteral )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(377, 2);

			set446=(IToken)input.LT(1);
			if (input.LA(1)==NumericLiteral||input.LA(1)==StringLiteral||input.LA(1)==81||input.LA(1)==89||input.LA(1)==94)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set446));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("literal", 81);
			LeaveRule("literal", 81);
			LeaveRule_literal();
			if (state.backtracking > 0) { Memoize(input, 81, literal_StartIndex); }

		}
		DebugLocation(382, 1);
		} finally { DebugExitRule(GrammarFileName, "literal"); }
		return retval;

	}
	// $ANTLR end "literal"

	partial void EnterRule_synpred5_TypeScript_fragment();
	partial void LeaveRule_synpred5_TypeScript_fragment();

	// $ANTLR start synpred5_TypeScript
	private void synpred5_TypeScript_fragment()
	{
		EnterRule_synpred5_TypeScript_fragment();
		EnterRule("synpred5_TypeScript_fragment", 86);
		TraceIn("synpred5_TypeScript_fragment", 86);
		try
		{
			// C:\\DEVGIT\\typesharp\\TypeScript.g:25:4: ( functionDeclaration )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:25:4: functionDeclaration
			{
			DebugLocation(25, 4);
			PushFollow(Follow._functionDeclaration_in_synpred5_TypeScript87);
			functionDeclaration();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred5_TypeScript_fragment", 86);
			LeaveRule("synpred5_TypeScript_fragment", 86);
			LeaveRule_synpred5_TypeScript_fragment();
		}
	}
	// $ANTLR end synpred5_TypeScript

	partial void EnterRule_synpred9_TypeScript_fragment();
	partial void LeaveRule_synpred9_TypeScript_fragment();

	// $ANTLR start synpred9_TypeScript
	private void synpred9_TypeScript_fragment()
	{
		EnterRule_synpred9_TypeScript_fragment();
		EnterRule("synpred9_TypeScript_fragment", 90);
		TraceIn("synpred9_TypeScript_fragment", 90);
		try
		{
			// C:\\DEVGIT\\typesharp\\TypeScript.g:35:17: ( LT )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:35:17: LT
			{
			DebugLocation(35, 15);
			Match(input,LT,Follow._LT_in_synpred9_TypeScript137); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred9_TypeScript_fragment", 90);
			LeaveRule("synpred9_TypeScript_fragment", 90);
			LeaveRule_synpred9_TypeScript_fragment();
		}
	}
	// $ANTLR end synpred9_TypeScript

	partial void EnterRule_synpred21_TypeScript_fragment();
	partial void LeaveRule_synpred21_TypeScript_fragment();

	// $ANTLR start synpred21_TypeScript
	private void synpred21_TypeScript_fragment()
	{
		EnterRule_synpred21_TypeScript_fragment();
		EnterRule("synpred21_TypeScript_fragment", 102);
		TraceIn("synpred21_TypeScript_fragment", 102);
		try
		{
			// C:\\DEVGIT\\typesharp\\TypeScript.g:48:4: ( statementBlock )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:48:4: statementBlock
			{
			DebugLocation(48, 4);
			PushFollow(Follow._statementBlock_in_synpred21_TypeScript231);
			statementBlock();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred21_TypeScript_fragment", 102);
			LeaveRule("synpred21_TypeScript_fragment", 102);
			LeaveRule_synpred21_TypeScript_fragment();
		}
	}
	// $ANTLR end synpred21_TypeScript

	partial void EnterRule_synpred24_TypeScript_fragment();
	partial void LeaveRule_synpred24_TypeScript_fragment();

	// $ANTLR start synpred24_TypeScript
	private void synpred24_TypeScript_fragment()
	{
		EnterRule_synpred24_TypeScript_fragment();
		EnterRule("synpred24_TypeScript_fragment", 105);
		TraceIn("synpred24_TypeScript_fragment", 105);
		try
		{
			// C:\\DEVGIT\\typesharp\\TypeScript.g:51:4: ( expressionStatement )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:51:4: expressionStatement
			{
			DebugLocation(51, 4);
			PushFollow(Follow._expressionStatement_in_synpred24_TypeScript246);
			expressionStatement();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred24_TypeScript_fragment", 105);
			LeaveRule("synpred24_TypeScript_fragment", 105);
			LeaveRule_synpred24_TypeScript_fragment();
		}
	}
	// $ANTLR end synpred24_TypeScript

	partial void EnterRule_synpred31_TypeScript_fragment();
	partial void LeaveRule_synpred31_TypeScript_fragment();

	// $ANTLR start synpred31_TypeScript
	private void synpred31_TypeScript_fragment()
	{
		EnterRule_synpred31_TypeScript_fragment();
		EnterRule("synpred31_TypeScript_fragment", 112);
		TraceIn("synpred31_TypeScript_fragment", 112);
		try
		{
			// C:\\DEVGIT\\typesharp\\TypeScript.g:58:4: ( labelledStatement )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:58:4: labelledStatement
			{
			DebugLocation(58, 4);
			PushFollow(Follow._labelledStatement_in_synpred31_TypeScript281);
			labelledStatement();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred31_TypeScript_fragment", 112);
			LeaveRule("synpred31_TypeScript_fragment", 112);
			LeaveRule_synpred31_TypeScript_fragment();
		}
	}
	// $ANTLR end synpred31_TypeScript

	partial void EnterRule_synpred34_TypeScript_fragment();
	partial void LeaveRule_synpred34_TypeScript_fragment();

	// $ANTLR start synpred34_TypeScript
	private void synpred34_TypeScript_fragment()
	{
		EnterRule_synpred34_TypeScript_fragment();
		EnterRule("synpred34_TypeScript_fragment", 115);
		TraceIn("synpred34_TypeScript_fragment", 115);
		try
		{
			// C:\\DEVGIT\\typesharp\\TypeScript.g:65:10: ( LT )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:65:10: LT
			{
			DebugLocation(65, 8);
			Match(input,LT,Follow._LT_in_synpred34_TypeScript310); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred34_TypeScript_fragment", 115);
			LeaveRule("synpred34_TypeScript_fragment", 115);
			LeaveRule_synpred34_TypeScript_fragment();
		}
	}
	// $ANTLR end synpred34_TypeScript

	partial void EnterRule_synpred47_TypeScript_fragment();
	partial void LeaveRule_synpred47_TypeScript_fragment();

	// $ANTLR start synpred47_TypeScript
	private void synpred47_TypeScript_fragment()
	{
		EnterRule_synpred47_TypeScript_fragment();
		EnterRule("synpred47_TypeScript_fragment", 128);
		TraceIn("synpred47_TypeScript_fragment", 128);
		try
		{
			// C:\\DEVGIT\\typesharp\\TypeScript.g:85:17: ( LT )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:85:17: LT
			{
			DebugLocation(85, 15);
			Match(input,LT,Follow._LT_in_synpred47_TypeScript437); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred47_TypeScript_fragment", 128);
			LeaveRule("synpred47_TypeScript_fragment", 128);
			LeaveRule_synpred47_TypeScript_fragment();
		}
	}
	// $ANTLR end synpred47_TypeScript

	partial void EnterRule_synpred49_TypeScript_fragment();
	partial void LeaveRule_synpred49_TypeScript_fragment();

	// $ANTLR start synpred49_TypeScript
	private void synpred49_TypeScript_fragment()
	{
		EnterRule_synpred49_TypeScript_fragment();
		EnterRule("synpred49_TypeScript_fragment", 130);
		TraceIn("synpred49_TypeScript_fragment", 130);
		try
		{
			// C:\\DEVGIT\\typesharp\\TypeScript.g:89:17: ( LT )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:89:17: LT
			{
			DebugLocation(89, 15);
			Match(input,LT,Follow._LT_in_synpred49_TypeScript456); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred49_TypeScript_fragment", 130);
			LeaveRule("synpred49_TypeScript_fragment", 130);
			LeaveRule_synpred49_TypeScript_fragment();
		}
	}
	// $ANTLR end synpred49_TypeScript

	partial void EnterRule_synpred60_TypeScript_fragment();
	partial void LeaveRule_synpred60_TypeScript_fragment();

	// $ANTLR start synpred60_TypeScript
	private void synpred60_TypeScript_fragment()
	{
		EnterRule_synpred60_TypeScript_fragment();
		EnterRule("synpred60_TypeScript_fragment", 141);
		TraceIn("synpred60_TypeScript_fragment", 141);
		try
		{
			// C:\\DEVGIT\\typesharp\\TypeScript.g:109:59: ( ( LT )* 'else' ( LT )* statement )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:109:59: ( LT )* 'else' ( LT )* statement
			{
			DebugLocation(109, 61);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:109:61: ( LT )*
			try { DebugEnterSubRule(239);
			while (true)
			{
				int alt239=2;
				try { DebugEnterDecision(239, false);
				int LA239_1 = input.LA(1);

				if ((LA239_1==LT))
				{
					alt239 = 1;
				}


				} finally { DebugExitDecision(239); }
				switch ( alt239 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:109:61: LT
					{
					DebugLocation(109, 59);
					Match(input,LT,Follow._LT_in_synpred60_TypeScript569); if (state.failed) return;

					}
					break;

				default:
					goto loop239;
				}
			}

			loop239:
				;

			} finally { DebugExitSubRule(239); }

			DebugLocation(109, 64);
			Match(input,80,Follow._80_in_synpred60_TypeScript573); if (state.failed) return;
			DebugLocation(109, 73);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:109:73: ( LT )*
			try { DebugEnterSubRule(240);
			while (true)
			{
				int alt240=2;
				try { DebugEnterDecision(240, false);
				int LA240_1 = input.LA(1);

				if ((LA240_1==LT))
				{
					alt240 = 1;
				}


				} finally { DebugExitDecision(240); }
				switch ( alt240 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:109:73: LT
					{
					DebugLocation(109, 71);
					Match(input,LT,Follow._LT_in_synpred60_TypeScript575); if (state.failed) return;

					}
					break;

				default:
					goto loop240;
				}
			}

			loop240:
				;

			} finally { DebugExitSubRule(240); }

			DebugLocation(109, 76);
			PushFollow(Follow._statement_in_synpred60_TypeScript579);
			statement();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred60_TypeScript_fragment", 141);
			LeaveRule("synpred60_TypeScript_fragment", 141);
			LeaveRule_synpred60_TypeScript_fragment();
		}
	}
	// $ANTLR end synpred60_TypeScript

	partial void EnterRule_synpred63_TypeScript_fragment();
	partial void LeaveRule_synpred63_TypeScript_fragment();

	// $ANTLR start synpred63_TypeScript
	private void synpred63_TypeScript_fragment()
	{
		EnterRule_synpred63_TypeScript_fragment();
		EnterRule("synpred63_TypeScript_fragment", 144);
		TraceIn("synpred63_TypeScript_fragment", 144);
		try
		{
			// C:\\DEVGIT\\typesharp\\TypeScript.g:115:4: ( forStatement )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:115:4: forStatement
			{
			DebugLocation(115, 4);
			PushFollow(Follow._forStatement_in_synpred63_TypeScript603);
			forStatement();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred63_TypeScript_fragment", 144);
			LeaveRule("synpred63_TypeScript_fragment", 144);
			LeaveRule_synpred63_TypeScript_fragment();
		}
	}
	// $ANTLR end synpred63_TypeScript

	partial void EnterRule_synpred118_TypeScript_fragment();
	partial void LeaveRule_synpred118_TypeScript_fragment();

	// $ANTLR start synpred118_TypeScript
	private void synpred118_TypeScript_fragment()
	{
		EnterRule_synpred118_TypeScript_fragment();
		EnterRule("synpred118_TypeScript_fragment", 199);
		TraceIn("synpred118_TypeScript_fragment", 199);
		try
		{
			// C:\\DEVGIT\\typesharp\\TypeScript.g:174:38: ( LT )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:174:38: LT
			{
			DebugLocation(174, 36);
			Match(input,LT,Follow._LT_in_synpred118_TypeScript1084); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred118_TypeScript_fragment", 199);
			LeaveRule("synpred118_TypeScript_fragment", 199);
			LeaveRule_synpred118_TypeScript_fragment();
		}
	}
	// $ANTLR end synpred118_TypeScript

	partial void EnterRule_synpred121_TypeScript_fragment();
	partial void LeaveRule_synpred121_TypeScript_fragment();

	// $ANTLR start synpred121_TypeScript
	private void synpred121_TypeScript_fragment()
	{
		EnterRule_synpred121_TypeScript_fragment();
		EnterRule("synpred121_TypeScript_fragment", 202);
		TraceIn("synpred121_TypeScript_fragment", 202);
		try
		{
			// C:\\DEVGIT\\typesharp\\TypeScript.g:178:25: ( LT )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:178:25: LT
			{
			DebugLocation(178, 23);
			Match(input,LT,Follow._LT_in_synpred121_TypeScript1109); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred121_TypeScript_fragment", 202);
			LeaveRule("synpred121_TypeScript_fragment", 202);
			LeaveRule_synpred121_TypeScript_fragment();
		}
	}
	// $ANTLR end synpred121_TypeScript

	partial void EnterRule_synpred140_TypeScript_fragment();
	partial void LeaveRule_synpred140_TypeScript_fragment();

	// $ANTLR start synpred140_TypeScript
	private void synpred140_TypeScript_fragment()
	{
		EnterRule_synpred140_TypeScript_fragment();
		EnterRule("synpred140_TypeScript_fragment", 221);
		TraceIn("synpred140_TypeScript_fragment", 221);
		try
		{
			// C:\\DEVGIT\\typesharp\\TypeScript.g:207:4: ( conditionalExpression )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:207:4: conditionalExpression
			{
			DebugLocation(207, 4);
			PushFollow(Follow._conditionalExpression_in_synpred140_TypeScript1301);
			conditionalExpression();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred140_TypeScript_fragment", 221);
			LeaveRule("synpred140_TypeScript_fragment", 221);
			LeaveRule_synpred140_TypeScript_fragment();
		}
	}
	// $ANTLR end synpred140_TypeScript

	partial void EnterRule_synpred143_TypeScript_fragment();
	partial void LeaveRule_synpred143_TypeScript_fragment();

	// $ANTLR start synpred143_TypeScript
	private void synpred143_TypeScript_fragment()
	{
		EnterRule_synpred143_TypeScript_fragment();
		EnterRule("synpred143_TypeScript_fragment", 224);
		TraceIn("synpred143_TypeScript_fragment", 224);
		try
		{
			// C:\\DEVGIT\\typesharp\\TypeScript.g:212:4: ( conditionalExpressionNoIn )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:212:4: conditionalExpressionNoIn
			{
			DebugLocation(212, 4);
			PushFollow(Follow._conditionalExpressionNoIn_in_synpred143_TypeScript1330);
			conditionalExpressionNoIn();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred143_TypeScript_fragment", 224);
			LeaveRule("synpred143_TypeScript_fragment", 224);
			LeaveRule_synpred143_TypeScript_fragment();
		}
	}
	// $ANTLR end synpred143_TypeScript

	partial void EnterRule_synpred146_TypeScript_fragment();
	partial void LeaveRule_synpred146_TypeScript_fragment();

	// $ANTLR start synpred146_TypeScript
	private void synpred146_TypeScript_fragment()
	{
		EnterRule_synpred146_TypeScript_fragment();
		EnterRule("synpred146_TypeScript_fragment", 227);
		TraceIn("synpred146_TypeScript_fragment", 227);
		try
		{
			// C:\\DEVGIT\\typesharp\\TypeScript.g:217:4: ( callExpression )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:217:4: callExpression
			{
			DebugLocation(217, 4);
			PushFollow(Follow._callExpression_in_synpred146_TypeScript1359);
			callExpression();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred146_TypeScript_fragment", 227);
			LeaveRule("synpred146_TypeScript_fragment", 227);
			LeaveRule_synpred146_TypeScript_fragment();
		}
	}
	// $ANTLR end synpred146_TypeScript

	partial void EnterRule_synpred147_TypeScript_fragment();
	partial void LeaveRule_synpred147_TypeScript_fragment();

	// $ANTLR start synpred147_TypeScript
	private void synpred147_TypeScript_fragment()
	{
		EnterRule_synpred147_TypeScript_fragment();
		EnterRule("synpred147_TypeScript_fragment", 228);
		TraceIn("synpred147_TypeScript_fragment", 228);
		try
		{
			// C:\\DEVGIT\\typesharp\\TypeScript.g:222:4: ( memberExpression )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:222:4: memberExpression
			{
			DebugLocation(222, 4);
			PushFollow(Follow._memberExpression_in_synpred147_TypeScript1376);
			memberExpression();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred147_TypeScript_fragment", 228);
			LeaveRule("synpred147_TypeScript_fragment", 228);
			LeaveRule_synpred147_TypeScript_fragment();
		}
	}
	// $ANTLR end synpred147_TypeScript

	partial void EnterRule_synpred154_TypeScript_fragment();
	partial void LeaveRule_synpred154_TypeScript_fragment();

	// $ANTLR start synpred154_TypeScript
	private void synpred154_TypeScript_fragment()
	{
		EnterRule_synpred154_TypeScript_fragment();
		EnterRule("synpred154_TypeScript_fragment", 235);
		TraceIn("synpred154_TypeScript_fragment", 235);
		try
		{
			// C:\\DEVGIT\\typesharp\\TypeScript.g:227:91: ( ( LT )* memberExpressionSuffix )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:227:91: ( LT )* memberExpressionSuffix
			{
			DebugLocation(227, 93);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:227:93: ( LT )*
			try { DebugEnterSubRule(254);
			while (true)
			{
				int alt254=2;
				try { DebugEnterDecision(254, false);
				int LA254_1 = input.LA(1);

				if ((LA254_1==LT))
				{
					alt254 = 1;
				}


				} finally { DebugExitDecision(254); }
				switch ( alt254 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:227:93: LT
					{
					DebugLocation(227, 91);
					Match(input,LT,Follow._LT_in_synpred154_TypeScript1424); if (state.failed) return;

					}
					break;

				default:
					goto loop254;
				}
			}

			loop254:
				;

			} finally { DebugExitSubRule(254); }

			DebugLocation(227, 96);
			PushFollow(Follow._memberExpressionSuffix_in_synpred154_TypeScript1428);
			memberExpressionSuffix();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred154_TypeScript_fragment", 235);
			LeaveRule("synpred154_TypeScript_fragment", 235);
			LeaveRule_synpred154_TypeScript_fragment();
		}
	}
	// $ANTLR end synpred154_TypeScript

	partial void EnterRule_synpred158_TypeScript_fragment();
	partial void LeaveRule_synpred158_TypeScript_fragment();

	// $ANTLR start synpred158_TypeScript
	private void synpred158_TypeScript_fragment()
	{
		EnterRule_synpred158_TypeScript_fragment();
		EnterRule("synpred158_TypeScript_fragment", 239);
		TraceIn("synpred158_TypeScript_fragment", 239);
		try
		{
			// C:\\DEVGIT\\typesharp\\TypeScript.g:236:37: ( ( LT )* callExpressionSuffix )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:236:37: ( LT )* callExpressionSuffix
			{
			DebugLocation(236, 39);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:236:39: ( LT )*
			try { DebugEnterSubRule(255);
			while (true)
			{
				int alt255=2;
				try { DebugEnterDecision(255, false);
				int LA255_1 = input.LA(1);

				if ((LA255_1==LT))
				{
					alt255 = 1;
				}


				} finally { DebugExitDecision(255); }
				switch ( alt255 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:236:39: LT
					{
					DebugLocation(236, 37);
					Match(input,LT,Follow._LT_in_synpred158_TypeScript1467); if (state.failed) return;

					}
					break;

				default:
					goto loop255;
				}
			}

			loop255:
				;

			} finally { DebugExitSubRule(255); }

			DebugLocation(236, 42);
			PushFollow(Follow._callExpressionSuffix_in_synpred158_TypeScript1471);
			callExpressionSuffix();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred158_TypeScript_fragment", 239);
			LeaveRule("synpred158_TypeScript_fragment", 239);
			LeaveRule_synpred158_TypeScript_fragment();
		}
	}
	// $ANTLR end synpred158_TypeScript

	partial void EnterRule_synpred256_TypeScript_fragment();
	partial void LeaveRule_synpred256_TypeScript_fragment();

	// $ANTLR start synpred256_TypeScript
	private void synpred256_TypeScript_fragment()
	{
		EnterRule_synpred256_TypeScript_fragment();
		EnterRule("synpred256_TypeScript_fragment", 337);
		TraceIn("synpred256_TypeScript_fragment", 337);
		try
		{
			// C:\\DEVGIT\\typesharp\\TypeScript.g:330:30: ( ( LT )* ( '+' | '-' ) ( LT )* multiplicativeExpression )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:330:30: ( LT )* ( '+' | '-' ) ( LT )* multiplicativeExpression
			{
			DebugLocation(330, 32);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:330:32: ( LT )*
			try { DebugEnterSubRule(300);
			while (true)
			{
				int alt300=2;
				try { DebugEnterDecision(300, false);
				int LA300_1 = input.LA(1);

				if ((LA300_1==LT))
				{
					alt300 = 1;
				}


				} finally { DebugExitDecision(300); }
				switch ( alt300 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:330:32: LT
					{
					DebugLocation(330, 30);
					Match(input,LT,Follow._LT_in_synpred256_TypeScript2204); if (state.failed) return;

					}
					break;

				default:
					goto loop300;
				}
			}

			loop300:
				;

			} finally { DebugExitSubRule(300); }

			DebugLocation(330, 35);
			if (input.LA(1)==43||input.LA(1)==47)
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}

			DebugLocation(330, 49);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:330:49: ( LT )*
			try { DebugEnterSubRule(301);
			while (true)
			{
				int alt301=2;
				try { DebugEnterDecision(301, false);
				int LA301_1 = input.LA(1);

				if ((LA301_1==LT))
				{
					alt301 = 1;
				}


				} finally { DebugExitDecision(301); }
				switch ( alt301 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\DEVGIT\\typesharp\\TypeScript.g:330:49: LT
					{
					DebugLocation(330, 47);
					Match(input,LT,Follow._LT_in_synpred256_TypeScript2216); if (state.failed) return;

					}
					break;

				default:
					goto loop301;
				}
			}

			loop301:
				;

			} finally { DebugExitSubRule(301); }

			DebugLocation(330, 52);
			PushFollow(Follow._multiplicativeExpression_in_synpred256_TypeScript2220);
			multiplicativeExpression();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred256_TypeScript_fragment", 337);
			LeaveRule("synpred256_TypeScript_fragment", 337);
			LeaveRule_synpred256_TypeScript_fragment();
		}
	}
	// $ANTLR end synpred256_TypeScript

	partial void EnterRule_synpred280_TypeScript_fragment();
	partial void LeaveRule_synpred280_TypeScript_fragment();

	// $ANTLR start synpred280_TypeScript
	private void synpred280_TypeScript_fragment()
	{
		EnterRule_synpred280_TypeScript_fragment();
		EnterRule("synpred280_TypeScript_fragment", 361);
		TraceIn("synpred280_TypeScript_fragment", 361);
		try
		{
			// C:\\DEVGIT\\typesharp\\TypeScript.g:357:10: ( LT )
			DebugEnterAlt(1);
			// C:\\DEVGIT\\typesharp\\TypeScript.g:357:10: LT
			{
			DebugLocation(357, 8);
			Match(input,LT,Follow._LT_in_synpred280_TypeScript2394); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred280_TypeScript_fragment", 361);
			LeaveRule("synpred280_TypeScript_fragment", 361);
			LeaveRule_synpred280_TypeScript_fragment();
		}
	}
	// $ANTLR end synpred280_TypeScript
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	private DFA4 dfa4;
	private DFA17 dfa17;
	private DFA16 dfa16;
	private DFA26 dfa26;
	private DFA30 dfa30;
	private DFA33 dfa33;
	private DFA57 dfa57;
	private DFA60 dfa60;
	private DFA63 dfa63;
	private DFA90 dfa90;
	private DFA94 dfa94;
	private DFA93 dfa93;
	private DFA106 dfa106;
	private DFA115 dfa115;
	private DFA118 dfa118;
	private DFA142 dfa142;
	private DFA141 dfa141;
	private DFA151 dfa151;
	private DFA156 dfa156;
	private DFA159 dfa159;
	private DFA162 dfa162;
	private DFA165 dfa165;
	private DFA168 dfa168;
	private DFA171 dfa171;
	private DFA174 dfa174;
	private DFA177 dfa177;
	private DFA180 dfa180;
	private DFA183 dfa183;
	private DFA186 dfa186;
	private DFA189 dfa189;
	private DFA192 dfa192;
	private DFA195 dfa195;
	private DFA198 dfa198;
	private DFA201 dfa201;
	private DFA207 dfa207;
	private DFA218 dfa218;
	private DFA217 dfa217;
	private DFA223 dfa223;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa4 = new DFA4( this );
		dfa17 = new DFA17( this );
		dfa16 = new DFA16( this );
		dfa26 = new DFA26( this );
		dfa30 = new DFA30( this );
		dfa33 = new DFA33( this );
		dfa57 = new DFA57( this );
		dfa60 = new DFA60( this );
		dfa63 = new DFA63( this );
		dfa90 = new DFA90( this );
		dfa94 = new DFA94( this );
		dfa93 = new DFA93( this );
		dfa106 = new DFA106( this );
		dfa115 = new DFA115( this );
		dfa118 = new DFA118( this );
		dfa142 = new DFA142( this );
		dfa141 = new DFA141( this );
		dfa151 = new DFA151( this );
		dfa156 = new DFA156( this );
		dfa159 = new DFA159( this );
		dfa162 = new DFA162( this );
		dfa165 = new DFA165( this );
		dfa168 = new DFA168( this );
		dfa171 = new DFA171( this );
		dfa174 = new DFA174( this );
		dfa177 = new DFA177( this );
		dfa180 = new DFA180( this );
		dfa183 = new DFA183( this );
		dfa186 = new DFA186( this );
		dfa189 = new DFA189( this );
		dfa192 = new DFA192( this );
		dfa195 = new DFA195( this );
		dfa198 = new DFA198( this );
		dfa201 = new DFA201( this );
		dfa207 = new DFA207( this );
		dfa218 = new DFA218( this );
		dfa217 = new DFA217( this );
		dfa223 = new DFA223( this );
	}

	private class DFA4 : DFA
	{
		private const string DFA4_eotS =
			"\4\uffff";
		private const string DFA4_eofS =
			"\2\2\2\uffff";
		private const string DFA4_minS =
			"\2\17\2\uffff";
		private const string DFA4_maxS =
			"\2\152\2\uffff";
		private const string DFA4_acceptS =
			"\2\uffff\1\2\1\1";
		private const string DFA4_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA4_transitionS =
			{
				"\1\3\2\uffff\1\1\2\uffff\1\3\2\uffff\1\3\6\uffff\1\3\7\uffff\1\3\3\uffff"+
				"\2\3\2\uffff\2\3\5\uffff\1\3\16\uffff\1\3\3\uffff\1\3\2\uffff\1\3\1"+
				"\uffff\2\3\1\uffff\1\3\1\uffff\3\3\2\uffff\16\3\3\uffff\1\2\1\3",
				"\1\3\2\uffff\1\1\2\uffff\1\3\2\uffff\1\3\6\uffff\1\3\7\uffff\1\3\3"+
				"\uffff\2\3\2\uffff\2\3\5\uffff\1\3\16\uffff\1\3\3\uffff\1\3\2\uffff"+
				"\1\3\1\uffff\2\3\1\uffff\1\3\1\uffff\3\3\2\uffff\16\3\3\uffff\1\2\1"+
				"\3",
				"",
				""
			};

		private static readonly short[] DFA4_eot = DFA.UnpackEncodedString(DFA4_eotS);
		private static readonly short[] DFA4_eof = DFA.UnpackEncodedString(DFA4_eofS);
		private static readonly char[] DFA4_min = DFA.UnpackEncodedStringToUnsignedChars(DFA4_minS);
		private static readonly char[] DFA4_max = DFA.UnpackEncodedStringToUnsignedChars(DFA4_maxS);
		private static readonly short[] DFA4_accept = DFA.UnpackEncodedString(DFA4_acceptS);
		private static readonly short[] DFA4_special = DFA.UnpackEncodedString(DFA4_specialS);
		private static readonly short[][] DFA4_transition;

		static DFA4()
		{
			int numStates = DFA4_transitionS.Length;
			DFA4_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA4_transition[i] = DFA.UnpackEncodedString(DFA4_transitionS[i]);
			}
		}

		public DFA4( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 4;
			this.eot = DFA4_eot;
			this.eof = DFA4_eof;
			this.min = DFA4_min;
			this.max = DFA4_max;
			this.accept = DFA4_accept;
			this.special = DFA4_special;
			this.transition = DFA4_transition;
		}

		public override string Description { get { return "()* loopback of 21:18: ( ( LT !)* sourceElement )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA17 : DFA
	{
		private const string DFA17_eotS =
			"\4\uffff";
		private const string DFA17_eofS =
			"\4\uffff";
		private const string DFA17_minS =
			"\2\17\2\uffff";
		private const string DFA17_maxS =
			"\2\50\2\uffff";
		private const string DFA17_acceptS =
			"\2\uffff\1\1\1\2";
		private const string DFA17_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA17_transitionS =
			{
				"\1\2\2\uffff\1\1\25\uffff\1\3",
				"\1\2\2\uffff\1\1\25\uffff\1\3",
				"",
				""
			};

		private static readonly short[] DFA17_eot = DFA.UnpackEncodedString(DFA17_eotS);
		private static readonly short[] DFA17_eof = DFA.UnpackEncodedString(DFA17_eofS);
		private static readonly char[] DFA17_min = DFA.UnpackEncodedStringToUnsignedChars(DFA17_minS);
		private static readonly char[] DFA17_max = DFA.UnpackEncodedStringToUnsignedChars(DFA17_maxS);
		private static readonly short[] DFA17_accept = DFA.UnpackEncodedString(DFA17_acceptS);
		private static readonly short[] DFA17_special = DFA.UnpackEncodedString(DFA17_specialS);
		private static readonly short[][] DFA17_transition;

		static DFA17()
		{
			int numStates = DFA17_transitionS.Length;
			DFA17_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA17_transition[i] = DFA.UnpackEncodedString(DFA17_transitionS[i]);
			}
		}

		public DFA17( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 17;
			this.eot = DFA17_eot;
			this.eof = DFA17_eof;
			this.min = DFA17_min;
			this.max = DFA17_max;
			this.accept = DFA17_accept;
			this.special = DFA17_special;
			this.transition = DFA17_transition;
		}

		public override string Description { get { return "39:8: ( ( LT !)* Identifier ( ( LT !)* ',' ( LT !)* Identifier )* )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA16 : DFA
	{
		private const string DFA16_eotS =
			"\4\uffff";
		private const string DFA16_eofS =
			"\4\uffff";
		private const string DFA16_minS =
			"\2\22\2\uffff";
		private const string DFA16_maxS =
			"\2\56\2\uffff";
		private const string DFA16_acceptS =
			"\2\uffff\1\2\1\1";
		private const string DFA16_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA16_transitionS =
			{
				"\1\1\25\uffff\1\2\5\uffff\1\3",
				"\1\1\25\uffff\1\2\5\uffff\1\3",
				"",
				""
			};

		private static readonly short[] DFA16_eot = DFA.UnpackEncodedString(DFA16_eotS);
		private static readonly short[] DFA16_eof = DFA.UnpackEncodedString(DFA16_eofS);
		private static readonly char[] DFA16_min = DFA.UnpackEncodedStringToUnsignedChars(DFA16_minS);
		private static readonly char[] DFA16_max = DFA.UnpackEncodedStringToUnsignedChars(DFA16_maxS);
		private static readonly short[] DFA16_accept = DFA.UnpackEncodedString(DFA16_acceptS);
		private static readonly short[] DFA16_special = DFA.UnpackEncodedString(DFA16_specialS);
		private static readonly short[][] DFA16_transition;

		static DFA16()
		{
			int numStates = DFA16_transitionS.Length;
			DFA16_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA16_transition[i] = DFA.UnpackEncodedString(DFA16_transitionS[i]);
			}
		}

		public DFA16( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 16;
			this.eot = DFA16_eot;
			this.eof = DFA16_eof;
			this.min = DFA16_min;
			this.max = DFA16_max;
			this.accept = DFA16_accept;
			this.special = DFA16_special;
			this.transition = DFA16_transition;
		}

		public override string Description { get { return "()* loopback of 39:25: ( ( LT !)* ',' ( LT !)* Identifier )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA26 : DFA
	{
		private const string DFA26_eotS =
			"\4\uffff";
		private const string DFA26_eofS =
			"\1\2\3\uffff";
		private const string DFA26_minS =
			"\2\17\2\uffff";
		private const string DFA26_maxS =
			"\2\152\2\uffff";
		private const string DFA26_acceptS =
			"\2\uffff\1\2\1\1";
		private const string DFA26_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA26_transitionS =
			{
				"\1\3\2\uffff\1\1\2\uffff\1\3\2\uffff\1\3\6\uffff\1\3\7\uffff\1\3\3\uffff"+
				"\2\3\2\uffff\2\3\5\uffff\1\3\16\uffff\1\3\3\uffff\1\3\1\2\1\uffff\1"+
				"\3\1\2\2\3\1\uffff\1\3\1\uffff\3\3\2\uffff\16\3\3\uffff\1\2\1\3",
				"\1\3\2\uffff\1\1\2\uffff\1\3\2\uffff\1\3\6\uffff\1\3\7\uffff\1\3\3"+
				"\uffff\2\3\2\uffff\2\3\5\uffff\1\3\16\uffff\1\3\3\uffff\1\3\1\2\1\uffff"+
				"\1\3\1\2\2\3\1\uffff\1\3\1\uffff\3\3\2\uffff\16\3\3\uffff\1\2\1\3",
				"",
				""
			};

		private static readonly short[] DFA26_eot = DFA.UnpackEncodedString(DFA26_eotS);
		private static readonly short[] DFA26_eof = DFA.UnpackEncodedString(DFA26_eofS);
		private static readonly char[] DFA26_min = DFA.UnpackEncodedStringToUnsignedChars(DFA26_minS);
		private static readonly char[] DFA26_max = DFA.UnpackEncodedStringToUnsignedChars(DFA26_maxS);
		private static readonly short[] DFA26_accept = DFA.UnpackEncodedString(DFA26_acceptS);
		private static readonly short[] DFA26_special = DFA.UnpackEncodedString(DFA26_specialS);
		private static readonly short[][] DFA26_transition;

		static DFA26()
		{
			int numStates = DFA26_transitionS.Length;
			DFA26_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA26_transition[i] = DFA.UnpackEncodedString(DFA26_transitionS[i]);
			}
		}

		public DFA26( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 26;
			this.eot = DFA26_eot;
			this.eof = DFA26_eof;
			this.min = DFA26_min;
			this.max = DFA26_max;
			this.accept = DFA26_accept;
			this.special = DFA26_special;
			this.transition = DFA26_transition;
		}

		public override string Description { get { return "()* loopback of 69:14: ( ( LT !)* statement )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA30 : DFA
	{
		private const string DFA30_eotS =
			"\5\uffff";
		private const string DFA30_eofS =
			"\1\uffff\1\2\2\uffff\1\2";
		private const string DFA30_minS =
			"\1\22\1\17\2\uffff\1\17";
		private const string DFA30_maxS =
			"\1\66\1\152\2\uffff\1\152";
		private const string DFA30_acceptS =
			"\2\uffff\1\2\1\1\1\uffff";
		private const string DFA30_specialS =
			"\5\uffff}>";
		private static readonly string[] DFA30_transitionS =
			{
				"\1\1\33\uffff\1\3\7\uffff\1\2",
				"\1\2\2\uffff\1\4\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\7\uffff\1\2\3"+
				"\uffff\2\2\1\uffff\1\3\2\2\5\uffff\1\2\16\uffff\1\2\3\uffff\2\2\1\uffff"+
				"\6\2\1\uffff\3\2\2\uffff\16\2\3\uffff\2\2",
				"",
				"",
				"\1\2\2\uffff\1\4\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\7\uffff\1\2\3"+
				"\uffff\2\2\1\uffff\1\3\2\2\5\uffff\1\2\16\uffff\1\2\3\uffff\2\2\1\uffff"+
				"\6\2\1\uffff\3\2\2\uffff\16\2\3\uffff\2\2"
			};

		private static readonly short[] DFA30_eot = DFA.UnpackEncodedString(DFA30_eotS);
		private static readonly short[] DFA30_eof = DFA.UnpackEncodedString(DFA30_eofS);
		private static readonly char[] DFA30_min = DFA.UnpackEncodedStringToUnsignedChars(DFA30_minS);
		private static readonly char[] DFA30_max = DFA.UnpackEncodedStringToUnsignedChars(DFA30_maxS);
		private static readonly short[] DFA30_accept = DFA.UnpackEncodedString(DFA30_acceptS);
		private static readonly short[] DFA30_special = DFA.UnpackEncodedString(DFA30_specialS);
		private static readonly short[][] DFA30_transition;

		static DFA30()
		{
			int numStates = DFA30_transitionS.Length;
			DFA30_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA30_transition[i] = DFA.UnpackEncodedString(DFA30_transitionS[i]);
			}
		}

		public DFA30( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 30;
			this.eot = DFA30_eot;
			this.eof = DFA30_eof;
			this.min = DFA30_min;
			this.max = DFA30_max;
			this.accept = DFA30_accept;
			this.special = DFA30_special;
			this.transition = DFA30_transition;
		}

		public override string Description { get { return "()* loopback of 77:24: ( ( LT !)* ',' ( LT !)* variableDeclaration )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA33 : DFA
	{
		private const string DFA33_eotS =
			"\4\uffff";
		private const string DFA33_eofS =
			"\1\2\3\uffff";
		private const string DFA33_minS =
			"\2\22\2\uffff";
		private const string DFA33_maxS =
			"\2\66\2\uffff";
		private const string DFA33_acceptS =
			"\2\uffff\1\2\1\1";
		private const string DFA33_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA33_transitionS =
			{
				"\1\1\33\uffff\1\3\7\uffff\1\2",
				"\1\1\33\uffff\1\3\7\uffff\1\2",
				"",
				""
			};

		private static readonly short[] DFA33_eot = DFA.UnpackEncodedString(DFA33_eotS);
		private static readonly short[] DFA33_eof = DFA.UnpackEncodedString(DFA33_eofS);
		private static readonly char[] DFA33_min = DFA.UnpackEncodedStringToUnsignedChars(DFA33_minS);
		private static readonly char[] DFA33_max = DFA.UnpackEncodedStringToUnsignedChars(DFA33_maxS);
		private static readonly short[] DFA33_accept = DFA.UnpackEncodedString(DFA33_acceptS);
		private static readonly short[] DFA33_special = DFA.UnpackEncodedString(DFA33_specialS);
		private static readonly short[][] DFA33_transition;

		static DFA33()
		{
			int numStates = DFA33_transitionS.Length;
			DFA33_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA33_transition[i] = DFA.UnpackEncodedString(DFA33_transitionS[i]);
			}
		}

		public DFA33( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 33;
			this.eot = DFA33_eot;
			this.eof = DFA33_eof;
			this.min = DFA33_min;
			this.max = DFA33_max;
			this.accept = DFA33_accept;
			this.special = DFA33_special;
			this.transition = DFA33_transition;
		}

		public override string Description { get { return "()* loopback of 81:28: ( ( LT !)* ',' ( LT !)* variableDeclarationNoIn )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA57 : DFA
	{
		private const string DFA57_eotS =
			"\4\uffff";
		private const string DFA57_eofS =
			"\4\uffff";
		private const string DFA57_minS =
			"\2\17\2\uffff";
		private const string DFA57_maxS =
			"\2\152\2\uffff";
		private const string DFA57_acceptS =
			"\2\uffff\1\1\1\2";
		private const string DFA57_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA57_transitionS =
			{
				"\1\2\2\uffff\1\1\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\7\uffff\1\2\3\uffff"+
				"\2\2\2\uffff\2\2\5\uffff\1\3\16\uffff\1\2\10\uffff\1\2\2\uffff\1\2\2"+
				"\uffff\1\2\3\uffff\2\2\2\uffff\1\2\1\uffff\1\2\1\uffff\3\2\2\uffff\1"+
				"\2\4\uffff\1\2",
				"\1\2\2\uffff\1\1\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\7\uffff\1\2\3"+
				"\uffff\2\2\2\uffff\2\2\5\uffff\1\3\16\uffff\1\2\10\uffff\1\2\2\uffff"+
				"\1\2\2\uffff\1\2\3\uffff\2\2\2\uffff\1\2\1\uffff\1\2\1\uffff\3\2\2\uffff"+
				"\1\2\4\uffff\1\2",
				"",
				""
			};

		private static readonly short[] DFA57_eot = DFA.UnpackEncodedString(DFA57_eotS);
		private static readonly short[] DFA57_eof = DFA.UnpackEncodedString(DFA57_eofS);
		private static readonly char[] DFA57_min = DFA.UnpackEncodedStringToUnsignedChars(DFA57_minS);
		private static readonly char[] DFA57_max = DFA.UnpackEncodedStringToUnsignedChars(DFA57_maxS);
		private static readonly short[] DFA57_accept = DFA.UnpackEncodedString(DFA57_acceptS);
		private static readonly short[] DFA57_special = DFA.UnpackEncodedString(DFA57_specialS);
		private static readonly short[][] DFA57_transition;

		static DFA57()
		{
			int numStates = DFA57_transitionS.Length;
			DFA57_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA57_transition[i] = DFA.UnpackEncodedString(DFA57_transitionS[i]);
			}
		}

		public DFA57( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 57;
			this.eot = DFA57_eot;
			this.eof = DFA57_eof;
			this.min = DFA57_min;
			this.max = DFA57_max;
			this.accept = DFA57_accept;
			this.special = DFA57_special;
			this.transition = DFA57_transition;
		}

		public override string Description { get { return "128:19: ( ( LT !)* forStatementInitialiserPart )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA60 : DFA
	{
		private const string DFA60_eotS =
			"\4\uffff";
		private const string DFA60_eofS =
			"\4\uffff";
		private const string DFA60_minS =
			"\2\17\2\uffff";
		private const string DFA60_maxS =
			"\2\152\2\uffff";
		private const string DFA60_acceptS =
			"\2\uffff\1\1\1\2";
		private const string DFA60_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA60_transitionS =
			{
				"\1\2\2\uffff\1\1\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\7\uffff\1\2\3\uffff"+
				"\2\2\2\uffff\2\2\5\uffff\1\3\16\uffff\1\2\10\uffff\1\2\2\uffff\1\2\2"+
				"\uffff\1\2\3\uffff\2\2\2\uffff\1\2\1\uffff\1\2\1\uffff\1\2\1\uffff\1"+
				"\2\2\uffff\1\2\4\uffff\1\2",
				"\1\2\2\uffff\1\1\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\7\uffff\1\2\3"+
				"\uffff\2\2\2\uffff\2\2\5\uffff\1\3\16\uffff\1\2\10\uffff\1\2\2\uffff"+
				"\1\2\2\uffff\1\2\3\uffff\2\2\2\uffff\1\2\1\uffff\1\2\1\uffff\1\2\1\uffff"+
				"\1\2\2\uffff\1\2\4\uffff\1\2",
				"",
				""
			};

		private static readonly short[] DFA60_eot = DFA.UnpackEncodedString(DFA60_eotS);
		private static readonly short[] DFA60_eof = DFA.UnpackEncodedString(DFA60_eofS);
		private static readonly char[] DFA60_min = DFA.UnpackEncodedStringToUnsignedChars(DFA60_minS);
		private static readonly char[] DFA60_max = DFA.UnpackEncodedStringToUnsignedChars(DFA60_maxS);
		private static readonly short[] DFA60_accept = DFA.UnpackEncodedString(DFA60_acceptS);
		private static readonly short[] DFA60_special = DFA.UnpackEncodedString(DFA60_specialS);
		private static readonly short[][] DFA60_transition;

		static DFA60()
		{
			int numStates = DFA60_transitionS.Length;
			DFA60_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA60_transition[i] = DFA.UnpackEncodedString(DFA60_transitionS[i]);
			}
		}

		public DFA60( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 60;
			this.eot = DFA60_eot;
			this.eof = DFA60_eof;
			this.min = DFA60_min;
			this.max = DFA60_max;
			this.accept = DFA60_accept;
			this.special = DFA60_special;
			this.transition = DFA60_transition;
		}

		public override string Description { get { return "128:64: ( ( LT !)* expression )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA63 : DFA
	{
		private const string DFA63_eotS =
			"\4\uffff";
		private const string DFA63_eofS =
			"\4\uffff";
		private const string DFA63_minS =
			"\2\17\2\uffff";
		private const string DFA63_maxS =
			"\2\152\2\uffff";
		private const string DFA63_acceptS =
			"\2\uffff\1\1\1\2";
		private const string DFA63_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA63_transitionS =
			{
				"\1\2\2\uffff\1\1\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\7\uffff\1\2\1\3"+
				"\2\uffff\2\2\2\uffff\2\2\24\uffff\1\2\10\uffff\1\2\2\uffff\1\2\2\uffff"+
				"\1\2\3\uffff\2\2\2\uffff\1\2\1\uffff\1\2\1\uffff\1\2\1\uffff\1\2\2\uffff"+
				"\1\2\4\uffff\1\2",
				"\1\2\2\uffff\1\1\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\7\uffff\1\2\1"+
				"\3\2\uffff\2\2\2\uffff\2\2\24\uffff\1\2\10\uffff\1\2\2\uffff\1\2\2\uffff"+
				"\1\2\3\uffff\2\2\2\uffff\1\2\1\uffff\1\2\1\uffff\1\2\1\uffff\1\2\2\uffff"+
				"\1\2\4\uffff\1\2",
				"",
				""
			};

		private static readonly short[] DFA63_eot = DFA.UnpackEncodedString(DFA63_eotS);
		private static readonly short[] DFA63_eof = DFA.UnpackEncodedString(DFA63_eofS);
		private static readonly char[] DFA63_min = DFA.UnpackEncodedStringToUnsignedChars(DFA63_minS);
		private static readonly char[] DFA63_max = DFA.UnpackEncodedStringToUnsignedChars(DFA63_maxS);
		private static readonly short[] DFA63_accept = DFA.UnpackEncodedString(DFA63_acceptS);
		private static readonly short[] DFA63_special = DFA.UnpackEncodedString(DFA63_specialS);
		private static readonly short[][] DFA63_transition;

		static DFA63()
		{
			int numStates = DFA63_transitionS.Length;
			DFA63_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA63_transition[i] = DFA.UnpackEncodedString(DFA63_transitionS[i]);
			}
		}

		public DFA63( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 63;
			this.eot = DFA63_eot;
			this.eof = DFA63_eof;
			this.min = DFA63_min;
			this.max = DFA63_max;
			this.accept = DFA63_accept;
			this.special = DFA63_special;
			this.transition = DFA63_transition;
		}

		public override string Description { get { return "128:92: ( ( LT !)* expression )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA90 : DFA
	{
		private const string DFA90_eotS =
			"\4\uffff";
		private const string DFA90_eofS =
			"\4\uffff";
		private const string DFA90_minS =
			"\2\22\2\uffff";
		private const string DFA90_maxS =
			"\2\151\2\uffff";
		private const string DFA90_acceptS =
			"\2\uffff\1\2\1\1";
		private const string DFA90_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA90_transitionS =
			{
				"\1\1\67\uffff\1\3\2\uffff\1\2\33\uffff\1\2",
				"\1\1\67\uffff\1\3\2\uffff\1\2\33\uffff\1\2",
				"",
				""
			};

		private static readonly short[] DFA90_eot = DFA.UnpackEncodedString(DFA90_eotS);
		private static readonly short[] DFA90_eof = DFA.UnpackEncodedString(DFA90_eofS);
		private static readonly char[] DFA90_min = DFA.UnpackEncodedStringToUnsignedChars(DFA90_minS);
		private static readonly char[] DFA90_max = DFA.UnpackEncodedStringToUnsignedChars(DFA90_maxS);
		private static readonly short[] DFA90_accept = DFA.UnpackEncodedString(DFA90_acceptS);
		private static readonly short[] DFA90_special = DFA.UnpackEncodedString(DFA90_specialS);
		private static readonly short[][] DFA90_transition;

		static DFA90()
		{
			int numStates = DFA90_transitionS.Length;
			DFA90_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA90_transition[i] = DFA.UnpackEncodedString(DFA90_transitionS[i]);
			}
		}

		public DFA90( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 90;
			this.eot = DFA90_eot;
			this.eof = DFA90_eof;
			this.min = DFA90_min;
			this.max = DFA90_max;
			this.accept = DFA90_accept;
			this.special = DFA90_special;
			this.transition = DFA90_transition;
		}

		public override string Description { get { return "()* loopback of 170:8: ( ( LT !)* caseClause )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA94 : DFA
	{
		private const string DFA94_eotS =
			"\4\uffff";
		private const string DFA94_eofS =
			"\4\uffff";
		private const string DFA94_minS =
			"\2\22\2\uffff";
		private const string DFA94_maxS =
			"\2\151\2\uffff";
		private const string DFA94_acceptS =
			"\2\uffff\1\1\1\2";
		private const string DFA94_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA94_transitionS =
			{
				"\1\1\72\uffff\1\2\33\uffff\1\3",
				"\1\1\72\uffff\1\2\33\uffff\1\3",
				"",
				""
			};

		private static readonly short[] DFA94_eot = DFA.UnpackEncodedString(DFA94_eotS);
		private static readonly short[] DFA94_eof = DFA.UnpackEncodedString(DFA94_eofS);
		private static readonly char[] DFA94_min = DFA.UnpackEncodedStringToUnsignedChars(DFA94_minS);
		private static readonly char[] DFA94_max = DFA.UnpackEncodedStringToUnsignedChars(DFA94_maxS);
		private static readonly short[] DFA94_accept = DFA.UnpackEncodedString(DFA94_acceptS);
		private static readonly short[] DFA94_special = DFA.UnpackEncodedString(DFA94_specialS);
		private static readonly short[][] DFA94_transition;

		static DFA94()
		{
			int numStates = DFA94_transitionS.Length;
			DFA94_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA94_transition[i] = DFA.UnpackEncodedString(DFA94_transitionS[i]);
			}
		}

		public DFA94( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 94;
			this.eot = DFA94_eot;
			this.eof = DFA94_eof;
			this.min = DFA94_min;
			this.max = DFA94_max;
			this.accept = DFA94_accept;
			this.special = DFA94_special;
			this.transition = DFA94_transition;
		}

		public override string Description { get { return "170:27: ( ( LT !)* defaultClause ( ( LT !)* caseClause )* )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA93 : DFA
	{
		private const string DFA93_eotS =
			"\4\uffff";
		private const string DFA93_eofS =
			"\4\uffff";
		private const string DFA93_minS =
			"\2\22\2\uffff";
		private const string DFA93_maxS =
			"\2\151\2\uffff";
		private const string DFA93_acceptS =
			"\2\uffff\1\2\1\1";
		private const string DFA93_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA93_transitionS =
			{
				"\1\1\67\uffff\1\3\36\uffff\1\2",
				"\1\1\67\uffff\1\3\36\uffff\1\2",
				"",
				""
			};

		private static readonly short[] DFA93_eot = DFA.UnpackEncodedString(DFA93_eotS);
		private static readonly short[] DFA93_eof = DFA.UnpackEncodedString(DFA93_eofS);
		private static readonly char[] DFA93_min = DFA.UnpackEncodedStringToUnsignedChars(DFA93_minS);
		private static readonly char[] DFA93_max = DFA.UnpackEncodedStringToUnsignedChars(DFA93_maxS);
		private static readonly short[] DFA93_accept = DFA.UnpackEncodedString(DFA93_acceptS);
		private static readonly short[] DFA93_special = DFA.UnpackEncodedString(DFA93_specialS);
		private static readonly short[][] DFA93_transition;

		static DFA93()
		{
			int numStates = DFA93_transitionS.Length;
			DFA93_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA93_transition[i] = DFA.UnpackEncodedString(DFA93_transitionS[i]);
			}
		}

		public DFA93( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 93;
			this.eot = DFA93_eot;
			this.eof = DFA93_eof;
			this.min = DFA93_min;
			this.max = DFA93_max;
			this.accept = DFA93_accept;
			this.special = DFA93_special;
			this.transition = DFA93_transition;
		}

		public override string Description { get { return "()* loopback of 170:47: ( ( LT !)* caseClause )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA106 : DFA
	{
		private const string DFA106_eotS =
			"\4\uffff";
		private const string DFA106_eofS =
			"\2\3\2\uffff";
		private const string DFA106_minS =
			"\2\17\2\uffff";
		private const string DFA106_maxS =
			"\2\152\2\uffff";
		private const string DFA106_acceptS =
			"\2\uffff\1\1\1\2";
		private const string DFA106_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA106_transitionS =
			{
				"\1\3\2\uffff\1\1\2\uffff\1\3\2\uffff\1\3\6\uffff\1\3\7\uffff\1\3\3\uffff"+
				"\2\3\2\uffff\2\3\5\uffff\1\3\16\uffff\1\3\3\uffff\2\3\1\uffff\6\3\1"+
				"\2\3\3\2\uffff\16\3\3\uffff\2\3",
				"\1\3\2\uffff\1\1\2\uffff\1\3\2\uffff\1\3\6\uffff\1\3\7\uffff\1\3\3"+
				"\uffff\2\3\2\uffff\2\3\5\uffff\1\3\16\uffff\1\3\3\uffff\2\3\1\uffff"+
				"\6\3\1\2\3\3\2\uffff\16\3\3\uffff\2\3",
				"",
				""
			};

		private static readonly short[] DFA106_eot = DFA.UnpackEncodedString(DFA106_eotS);
		private static readonly short[] DFA106_eof = DFA.UnpackEncodedString(DFA106_eofS);
		private static readonly char[] DFA106_min = DFA.UnpackEncodedStringToUnsignedChars(DFA106_minS);
		private static readonly char[] DFA106_max = DFA.UnpackEncodedStringToUnsignedChars(DFA106_maxS);
		private static readonly short[] DFA106_accept = DFA.UnpackEncodedString(DFA106_acceptS);
		private static readonly short[] DFA106_special = DFA.UnpackEncodedString(DFA106_specialS);
		private static readonly short[][] DFA106_transition;

		static DFA106()
		{
			int numStates = DFA106_transitionS.Length;
			DFA106_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA106_transition[i] = DFA.UnpackEncodedString(DFA106_transitionS[i]);
			}
		}

		public DFA106( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 106;
			this.eot = DFA106_eot;
			this.eof = DFA106_eof;
			this.min = DFA106_min;
			this.max = DFA106_max;
			this.accept = DFA106_accept;
			this.special = DFA106_special;
			this.transition = DFA106_transition;
		}

		public override string Description { get { return "186:64: ( ( LT !)* finallyClause )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA115 : DFA
	{
		private const string DFA115_eotS =
			"\5\uffff";
		private const string DFA115_eofS =
			"\2\2\2\uffff\1\2";
		private const string DFA115_minS =
			"\1\22\1\17\2\uffff\1\17";
		private const string DFA115_maxS =
			"\1\106\1\152\2\uffff\1\152";
		private const string DFA115_acceptS =
			"\2\uffff\1\2\1\1\1\uffff";
		private const string DFA115_specialS =
			"\5\uffff}>";
		private static readonly string[] DFA115_transitionS =
			{
				"\1\1\25\uffff\1\2\5\uffff\1\3\6\uffff\2\2\17\uffff\1\2",
				"\1\2\2\uffff\1\4\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\7\uffff\2\2\2"+
				"\uffff\2\2\1\uffff\1\3\2\2\4\uffff\2\2\16\uffff\2\2\2\uffff\2\2\1\uffff"+
				"\6\2\1\uffff\3\2\2\uffff\16\2\3\uffff\2\2",
				"",
				"",
				"\1\2\2\uffff\1\4\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\7\uffff\2\2\2"+
				"\uffff\2\2\1\uffff\1\3\2\2\4\uffff\2\2\16\uffff\2\2\2\uffff\2\2\1\uffff"+
				"\6\2\1\uffff\3\2\2\uffff\16\2\3\uffff\2\2"
			};

		private static readonly short[] DFA115_eot = DFA.UnpackEncodedString(DFA115_eotS);
		private static readonly short[] DFA115_eof = DFA.UnpackEncodedString(DFA115_eofS);
		private static readonly char[] DFA115_min = DFA.UnpackEncodedStringToUnsignedChars(DFA115_minS);
		private static readonly char[] DFA115_max = DFA.UnpackEncodedStringToUnsignedChars(DFA115_maxS);
		private static readonly short[] DFA115_accept = DFA.UnpackEncodedString(DFA115_acceptS);
		private static readonly short[] DFA115_special = DFA.UnpackEncodedString(DFA115_specialS);
		private static readonly short[][] DFA115_transition;

		static DFA115()
		{
			int numStates = DFA115_transitionS.Length;
			DFA115_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA115_transition[i] = DFA.UnpackEncodedString(DFA115_transitionS[i]);
			}
		}

		public DFA115( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 115;
			this.eot = DFA115_eot;
			this.eof = DFA115_eof;
			this.min = DFA115_min;
			this.max = DFA115_max;
			this.accept = DFA115_accept;
			this.special = DFA115_special;
			this.transition = DFA115_transition;
		}

		public override string Description { get { return "()* loopback of 199:25: ( ( LT !)* ',' ( LT !)* assignmentExpression )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA118 : DFA
	{
		private const string DFA118_eotS =
			"\4\uffff";
		private const string DFA118_eofS =
			"\1\2\3\uffff";
		private const string DFA118_minS =
			"\2\22\2\uffff";
		private const string DFA118_maxS =
			"\2\66\2\uffff";
		private const string DFA118_acceptS =
			"\2\uffff\1\2\1\1";
		private const string DFA118_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA118_transitionS =
			{
				"\1\1\33\uffff\1\3\7\uffff\1\2",
				"\1\1\33\uffff\1\3\7\uffff\1\2",
				"",
				""
			};

		private static readonly short[] DFA118_eot = DFA.UnpackEncodedString(DFA118_eotS);
		private static readonly short[] DFA118_eof = DFA.UnpackEncodedString(DFA118_eofS);
		private static readonly char[] DFA118_min = DFA.UnpackEncodedStringToUnsignedChars(DFA118_minS);
		private static readonly char[] DFA118_max = DFA.UnpackEncodedStringToUnsignedChars(DFA118_maxS);
		private static readonly short[] DFA118_accept = DFA.UnpackEncodedString(DFA118_acceptS);
		private static readonly short[] DFA118_special = DFA.UnpackEncodedString(DFA118_specialS);
		private static readonly short[][] DFA118_transition;

		static DFA118()
		{
			int numStates = DFA118_transitionS.Length;
			DFA118_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA118_transition[i] = DFA.UnpackEncodedString(DFA118_transitionS[i]);
			}
		}

		public DFA118( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 118;
			this.eot = DFA118_eot;
			this.eof = DFA118_eof;
			this.min = DFA118_min;
			this.max = DFA118_max;
			this.accept = DFA118_accept;
			this.special = DFA118_special;
			this.transition = DFA118_transition;
		}

		public override string Description { get { return "()* loopback of 203:29: ( ( LT !)* ',' ( LT !)* assignmentExpressionNoIn )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA142 : DFA
	{
		private const string DFA142_eotS =
			"\4\uffff";
		private const string DFA142_eofS =
			"\4\uffff";
		private const string DFA142_minS =
			"\2\17\2\uffff";
		private const string DFA142_maxS =
			"\2\152\2\uffff";
		private const string DFA142_acceptS =
			"\2\uffff\1\1\1\2";
		private const string DFA142_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA142_transitionS =
			{
				"\1\2\2\uffff\1\1\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\7\uffff\1\2\1\3"+
				"\2\uffff\2\2\2\uffff\2\2\24\uffff\1\2\10\uffff\1\2\2\uffff\1\2\2\uffff"+
				"\1\2\3\uffff\2\2\2\uffff\1\2\1\uffff\1\2\1\uffff\1\2\1\uffff\1\2\2\uffff"+
				"\1\2\4\uffff\1\2",
				"\1\2\2\uffff\1\1\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\7\uffff\1\2\1"+
				"\3\2\uffff\2\2\2\uffff\2\2\24\uffff\1\2\10\uffff\1\2\2\uffff\1\2\2\uffff"+
				"\1\2\3\uffff\2\2\2\uffff\1\2\1\uffff\1\2\1\uffff\1\2\1\uffff\1\2\2\uffff"+
				"\1\2\4\uffff\1\2",
				"",
				""
			};

		private static readonly short[] DFA142_eot = DFA.UnpackEncodedString(DFA142_eotS);
		private static readonly short[] DFA142_eof = DFA.UnpackEncodedString(DFA142_eofS);
		private static readonly char[] DFA142_min = DFA.UnpackEncodedStringToUnsignedChars(DFA142_minS);
		private static readonly char[] DFA142_max = DFA.UnpackEncodedStringToUnsignedChars(DFA142_maxS);
		private static readonly short[] DFA142_accept = DFA.UnpackEncodedString(DFA142_acceptS);
		private static readonly short[] DFA142_special = DFA.UnpackEncodedString(DFA142_specialS);
		private static readonly short[][] DFA142_transition;

		static DFA142()
		{
			int numStates = DFA142_transitionS.Length;
			DFA142_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA142_transition[i] = DFA.UnpackEncodedString(DFA142_transitionS[i]);
			}
		}

		public DFA142( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 142;
			this.eot = DFA142_eot;
			this.eof = DFA142_eof;
			this.min = DFA142_min;
			this.max = DFA142_max;
			this.accept = DFA142_accept;
			this.special = DFA142_special;
			this.transition = DFA142_transition;
		}

		public override string Description { get { return "246:8: ( ( LT !)* assignmentExpression ( ( LT !)* ',' ( LT !)* assignmentExpression )* )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA141 : DFA
	{
		private const string DFA141_eotS =
			"\4\uffff";
		private const string DFA141_eofS =
			"\4\uffff";
		private const string DFA141_minS =
			"\2\22\2\uffff";
		private const string DFA141_maxS =
			"\2\56\2\uffff";
		private const string DFA141_acceptS =
			"\2\uffff\1\2\1\1";
		private const string DFA141_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA141_transitionS =
			{
				"\1\1\25\uffff\1\2\5\uffff\1\3",
				"\1\1\25\uffff\1\2\5\uffff\1\3",
				"",
				""
			};

		private static readonly short[] DFA141_eot = DFA.UnpackEncodedString(DFA141_eotS);
		private static readonly short[] DFA141_eof = DFA.UnpackEncodedString(DFA141_eofS);
		private static readonly char[] DFA141_min = DFA.UnpackEncodedStringToUnsignedChars(DFA141_minS);
		private static readonly char[] DFA141_max = DFA.UnpackEncodedStringToUnsignedChars(DFA141_maxS);
		private static readonly short[] DFA141_accept = DFA.UnpackEncodedString(DFA141_acceptS);
		private static readonly short[] DFA141_special = DFA.UnpackEncodedString(DFA141_specialS);
		private static readonly short[][] DFA141_transition;

		static DFA141()
		{
			int numStates = DFA141_transitionS.Length;
			DFA141_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA141_transition[i] = DFA.UnpackEncodedString(DFA141_transitionS[i]);
			}
		}

		public DFA141( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 141;
			this.eot = DFA141_eot;
			this.eof = DFA141_eof;
			this.min = DFA141_min;
			this.max = DFA141_max;
			this.accept = DFA141_accept;
			this.special = DFA141_special;
			this.transition = DFA141_transition;
		}

		public override string Description { get { return "()* loopback of 246:35: ( ( LT !)* ',' ( LT !)* assignmentExpression )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA151 : DFA
	{
		private const string DFA151_eotS =
			"\5\uffff";
		private const string DFA151_eofS =
			"\2\3\2\uffff\1\3";
		private const string DFA151_minS =
			"\1\22\1\17\2\uffff\1\17";
		private const string DFA151_maxS =
			"\1\151\1\152\2\uffff\1\152";
		private const string DFA151_acceptS =
			"\2\uffff\1\1\1\2\1\uffff";
		private const string DFA151_specialS =
			"\5\uffff}>";
		private static readonly string[] DFA151_transitionS =
			{
				"\1\1\25\uffff\1\3\5\uffff\1\3\6\uffff\2\3\15\uffff\1\2\1\uffff\1\3\42"+
				"\uffff\1\3",
				"\1\3\2\uffff\1\4\2\uffff\1\3\2\uffff\1\3\6\uffff\1\3\7\uffff\2\3\2"+
				"\uffff\2\3\1\uffff\3\3\4\uffff\2\3\15\uffff\1\2\2\3\2\uffff\2\3\1\uffff"+
				"\6\3\1\uffff\3\3\2\uffff\16\3\3\uffff\2\3",
				"",
				"",
				"\1\3\2\uffff\1\4\2\uffff\1\3\2\uffff\1\3\6\uffff\1\3\7\uffff\2\3\2"+
				"\uffff\2\3\1\uffff\3\3\4\uffff\2\3\15\uffff\1\2\2\3\2\uffff\2\3\1\uffff"+
				"\6\3\1\uffff\3\3\2\uffff\16\3\3\uffff\2\3"
			};

		private static readonly short[] DFA151_eot = DFA.UnpackEncodedString(DFA151_eotS);
		private static readonly short[] DFA151_eof = DFA.UnpackEncodedString(DFA151_eofS);
		private static readonly char[] DFA151_min = DFA.UnpackEncodedStringToUnsignedChars(DFA151_minS);
		private static readonly char[] DFA151_max = DFA.UnpackEncodedStringToUnsignedChars(DFA151_maxS);
		private static readonly short[] DFA151_accept = DFA.UnpackEncodedString(DFA151_acceptS);
		private static readonly short[] DFA151_special = DFA.UnpackEncodedString(DFA151_specialS);
		private static readonly short[][] DFA151_transition;

		static DFA151()
		{
			int numStates = DFA151_transitionS.Length;
			DFA151_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA151_transition[i] = DFA.UnpackEncodedString(DFA151_transitionS[i]);
			}
		}

		public DFA151( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 151;
			this.eot = DFA151_eot;
			this.eof = DFA151_eof;
			this.min = DFA151_min;
			this.max = DFA151_max;
			this.accept = DFA151_accept;
			this.special = DFA151_special;
			this.transition = DFA151_transition;
		}

		public override string Description { get { return "262:24: ( ( LT !)* '?' ( LT !)* assignmentExpression ( LT !)* ':' ( LT !)* assignmentExpression )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA156 : DFA
	{
		private const string DFA156_eotS =
			"\4\uffff";
		private const string DFA156_eofS =
			"\1\3\3\uffff";
		private const string DFA156_minS =
			"\2\22\2\uffff";
		private const string DFA156_maxS =
			"\2\126\2\uffff";
		private const string DFA156_acceptS =
			"\2\uffff\1\1\1\2";
		private const string DFA156_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA156_transitionS =
			{
				"\1\1\33\uffff\1\3\6\uffff\2\3\15\uffff\1\2\21\uffff\1\3",
				"\1\1\33\uffff\1\3\6\uffff\2\3\15\uffff\1\2\21\uffff\1\3",
				"",
				""
			};

		private static readonly short[] DFA156_eot = DFA.UnpackEncodedString(DFA156_eotS);
		private static readonly short[] DFA156_eof = DFA.UnpackEncodedString(DFA156_eofS);
		private static readonly char[] DFA156_min = DFA.UnpackEncodedStringToUnsignedChars(DFA156_minS);
		private static readonly char[] DFA156_max = DFA.UnpackEncodedStringToUnsignedChars(DFA156_maxS);
		private static readonly short[] DFA156_accept = DFA.UnpackEncodedString(DFA156_acceptS);
		private static readonly short[] DFA156_special = DFA.UnpackEncodedString(DFA156_specialS);
		private static readonly short[][] DFA156_transition;

		static DFA156()
		{
			int numStates = DFA156_transitionS.Length;
			DFA156_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA156_transition[i] = DFA.UnpackEncodedString(DFA156_transitionS[i]);
			}
		}

		public DFA156( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 156;
			this.eot = DFA156_eot;
			this.eof = DFA156_eof;
			this.min = DFA156_min;
			this.max = DFA156_max;
			this.accept = DFA156_accept;
			this.special = DFA156_special;
			this.transition = DFA156_transition;
		}

		public override string Description { get { return "266:28: ( ( LT !)* '?' ( LT !)* assignmentExpressionNoIn ( LT !)* ':' ( LT !)* assignmentExpressionNoIn )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA159 : DFA
	{
		private const string DFA159_eotS =
			"\5\uffff";
		private const string DFA159_eofS =
			"\2\2\2\uffff\1\2";
		private const string DFA159_minS =
			"\1\22\1\17\2\uffff\1\17";
		private const string DFA159_maxS =
			"\1\151\1\152\2\uffff\1\152";
		private const string DFA159_acceptS =
			"\2\uffff\1\2\1\1\1\uffff";
		private const string DFA159_specialS =
			"\5\uffff}>";
		private static readonly string[] DFA159_transitionS =
			{
				"\1\1\25\uffff\1\2\5\uffff\1\2\6\uffff\2\2\15\uffff\1\2\1\uffff\1\2\41"+
				"\uffff\1\3\1\2",
				"\1\2\2\uffff\1\4\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\7\uffff\2\2\2"+
				"\uffff\2\2\1\uffff\3\2\4\uffff\2\2\15\uffff\3\2\2\uffff\2\2\1\uffff"+
				"\6\2\1\uffff\3\2\2\uffff\16\2\2\uffff\1\3\2\2",
				"",
				"",
				"\1\2\2\uffff\1\4\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\7\uffff\2\2\2"+
				"\uffff\2\2\1\uffff\3\2\4\uffff\2\2\15\uffff\3\2\2\uffff\2\2\1\uffff"+
				"\6\2\1\uffff\3\2\2\uffff\16\2\2\uffff\1\3\2\2"
			};

		private static readonly short[] DFA159_eot = DFA.UnpackEncodedString(DFA159_eotS);
		private static readonly short[] DFA159_eof = DFA.UnpackEncodedString(DFA159_eofS);
		private static readonly char[] DFA159_min = DFA.UnpackEncodedStringToUnsignedChars(DFA159_minS);
		private static readonly char[] DFA159_max = DFA.UnpackEncodedStringToUnsignedChars(DFA159_maxS);
		private static readonly short[] DFA159_accept = DFA.UnpackEncodedString(DFA159_acceptS);
		private static readonly short[] DFA159_special = DFA.UnpackEncodedString(DFA159_specialS);
		private static readonly short[][] DFA159_transition;

		static DFA159()
		{
			int numStates = DFA159_transitionS.Length;
			DFA159_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA159_transition[i] = DFA.UnpackEncodedString(DFA159_transitionS[i]);
			}
		}

		public DFA159( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 159;
			this.eot = DFA159_eot;
			this.eof = DFA159_eof;
			this.min = DFA159_min;
			this.max = DFA159_max;
			this.accept = DFA159_accept;
			this.special = DFA159_special;
			this.transition = DFA159_transition;
		}

		public override string Description { get { return "()* loopback of 270:25: ( ( LT !)* '||' ( LT !)* logicalANDExpression )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA162 : DFA
	{
		private const string DFA162_eotS =
			"\4\uffff";
		private const string DFA162_eofS =
			"\1\2\3\uffff";
		private const string DFA162_minS =
			"\2\22\2\uffff";
		private const string DFA162_maxS =
			"\2\150\2\uffff";
		private const string DFA162_acceptS =
			"\2\uffff\1\2\1\1";
		private const string DFA162_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA162_transitionS =
			{
				"\1\1\33\uffff\1\2\6\uffff\2\2\15\uffff\1\2\21\uffff\1\2\21\uffff\1\3",
				"\1\1\33\uffff\1\2\6\uffff\2\2\15\uffff\1\2\21\uffff\1\2\21\uffff\1"+
				"\3",
				"",
				""
			};

		private static readonly short[] DFA162_eot = DFA.UnpackEncodedString(DFA162_eotS);
		private static readonly short[] DFA162_eof = DFA.UnpackEncodedString(DFA162_eofS);
		private static readonly char[] DFA162_min = DFA.UnpackEncodedStringToUnsignedChars(DFA162_minS);
		private static readonly char[] DFA162_max = DFA.UnpackEncodedStringToUnsignedChars(DFA162_maxS);
		private static readonly short[] DFA162_accept = DFA.UnpackEncodedString(DFA162_acceptS);
		private static readonly short[] DFA162_special = DFA.UnpackEncodedString(DFA162_specialS);
		private static readonly short[][] DFA162_transition;

		static DFA162()
		{
			int numStates = DFA162_transitionS.Length;
			DFA162_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA162_transition[i] = DFA.UnpackEncodedString(DFA162_transitionS[i]);
			}
		}

		public DFA162( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 162;
			this.eot = DFA162_eot;
			this.eof = DFA162_eof;
			this.min = DFA162_min;
			this.max = DFA162_max;
			this.accept = DFA162_accept;
			this.special = DFA162_special;
			this.transition = DFA162_transition;
		}

		public override string Description { get { return "()* loopback of 274:29: ( ( LT !)* '||' ( LT !)* logicalANDExpressionNoIn )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA165 : DFA
	{
		private const string DFA165_eotS =
			"\5\uffff";
		private const string DFA165_eofS =
			"\2\2\2\uffff\1\2";
		private const string DFA165_minS =
			"\1\22\1\17\2\uffff\1\17";
		private const string DFA165_maxS =
			"\1\151\1\152\2\uffff\1\152";
		private const string DFA165_acceptS =
			"\2\uffff\1\2\1\1\1\uffff";
		private const string DFA165_specialS =
			"\5\uffff}>";
		private static readonly string[] DFA165_transitionS =
			{
				"\1\1\21\uffff\1\3\3\uffff\1\2\5\uffff\1\2\6\uffff\2\2\15\uffff\1\2\1"+
				"\uffff\1\2\41\uffff\2\2",
				"\1\2\2\uffff\1\4\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\4\uffff\1\3\2"+
				"\uffff\2\2\2\uffff\2\2\1\uffff\3\2\4\uffff\2\2\15\uffff\3\2\2\uffff"+
				"\2\2\1\uffff\6\2\1\uffff\3\2\2\uffff\16\2\2\uffff\3\2",
				"",
				"",
				"\1\2\2\uffff\1\4\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\4\uffff\1\3\2"+
				"\uffff\2\2\2\uffff\2\2\1\uffff\3\2\4\uffff\2\2\15\uffff\3\2\2\uffff"+
				"\2\2\1\uffff\6\2\1\uffff\3\2\2\uffff\16\2\2\uffff\3\2"
			};

		private static readonly short[] DFA165_eot = DFA.UnpackEncodedString(DFA165_eotS);
		private static readonly short[] DFA165_eof = DFA.UnpackEncodedString(DFA165_eofS);
		private static readonly char[] DFA165_min = DFA.UnpackEncodedStringToUnsignedChars(DFA165_minS);
		private static readonly char[] DFA165_max = DFA.UnpackEncodedStringToUnsignedChars(DFA165_maxS);
		private static readonly short[] DFA165_accept = DFA.UnpackEncodedString(DFA165_acceptS);
		private static readonly short[] DFA165_special = DFA.UnpackEncodedString(DFA165_specialS);
		private static readonly short[][] DFA165_transition;

		static DFA165()
		{
			int numStates = DFA165_transitionS.Length;
			DFA165_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA165_transition[i] = DFA.UnpackEncodedString(DFA165_transitionS[i]);
			}
		}

		public DFA165( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 165;
			this.eot = DFA165_eot;
			this.eof = DFA165_eof;
			this.min = DFA165_min;
			this.max = DFA165_max;
			this.accept = DFA165_accept;
			this.special = DFA165_special;
			this.transition = DFA165_transition;
		}

		public override string Description { get { return "()* loopback of 278:24: ( ( LT !)* '&&' ( LT !)* bitwiseORExpression )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA168 : DFA
	{
		private const string DFA168_eotS =
			"\4\uffff";
		private const string DFA168_eofS =
			"\1\2\3\uffff";
		private const string DFA168_minS =
			"\2\22\2\uffff";
		private const string DFA168_maxS =
			"\2\150\2\uffff";
		private const string DFA168_acceptS =
			"\2\uffff\1\2\1\1";
		private const string DFA168_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA168_transitionS =
			{
				"\1\1\21\uffff\1\3\11\uffff\1\2\6\uffff\2\2\15\uffff\1\2\21\uffff\1\2"+
				"\21\uffff\1\2",
				"\1\1\21\uffff\1\3\11\uffff\1\2\6\uffff\2\2\15\uffff\1\2\21\uffff\1"+
				"\2\21\uffff\1\2",
				"",
				""
			};

		private static readonly short[] DFA168_eot = DFA.UnpackEncodedString(DFA168_eotS);
		private static readonly short[] DFA168_eof = DFA.UnpackEncodedString(DFA168_eofS);
		private static readonly char[] DFA168_min = DFA.UnpackEncodedStringToUnsignedChars(DFA168_minS);
		private static readonly char[] DFA168_max = DFA.UnpackEncodedStringToUnsignedChars(DFA168_maxS);
		private static readonly short[] DFA168_accept = DFA.UnpackEncodedString(DFA168_acceptS);
		private static readonly short[] DFA168_special = DFA.UnpackEncodedString(DFA168_specialS);
		private static readonly short[][] DFA168_transition;

		static DFA168()
		{
			int numStates = DFA168_transitionS.Length;
			DFA168_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA168_transition[i] = DFA.UnpackEncodedString(DFA168_transitionS[i]);
			}
		}

		public DFA168( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 168;
			this.eot = DFA168_eot;
			this.eof = DFA168_eof;
			this.min = DFA168_min;
			this.max = DFA168_max;
			this.accept = DFA168_accept;
			this.special = DFA168_special;
			this.transition = DFA168_transition;
		}

		public override string Description { get { return "()* loopback of 282:28: ( ( LT !)* '&&' ( LT !)* bitwiseORExpressionNoIn )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA171 : DFA
	{
		private const string DFA171_eotS =
			"\5\uffff";
		private const string DFA171_eofS =
			"\2\2\2\uffff\1\2";
		private const string DFA171_minS =
			"\1\22\1\17\2\uffff\1\17";
		private const string DFA171_maxS =
			"\1\151\1\152\2\uffff\1\152";
		private const string DFA171_acceptS =
			"\2\uffff\1\2\1\1\1\uffff";
		private const string DFA171_specialS =
			"\5\uffff}>";
		private static readonly string[] DFA171_transitionS =
			{
				"\1\1\21\uffff\1\2\3\uffff\1\2\5\uffff\1\2\6\uffff\2\2\15\uffff\1\2\1"+
				"\uffff\1\2\37\uffff\1\3\1\uffff\2\2",
				"\1\2\2\uffff\1\4\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\4\uffff\1\2\2"+
				"\uffff\2\2\2\uffff\2\2\1\uffff\3\2\4\uffff\2\2\15\uffff\3\2\2\uffff"+
				"\2\2\1\uffff\6\2\1\uffff\3\2\2\uffff\16\2\1\3\1\uffff\3\2",
				"",
				"",
				"\1\2\2\uffff\1\4\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\4\uffff\1\2\2"+
				"\uffff\2\2\2\uffff\2\2\1\uffff\3\2\4\uffff\2\2\15\uffff\3\2\2\uffff"+
				"\2\2\1\uffff\6\2\1\uffff\3\2\2\uffff\16\2\1\3\1\uffff\3\2"
			};

		private static readonly short[] DFA171_eot = DFA.UnpackEncodedString(DFA171_eotS);
		private static readonly short[] DFA171_eof = DFA.UnpackEncodedString(DFA171_eofS);
		private static readonly char[] DFA171_min = DFA.UnpackEncodedStringToUnsignedChars(DFA171_minS);
		private static readonly char[] DFA171_max = DFA.UnpackEncodedStringToUnsignedChars(DFA171_maxS);
		private static readonly short[] DFA171_accept = DFA.UnpackEncodedString(DFA171_acceptS);
		private static readonly short[] DFA171_special = DFA.UnpackEncodedString(DFA171_specialS);
		private static readonly short[][] DFA171_transition;

		static DFA171()
		{
			int numStates = DFA171_transitionS.Length;
			DFA171_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA171_transition[i] = DFA.UnpackEncodedString(DFA171_transitionS[i]);
			}
		}

		public DFA171( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 171;
			this.eot = DFA171_eot;
			this.eof = DFA171_eof;
			this.min = DFA171_min;
			this.max = DFA171_max;
			this.accept = DFA171_accept;
			this.special = DFA171_special;
			this.transition = DFA171_transition;
		}

		public override string Description { get { return "()* loopback of 286:25: ( ( LT !)* '|' ( LT !)* bitwiseXORExpression )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA174 : DFA
	{
		private const string DFA174_eotS =
			"\4\uffff";
		private const string DFA174_eofS =
			"\1\2\3\uffff";
		private const string DFA174_minS =
			"\2\22\2\uffff";
		private const string DFA174_maxS =
			"\2\150\2\uffff";
		private const string DFA174_acceptS =
			"\2\uffff\1\2\1\1";
		private const string DFA174_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA174_transitionS =
			{
				"\1\1\21\uffff\1\2\11\uffff\1\2\6\uffff\2\2\15\uffff\1\2\21\uffff\1\2"+
				"\17\uffff\1\3\1\uffff\1\2",
				"\1\1\21\uffff\1\2\11\uffff\1\2\6\uffff\2\2\15\uffff\1\2\21\uffff\1"+
				"\2\17\uffff\1\3\1\uffff\1\2",
				"",
				""
			};

		private static readonly short[] DFA174_eot = DFA.UnpackEncodedString(DFA174_eotS);
		private static readonly short[] DFA174_eof = DFA.UnpackEncodedString(DFA174_eofS);
		private static readonly char[] DFA174_min = DFA.UnpackEncodedStringToUnsignedChars(DFA174_minS);
		private static readonly char[] DFA174_max = DFA.UnpackEncodedStringToUnsignedChars(DFA174_maxS);
		private static readonly short[] DFA174_accept = DFA.UnpackEncodedString(DFA174_acceptS);
		private static readonly short[] DFA174_special = DFA.UnpackEncodedString(DFA174_specialS);
		private static readonly short[][] DFA174_transition;

		static DFA174()
		{
			int numStates = DFA174_transitionS.Length;
			DFA174_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA174_transition[i] = DFA.UnpackEncodedString(DFA174_transitionS[i]);
			}
		}

		public DFA174( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 174;
			this.eot = DFA174_eot;
			this.eof = DFA174_eof;
			this.min = DFA174_min;
			this.max = DFA174_max;
			this.accept = DFA174_accept;
			this.special = DFA174_special;
			this.transition = DFA174_transition;
		}

		public override string Description { get { return "()* loopback of 290:29: ( ( LT !)* '|' ( LT !)* bitwiseXORExpressionNoIn )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA177 : DFA
	{
		private const string DFA177_eotS =
			"\5\uffff";
		private const string DFA177_eofS =
			"\2\2\2\uffff\1\2";
		private const string DFA177_minS =
			"\1\22\1\17\2\uffff\1\17";
		private const string DFA177_maxS =
			"\1\151\1\152\2\uffff\1\152";
		private const string DFA177_acceptS =
			"\2\uffff\1\2\1\1\1\uffff";
		private const string DFA177_specialS =
			"\5\uffff}>";
		private static readonly string[] DFA177_transitionS =
			{
				"\1\1\21\uffff\1\2\3\uffff\1\2\5\uffff\1\2\6\uffff\2\2\15\uffff\1\2\1"+
				"\uffff\1\2\1\3\36\uffff\1\2\1\uffff\2\2",
				"\1\2\2\uffff\1\4\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\4\uffff\1\2\2"+
				"\uffff\2\2\2\uffff\2\2\1\uffff\3\2\4\uffff\2\2\15\uffff\3\2\1\3\1\uffff"+
				"\2\2\1\uffff\6\2\1\uffff\3\2\2\uffff\17\2\1\uffff\3\2",
				"",
				"",
				"\1\2\2\uffff\1\4\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\4\uffff\1\2\2"+
				"\uffff\2\2\2\uffff\2\2\1\uffff\3\2\4\uffff\2\2\15\uffff\3\2\1\3\1\uffff"+
				"\2\2\1\uffff\6\2\1\uffff\3\2\2\uffff\17\2\1\uffff\3\2"
			};

		private static readonly short[] DFA177_eot = DFA.UnpackEncodedString(DFA177_eotS);
		private static readonly short[] DFA177_eof = DFA.UnpackEncodedString(DFA177_eofS);
		private static readonly char[] DFA177_min = DFA.UnpackEncodedStringToUnsignedChars(DFA177_minS);
		private static readonly char[] DFA177_max = DFA.UnpackEncodedStringToUnsignedChars(DFA177_maxS);
		private static readonly short[] DFA177_accept = DFA.UnpackEncodedString(DFA177_acceptS);
		private static readonly short[] DFA177_special = DFA.UnpackEncodedString(DFA177_specialS);
		private static readonly short[][] DFA177_transition;

		static DFA177()
		{
			int numStates = DFA177_transitionS.Length;
			DFA177_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA177_transition[i] = DFA.UnpackEncodedString(DFA177_transitionS[i]);
			}
		}

		public DFA177( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 177;
			this.eot = DFA177_eot;
			this.eof = DFA177_eof;
			this.min = DFA177_min;
			this.max = DFA177_max;
			this.accept = DFA177_accept;
			this.special = DFA177_special;
			this.transition = DFA177_transition;
		}

		public override string Description { get { return "()* loopback of 294:25: ( ( LT !)* '^' ( LT !)* bitwiseANDExpression )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA180 : DFA
	{
		private const string DFA180_eotS =
			"\4\uffff";
		private const string DFA180_eofS =
			"\1\2\3\uffff";
		private const string DFA180_minS =
			"\2\22\2\uffff";
		private const string DFA180_maxS =
			"\2\150\2\uffff";
		private const string DFA180_acceptS =
			"\2\uffff\1\2\1\1";
		private const string DFA180_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA180_transitionS =
			{
				"\1\1\21\uffff\1\2\11\uffff\1\2\6\uffff\2\2\15\uffff\1\2\2\uffff\1\3"+
				"\16\uffff\1\2\17\uffff\1\2\1\uffff\1\2",
				"\1\1\21\uffff\1\2\11\uffff\1\2\6\uffff\2\2\15\uffff\1\2\2\uffff\1\3"+
				"\16\uffff\1\2\17\uffff\1\2\1\uffff\1\2",
				"",
				""
			};

		private static readonly short[] DFA180_eot = DFA.UnpackEncodedString(DFA180_eotS);
		private static readonly short[] DFA180_eof = DFA.UnpackEncodedString(DFA180_eofS);
		private static readonly char[] DFA180_min = DFA.UnpackEncodedStringToUnsignedChars(DFA180_minS);
		private static readonly char[] DFA180_max = DFA.UnpackEncodedStringToUnsignedChars(DFA180_maxS);
		private static readonly short[] DFA180_accept = DFA.UnpackEncodedString(DFA180_acceptS);
		private static readonly short[] DFA180_special = DFA.UnpackEncodedString(DFA180_specialS);
		private static readonly short[][] DFA180_transition;

		static DFA180()
		{
			int numStates = DFA180_transitionS.Length;
			DFA180_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA180_transition[i] = DFA.UnpackEncodedString(DFA180_transitionS[i]);
			}
		}

		public DFA180( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 180;
			this.eot = DFA180_eot;
			this.eof = DFA180_eof;
			this.min = DFA180_min;
			this.max = DFA180_max;
			this.accept = DFA180_accept;
			this.special = DFA180_special;
			this.transition = DFA180_transition;
		}

		public override string Description { get { return "()* loopback of 298:29: ( ( LT !)* '^' ( LT !)* bitwiseANDExpressionNoIn )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA183 : DFA
	{
		private const string DFA183_eotS =
			"\5\uffff";
		private const string DFA183_eofS =
			"\2\2\2\uffff\1\2";
		private const string DFA183_minS =
			"\1\22\1\17\2\uffff\1\17";
		private const string DFA183_maxS =
			"\1\151\1\152\2\uffff\1\152";
		private const string DFA183_acceptS =
			"\2\uffff\1\2\1\1\1\uffff";
		private const string DFA183_specialS =
			"\5\uffff}>";
		private static readonly string[] DFA183_transitionS =
			{
				"\1\1\21\uffff\1\2\1\3\2\uffff\1\2\5\uffff\1\2\6\uffff\2\2\15\uffff\1"+
				"\2\1\uffff\2\2\36\uffff\1\2\1\uffff\2\2",
				"\1\2\2\uffff\1\4\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\4\uffff\1\2\1"+
				"\3\1\uffff\2\2\2\uffff\2\2\1\uffff\3\2\4\uffff\2\2\15\uffff\4\2\1\uffff"+
				"\2\2\1\uffff\6\2\1\uffff\3\2\2\uffff\17\2\1\uffff\3\2",
				"",
				"",
				"\1\2\2\uffff\1\4\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\4\uffff\1\2\1"+
				"\3\1\uffff\2\2\2\uffff\2\2\1\uffff\3\2\4\uffff\2\2\15\uffff\4\2\1\uffff"+
				"\2\2\1\uffff\6\2\1\uffff\3\2\2\uffff\17\2\1\uffff\3\2"
			};

		private static readonly short[] DFA183_eot = DFA.UnpackEncodedString(DFA183_eotS);
		private static readonly short[] DFA183_eof = DFA.UnpackEncodedString(DFA183_eofS);
		private static readonly char[] DFA183_min = DFA.UnpackEncodedStringToUnsignedChars(DFA183_minS);
		private static readonly char[] DFA183_max = DFA.UnpackEncodedStringToUnsignedChars(DFA183_maxS);
		private static readonly short[] DFA183_accept = DFA.UnpackEncodedString(DFA183_acceptS);
		private static readonly short[] DFA183_special = DFA.UnpackEncodedString(DFA183_specialS);
		private static readonly short[][] DFA183_transition;

		static DFA183()
		{
			int numStates = DFA183_transitionS.Length;
			DFA183_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA183_transition[i] = DFA.UnpackEncodedString(DFA183_transitionS[i]);
			}
		}

		public DFA183( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 183;
			this.eot = DFA183_eot;
			this.eof = DFA183_eof;
			this.min = DFA183_min;
			this.max = DFA183_max;
			this.accept = DFA183_accept;
			this.special = DFA183_special;
			this.transition = DFA183_transition;
		}

		public override string Description { get { return "()* loopback of 302:23: ( ( LT !)* '&' ( LT !)* equalityExpression )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA186 : DFA
	{
		private const string DFA186_eotS =
			"\4\uffff";
		private const string DFA186_eofS =
			"\1\2\3\uffff";
		private const string DFA186_minS =
			"\2\22\2\uffff";
		private const string DFA186_maxS =
			"\2\150\2\uffff";
		private const string DFA186_acceptS =
			"\2\uffff\1\2\1\1";
		private const string DFA186_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA186_transitionS =
			{
				"\1\1\21\uffff\1\2\1\3\10\uffff\1\2\6\uffff\2\2\15\uffff\1\2\2\uffff"+
				"\1\2\16\uffff\1\2\17\uffff\1\2\1\uffff\1\2",
				"\1\1\21\uffff\1\2\1\3\10\uffff\1\2\6\uffff\2\2\15\uffff\1\2\2\uffff"+
				"\1\2\16\uffff\1\2\17\uffff\1\2\1\uffff\1\2",
				"",
				""
			};

		private static readonly short[] DFA186_eot = DFA.UnpackEncodedString(DFA186_eotS);
		private static readonly short[] DFA186_eof = DFA.UnpackEncodedString(DFA186_eofS);
		private static readonly char[] DFA186_min = DFA.UnpackEncodedStringToUnsignedChars(DFA186_minS);
		private static readonly char[] DFA186_max = DFA.UnpackEncodedStringToUnsignedChars(DFA186_maxS);
		private static readonly short[] DFA186_accept = DFA.UnpackEncodedString(DFA186_acceptS);
		private static readonly short[] DFA186_special = DFA.UnpackEncodedString(DFA186_specialS);
		private static readonly short[][] DFA186_transition;

		static DFA186()
		{
			int numStates = DFA186_transitionS.Length;
			DFA186_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA186_transition[i] = DFA.UnpackEncodedString(DFA186_transitionS[i]);
			}
		}

		public DFA186( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 186;
			this.eot = DFA186_eot;
			this.eof = DFA186_eof;
			this.min = DFA186_min;
			this.max = DFA186_max;
			this.accept = DFA186_accept;
			this.special = DFA186_special;
			this.transition = DFA186_transition;
		}

		public override string Description { get { return "()* loopback of 306:27: ( ( LT !)* '&' ( LT !)* equalityExpressionNoIn )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA189 : DFA
	{
		private const string DFA189_eotS =
			"\5\uffff";
		private const string DFA189_eofS =
			"\2\2\2\uffff\1\2";
		private const string DFA189_minS =
			"\1\22\1\17\2\uffff\1\17";
		private const string DFA189_maxS =
			"\1\151\1\152\2\uffff\1\152";
		private const string DFA189_acceptS =
			"\2\uffff\1\2\1\1\1\uffff";
		private const string DFA189_specialS =
			"\5\uffff}>";
		private static readonly string[] DFA189_transitionS =
			{
				"\1\1\15\uffff\2\3\2\uffff\2\2\2\uffff\1\2\5\uffff\1\2\6\uffff\2\2\5"+
				"\uffff\2\3\6\uffff\1\2\1\uffff\2\2\36\uffff\1\2\1\uffff\2\2",
				"\1\2\2\uffff\1\4\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\2\3\2\uffff\2"+
				"\2\1\uffff\2\2\2\uffff\2\2\1\uffff\3\2\4\uffff\2\2\5\uffff\2\3\6\uffff"+
				"\4\2\1\uffff\2\2\1\uffff\6\2\1\uffff\3\2\2\uffff\17\2\1\uffff\3\2",
				"",
				"",
				"\1\2\2\uffff\1\4\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\2\3\2\uffff\2"+
				"\2\1\uffff\2\2\2\uffff\2\2\1\uffff\3\2\4\uffff\2\2\5\uffff\2\3\6\uffff"+
				"\4\2\1\uffff\2\2\1\uffff\6\2\1\uffff\3\2\2\uffff\17\2\1\uffff\3\2"
			};

		private static readonly short[] DFA189_eot = DFA.UnpackEncodedString(DFA189_eotS);
		private static readonly short[] DFA189_eof = DFA.UnpackEncodedString(DFA189_eofS);
		private static readonly char[] DFA189_min = DFA.UnpackEncodedStringToUnsignedChars(DFA189_minS);
		private static readonly char[] DFA189_max = DFA.UnpackEncodedStringToUnsignedChars(DFA189_maxS);
		private static readonly short[] DFA189_accept = DFA.UnpackEncodedString(DFA189_acceptS);
		private static readonly short[] DFA189_special = DFA.UnpackEncodedString(DFA189_specialS);
		private static readonly short[][] DFA189_transition;

		static DFA189()
		{
			int numStates = DFA189_transitionS.Length;
			DFA189_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA189_transition[i] = DFA.UnpackEncodedString(DFA189_transitionS[i]);
			}
		}

		public DFA189( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 189;
			this.eot = DFA189_eot;
			this.eof = DFA189_eof;
			this.min = DFA189_min;
			this.max = DFA189_max;
			this.accept = DFA189_accept;
			this.special = DFA189_special;
			this.transition = DFA189_transition;
		}

		public override string Description { get { return "()* loopback of 310:25: ( ( LT !)* ( '==' | '!=' | '===' | '!==' ) ( LT !)* relationalExpression )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA192 : DFA
	{
		private const string DFA192_eotS =
			"\4\uffff";
		private const string DFA192_eofS =
			"\1\2\3\uffff";
		private const string DFA192_minS =
			"\2\22\2\uffff";
		private const string DFA192_maxS =
			"\2\150\2\uffff";
		private const string DFA192_acceptS =
			"\2\uffff\1\2\1\1";
		private const string DFA192_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA192_transitionS =
			{
				"\1\1\15\uffff\2\3\2\uffff\2\2\10\uffff\1\2\6\uffff\2\2\5\uffff\2\3\6"+
				"\uffff\1\2\2\uffff\1\2\16\uffff\1\2\17\uffff\1\2\1\uffff\1\2",
				"\1\1\15\uffff\2\3\2\uffff\2\2\10\uffff\1\2\6\uffff\2\2\5\uffff\2\3"+
				"\6\uffff\1\2\2\uffff\1\2\16\uffff\1\2\17\uffff\1\2\1\uffff\1\2",
				"",
				""
			};

		private static readonly short[] DFA192_eot = DFA.UnpackEncodedString(DFA192_eotS);
		private static readonly short[] DFA192_eof = DFA.UnpackEncodedString(DFA192_eofS);
		private static readonly char[] DFA192_min = DFA.UnpackEncodedStringToUnsignedChars(DFA192_minS);
		private static readonly char[] DFA192_max = DFA.UnpackEncodedStringToUnsignedChars(DFA192_maxS);
		private static readonly short[] DFA192_accept = DFA.UnpackEncodedString(DFA192_acceptS);
		private static readonly short[] DFA192_special = DFA.UnpackEncodedString(DFA192_specialS);
		private static readonly short[][] DFA192_transition;

		static DFA192()
		{
			int numStates = DFA192_transitionS.Length;
			DFA192_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA192_transition[i] = DFA.UnpackEncodedString(DFA192_transitionS[i]);
			}
		}

		public DFA192( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 192;
			this.eot = DFA192_eot;
			this.eof = DFA192_eof;
			this.min = DFA192_min;
			this.max = DFA192_max;
			this.accept = DFA192_accept;
			this.special = DFA192_special;
			this.transition = DFA192_transition;
		}

		public override string Description { get { return "()* loopback of 314:29: ( ( LT !)* ( '==' | '!=' | '===' | '!==' ) ( LT !)* relationalExpressionNoIn )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA195 : DFA
	{
		private const string DFA195_eotS =
			"\5\uffff";
		private const string DFA195_eofS =
			"\2\2\2\uffff\1\2";
		private const string DFA195_minS =
			"\1\22\1\17\2\uffff\1\17";
		private const string DFA195_maxS =
			"\1\151\1\152\2\uffff\1\152";
		private const string DFA195_acceptS =
			"\2\uffff\1\2\1\1\1\uffff";
		private const string DFA195_specialS =
			"\5\uffff}>";
		private static readonly string[] DFA195_transitionS =
			{
				"\1\1\15\uffff\2\2\2\uffff\2\2\2\uffff\1\2\5\uffff\1\2\6\uffff\2\2\1"+
				"\3\2\uffff\1\3\1\uffff\2\2\2\3\4\uffff\1\2\1\uffff\2\2\16\uffff\2\3"+
				"\16\uffff\1\2\1\uffff\2\2",
				"\1\2\2\uffff\1\4\2\uffff\1\2\2\uffff\1\2\6\uffff\3\2\2\uffff\2\2\1"+
				"\uffff\2\2\2\uffff\2\2\1\uffff\3\2\4\uffff\2\2\1\3\2\uffff\1\3\1\uffff"+
				"\2\2\2\3\4\uffff\4\2\1\uffff\2\2\1\uffff\6\2\1\uffff\3\2\2\3\17\2\1"+
				"\uffff\3\2",
				"",
				"",
				"\1\2\2\uffff\1\4\2\uffff\1\2\2\uffff\1\2\6\uffff\3\2\2\uffff\2\2\1"+
				"\uffff\2\2\2\uffff\2\2\1\uffff\3\2\4\uffff\2\2\1\3\2\uffff\1\3\1\uffff"+
				"\2\2\2\3\4\uffff\4\2\1\uffff\2\2\1\uffff\6\2\1\uffff\3\2\2\3\17\2\1"+
				"\uffff\3\2"
			};

		private static readonly short[] DFA195_eot = DFA.UnpackEncodedString(DFA195_eotS);
		private static readonly short[] DFA195_eof = DFA.UnpackEncodedString(DFA195_eofS);
		private static readonly char[] DFA195_min = DFA.UnpackEncodedStringToUnsignedChars(DFA195_minS);
		private static readonly char[] DFA195_max = DFA.UnpackEncodedStringToUnsignedChars(DFA195_maxS);
		private static readonly short[] DFA195_accept = DFA.UnpackEncodedString(DFA195_acceptS);
		private static readonly short[] DFA195_special = DFA.UnpackEncodedString(DFA195_specialS);
		private static readonly short[][] DFA195_transition;

		static DFA195()
		{
			int numStates = DFA195_transitionS.Length;
			DFA195_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA195_transition[i] = DFA.UnpackEncodedString(DFA195_transitionS[i]);
			}
		}

		public DFA195( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 195;
			this.eot = DFA195_eot;
			this.eof = DFA195_eof;
			this.min = DFA195_min;
			this.max = DFA195_max;
			this.accept = DFA195_accept;
			this.special = DFA195_special;
			this.transition = DFA195_transition;
		}

		public override string Description { get { return "()* loopback of 318:20: ( ( LT !)* ( '<' | '>' | '<=' | '>=' | 'instanceof' | 'in' ) ( LT !)* shiftExpression )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA198 : DFA
	{
		private const string DFA198_eotS =
			"\4\uffff";
		private const string DFA198_eofS =
			"\1\2\3\uffff";
		private const string DFA198_minS =
			"\2\22\2\uffff";
		private const string DFA198_maxS =
			"\2\150\2\uffff";
		private const string DFA198_acceptS =
			"\2\uffff\1\2\1\1";
		private const string DFA198_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA198_transitionS =
			{
				"\1\1\15\uffff\2\2\2\uffff\2\2\10\uffff\1\2\6\uffff\2\2\1\3\2\uffff\1"+
				"\3\1\uffff\2\2\2\3\4\uffff\1\2\2\uffff\1\2\16\uffff\1\2\1\3\16\uffff"+
				"\1\2\1\uffff\1\2",
				"\1\1\15\uffff\2\2\2\uffff\2\2\10\uffff\1\2\6\uffff\2\2\1\3\2\uffff"+
				"\1\3\1\uffff\2\2\2\3\4\uffff\1\2\2\uffff\1\2\16\uffff\1\2\1\3\16\uffff"+
				"\1\2\1\uffff\1\2",
				"",
				""
			};

		private static readonly short[] DFA198_eot = DFA.UnpackEncodedString(DFA198_eotS);
		private static readonly short[] DFA198_eof = DFA.UnpackEncodedString(DFA198_eofS);
		private static readonly char[] DFA198_min = DFA.UnpackEncodedStringToUnsignedChars(DFA198_minS);
		private static readonly char[] DFA198_max = DFA.UnpackEncodedStringToUnsignedChars(DFA198_maxS);
		private static readonly short[] DFA198_accept = DFA.UnpackEncodedString(DFA198_acceptS);
		private static readonly short[] DFA198_special = DFA.UnpackEncodedString(DFA198_specialS);
		private static readonly short[][] DFA198_transition;

		static DFA198()
		{
			int numStates = DFA198_transitionS.Length;
			DFA198_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA198_transition[i] = DFA.UnpackEncodedString(DFA198_transitionS[i]);
			}
		}

		public DFA198( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 198;
			this.eot = DFA198_eot;
			this.eof = DFA198_eof;
			this.min = DFA198_min;
			this.max = DFA198_max;
			this.accept = DFA198_accept;
			this.special = DFA198_special;
			this.transition = DFA198_transition;
		}

		public override string Description { get { return "()* loopback of 322:20: ( ( LT !)* ( '<' | '>' | '<=' | '>=' | 'instanceof' ) ( LT !)* shiftExpression )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA201 : DFA
	{
		private const string DFA201_eotS =
			"\5\uffff";
		private const string DFA201_eofS =
			"\2\2\2\uffff\1\2";
		private const string DFA201_minS =
			"\1\22\1\17\2\uffff\1\17";
		private const string DFA201_maxS =
			"\1\151\1\152\2\uffff\1\152";
		private const string DFA201_acceptS =
			"\2\uffff\1\2\1\1\1\uffff";
		private const string DFA201_specialS =
			"\5\uffff}>";
		private static readonly string[] DFA201_transitionS =
			{
				"\1\1\15\uffff\2\2\2\uffff\2\2\2\uffff\1\2\5\uffff\1\2\6\uffff\3\2\1"+
				"\3\1\uffff\1\2\1\uffff\4\2\1\3\1\uffff\1\3\1\uffff\1\2\1\uffff\2\2\16"+
				"\uffff\2\2\16\uffff\1\2\1\uffff\2\2",
				"\1\2\2\uffff\1\4\2\uffff\1\2\2\uffff\1\2\6\uffff\3\2\2\uffff\2\2\1"+
				"\uffff\2\2\2\uffff\2\2\1\uffff\3\2\4\uffff\3\2\1\3\1\uffff\1\2\1\uffff"+
				"\4\2\1\3\1\uffff\1\3\1\uffff\4\2\1\uffff\2\2\1\uffff\6\2\1\uffff\24"+
				"\2\1\uffff\3\2",
				"",
				"",
				"\1\2\2\uffff\1\4\2\uffff\1\2\2\uffff\1\2\6\uffff\3\2\2\uffff\2\2\1"+
				"\uffff\2\2\2\uffff\2\2\1\uffff\3\2\4\uffff\3\2\1\3\1\uffff\1\2\1\uffff"+
				"\4\2\1\3\1\uffff\1\3\1\uffff\4\2\1\uffff\2\2\1\uffff\6\2\1\uffff\24"+
				"\2\1\uffff\3\2"
			};

		private static readonly short[] DFA201_eot = DFA.UnpackEncodedString(DFA201_eotS);
		private static readonly short[] DFA201_eof = DFA.UnpackEncodedString(DFA201_eofS);
		private static readonly char[] DFA201_min = DFA.UnpackEncodedStringToUnsignedChars(DFA201_minS);
		private static readonly char[] DFA201_max = DFA.UnpackEncodedStringToUnsignedChars(DFA201_maxS);
		private static readonly short[] DFA201_accept = DFA.UnpackEncodedString(DFA201_acceptS);
		private static readonly short[] DFA201_special = DFA.UnpackEncodedString(DFA201_specialS);
		private static readonly short[][] DFA201_transition;

		static DFA201()
		{
			int numStates = DFA201_transitionS.Length;
			DFA201_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA201_transition[i] = DFA.UnpackEncodedString(DFA201_transitionS[i]);
			}
		}

		public DFA201( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 201;
			this.eot = DFA201_eot;
			this.eof = DFA201_eof;
			this.min = DFA201_min;
			this.max = DFA201_max;
			this.accept = DFA201_accept;
			this.special = DFA201_special;
			this.transition = DFA201_transition;
		}

		public override string Description { get { return "()* loopback of 326:23: ( ( LT !)* ( '<<' | '>>' | '>>>' ) ( LT !)* additiveExpression )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA207 : DFA
	{
		private const string DFA207_eotS =
			"\5\uffff";
		private const string DFA207_eofS =
			"\2\2\2\uffff\1\2";
		private const string DFA207_minS =
			"\1\22\1\17\2\uffff\1\17";
		private const string DFA207_maxS =
			"\1\151\1\152\2\uffff\1\152";
		private const string DFA207_acceptS =
			"\2\uffff\1\2\1\1\1\uffff";
		private const string DFA207_specialS =
			"\5\uffff}>";
		private static readonly string[] DFA207_transitionS =
			{
				"\1\1\15\uffff\2\2\1\3\1\uffff\2\2\2\uffff\1\2\1\3\1\uffff\1\2\2\uffff"+
				"\2\2\3\uffff\1\3\1\uffff\4\2\1\uffff\1\2\1\uffff\5\2\1\uffff\1\2\1\uffff"+
				"\1\2\1\uffff\2\2\16\uffff\2\2\16\uffff\1\2\1\uffff\2\2",
				"\1\2\2\uffff\1\4\2\uffff\1\2\2\uffff\1\2\6\uffff\3\2\1\3\1\uffff\2"+
				"\2\1\uffff\2\2\1\3\1\uffff\2\2\1\uffff\3\2\2\uffff\1\3\1\uffff\4\2\1"+
				"\uffff\1\2\1\uffff\5\2\1\uffff\1\2\1\uffff\4\2\1\uffff\2\2\1\uffff\6"+
				"\2\1\uffff\24\2\1\uffff\3\2",
				"",
				"",
				"\1\2\2\uffff\1\4\2\uffff\1\2\2\uffff\1\2\6\uffff\3\2\1\3\1\uffff\2"+
				"\2\1\uffff\2\2\1\3\1\uffff\2\2\1\uffff\3\2\2\uffff\1\3\1\uffff\4\2\1"+
				"\uffff\1\2\1\uffff\5\2\1\uffff\1\2\1\uffff\4\2\1\uffff\2\2\1\uffff\6"+
				"\2\1\uffff\24\2\1\uffff\3\2"
			};

		private static readonly short[] DFA207_eot = DFA.UnpackEncodedString(DFA207_eotS);
		private static readonly short[] DFA207_eof = DFA.UnpackEncodedString(DFA207_eofS);
		private static readonly char[] DFA207_min = DFA.UnpackEncodedStringToUnsignedChars(DFA207_minS);
		private static readonly char[] DFA207_max = DFA.UnpackEncodedStringToUnsignedChars(DFA207_maxS);
		private static readonly short[] DFA207_accept = DFA.UnpackEncodedString(DFA207_acceptS);
		private static readonly short[] DFA207_special = DFA.UnpackEncodedString(DFA207_specialS);
		private static readonly short[][] DFA207_transition;

		static DFA207()
		{
			int numStates = DFA207_transitionS.Length;
			DFA207_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA207_transition[i] = DFA.UnpackEncodedString(DFA207_transitionS[i]);
			}
		}

		public DFA207( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 207;
			this.eot = DFA207_eot;
			this.eof = DFA207_eof;
			this.min = DFA207_min;
			this.max = DFA207_max;
			this.accept = DFA207_accept;
			this.special = DFA207_special;
			this.transition = DFA207_transition;
		}

		public override string Description { get { return "()* loopback of 334:20: ( ( LT !)* ( '*' | '/' | '%' ) ( LT !)* unaryExpression )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA218 : DFA
	{
		private const string DFA218_eotS =
			"\4\uffff";
		private const string DFA218_eofS =
			"\4\uffff";
		private const string DFA218_minS =
			"\2\22\2\uffff";
		private const string DFA218_maxS =
			"\2\106\2\uffff";
		private const string DFA218_acceptS =
			"\2\uffff\1\2\1\1";
		private const string DFA218_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA218_transitionS =
			{
				"\1\1\33\uffff\1\3\27\uffff\1\2",
				"\1\1\33\uffff\1\3\27\uffff\1\2",
				"",
				""
			};

		private static readonly short[] DFA218_eot = DFA.UnpackEncodedString(DFA218_eotS);
		private static readonly short[] DFA218_eof = DFA.UnpackEncodedString(DFA218_eofS);
		private static readonly char[] DFA218_min = DFA.UnpackEncodedStringToUnsignedChars(DFA218_minS);
		private static readonly char[] DFA218_max = DFA.UnpackEncodedStringToUnsignedChars(DFA218_maxS);
		private static readonly short[] DFA218_accept = DFA.UnpackEncodedString(DFA218_acceptS);
		private static readonly short[] DFA218_special = DFA.UnpackEncodedString(DFA218_specialS);
		private static readonly short[][] DFA218_transition;

		static DFA218()
		{
			int numStates = DFA218_transitionS.Length;
			DFA218_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA218_transition[i] = DFA.UnpackEncodedString(DFA218_transitionS[i]);
			}
		}

		public DFA218( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 218;
			this.eot = DFA218_eot;
			this.eof = DFA218_eof;
			this.min = DFA218_min;
			this.max = DFA218_max;
			this.accept = DFA218_accept;
			this.special = DFA218_special;
			this.transition = DFA218_transition;
		}

		public override string Description { get { return "()* loopback of 357:35: ( ( LT !)* ',' ( ( LT !)* assignmentExpression )? )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA217 : DFA
	{
		private const string DFA217_eotS =
			"\4\uffff";
		private const string DFA217_eofS =
			"\4\uffff";
		private const string DFA217_minS =
			"\2\17\2\uffff";
		private const string DFA217_maxS =
			"\2\152\2\uffff";
		private const string DFA217_acceptS =
			"\2\uffff\1\1\1\2";
		private const string DFA217_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA217_transitionS =
			{
				"\1\2\2\uffff\1\1\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\7\uffff\1\2\3\uffff"+
				"\2\2\1\uffff\1\3\2\2\24\uffff\1\2\1\3\7\uffff\1\2\2\uffff\1\2\2\uffff"+
				"\1\2\3\uffff\2\2\2\uffff\1\2\1\uffff\1\2\1\uffff\1\2\1\uffff\1\2\2\uffff"+
				"\1\2\4\uffff\1\2",
				"\1\2\2\uffff\1\1\2\uffff\1\2\2\uffff\1\2\6\uffff\1\2\7\uffff\1\2\3"+
				"\uffff\2\2\1\uffff\1\3\2\2\24\uffff\1\2\1\3\7\uffff\1\2\2\uffff\1\2"+
				"\2\uffff\1\2\3\uffff\2\2\2\uffff\1\2\1\uffff\1\2\1\uffff\1\2\1\uffff"+
				"\1\2\2\uffff\1\2\4\uffff\1\2",
				"",
				""
			};

		private static readonly short[] DFA217_eot = DFA.UnpackEncodedString(DFA217_eotS);
		private static readonly short[] DFA217_eof = DFA.UnpackEncodedString(DFA217_eofS);
		private static readonly char[] DFA217_min = DFA.UnpackEncodedStringToUnsignedChars(DFA217_minS);
		private static readonly char[] DFA217_max = DFA.UnpackEncodedStringToUnsignedChars(DFA217_maxS);
		private static readonly short[] DFA217_accept = DFA.UnpackEncodedString(DFA217_acceptS);
		private static readonly short[] DFA217_special = DFA.UnpackEncodedString(DFA217_specialS);
		private static readonly short[][] DFA217_transition;

		static DFA217()
		{
			int numStates = DFA217_transitionS.Length;
			DFA217_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA217_transition[i] = DFA.UnpackEncodedString(DFA217_transitionS[i]);
			}
		}

		public DFA217( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 217;
			this.eot = DFA217_eot;
			this.eof = DFA217_eof;
			this.min = DFA217_min;
			this.max = DFA217_max;
			this.accept = DFA217_accept;
			this.special = DFA217_special;
			this.transition = DFA217_transition;
		}

		public override string Description { get { return "357:45: ( ( LT !)* assignmentExpression )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA223 : DFA
	{
		private const string DFA223_eotS =
			"\4\uffff";
		private const string DFA223_eofS =
			"\4\uffff";
		private const string DFA223_minS =
			"\2\22\2\uffff";
		private const string DFA223_maxS =
			"\2\151\2\uffff";
		private const string DFA223_acceptS =
			"\2\uffff\1\2\1\1";
		private const string DFA223_specialS =
			"\4\uffff}>";
		private static readonly string[] DFA223_transitionS =
			{
				"\1\1\33\uffff\1\3\72\uffff\1\2",
				"\1\1\33\uffff\1\3\72\uffff\1\2",
				"",
				""
			};

		private static readonly short[] DFA223_eot = DFA.UnpackEncodedString(DFA223_eotS);
		private static readonly short[] DFA223_eof = DFA.UnpackEncodedString(DFA223_eofS);
		private static readonly char[] DFA223_min = DFA.UnpackEncodedStringToUnsignedChars(DFA223_minS);
		private static readonly char[] DFA223_max = DFA.UnpackEncodedStringToUnsignedChars(DFA223_maxS);
		private static readonly short[] DFA223_accept = DFA.UnpackEncodedString(DFA223_acceptS);
		private static readonly short[] DFA223_special = DFA.UnpackEncodedString(DFA223_specialS);
		private static readonly short[][] DFA223_transition;

		static DFA223()
		{
			int numStates = DFA223_transitionS.Length;
			DFA223_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA223_transition[i] = DFA.UnpackEncodedString(DFA223_transitionS[i]);
			}
		}

		public DFA223( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 223;
			this.eot = DFA223_eot;
			this.eof = DFA223_eof;
			this.min = DFA223_min;
			this.max = DFA223_max;
			this.accept = DFA223_accept;
			this.special = DFA223_special;
			this.transition = DFA223_transition;
		}

		public override string Description { get { return "()* loopback of 362:34: ( ( LT !)* ',' ( LT !)* propertyNameAndValue )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _LT_in_program43 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _sourceElements_in_program47 = new BitSet(new ulong[]{0x0000000000040000UL});
		public static readonly BitSet _LT_in_program49 = new BitSet(new ulong[]{0x0000000000040000UL});
		public static readonly BitSet _EOF_in_program53 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _sourceElement_in_sourceElements66 = new BitSet(new ulong[]{0x0041988081248002UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _LT_in_sourceElements69 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _sourceElement_in_sourceElements73 = new BitSet(new ulong[]{0x0041988081248002UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _functionDeclaration_in_sourceElement87 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _statement_in_sourceElement92 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _84_in_functionDeclaration105 = new BitSet(new ulong[]{0x0000000000048000UL});
		public static readonly BitSet _LT_in_functionDeclaration107 = new BitSet(new ulong[]{0x0000000000048000UL});
		public static readonly BitSet _Identifier_in_functionDeclaration111 = new BitSet(new ulong[]{0x0000008000040000UL});
		public static readonly BitSet _LT_in_functionDeclaration113 = new BitSet(new ulong[]{0x0000008000040000UL});
		public static readonly BitSet _formalParameterList_in_functionDeclaration117 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000002000000000UL});
		public static readonly BitSet _LT_in_functionDeclaration119 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000002000000000UL});
		public static readonly BitSet _functionBody_in_functionDeclaration123 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _84_in_functionExpression135 = new BitSet(new ulong[]{0x0000008000048000UL});
		public static readonly BitSet _LT_in_functionExpression137 = new BitSet(new ulong[]{0x0000008000048000UL});
		public static readonly BitSet _Identifier_in_functionExpression141 = new BitSet(new ulong[]{0x0000008000040000UL});
		public static readonly BitSet _LT_in_functionExpression144 = new BitSet(new ulong[]{0x0000008000040000UL});
		public static readonly BitSet _formalParameterList_in_functionExpression148 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000002000000000UL});
		public static readonly BitSet _LT_in_functionExpression150 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000002000000000UL});
		public static readonly BitSet _functionBody_in_functionExpression154 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _39_in_formalParameterList166 = new BitSet(new ulong[]{0x0000010000048000UL});
		public static readonly BitSet _LT_in_formalParameterList169 = new BitSet(new ulong[]{0x0000000000048000UL});
		public static readonly BitSet _Identifier_in_formalParameterList173 = new BitSet(new ulong[]{0x0000410000040000UL});
		public static readonly BitSet _LT_in_formalParameterList176 = new BitSet(new ulong[]{0x0000400000040000UL});
		public static readonly BitSet _46_in_formalParameterList180 = new BitSet(new ulong[]{0x0000000000048000UL});
		public static readonly BitSet _LT_in_formalParameterList182 = new BitSet(new ulong[]{0x0000000000048000UL});
		public static readonly BitSet _Identifier_in_formalParameterList186 = new BitSet(new ulong[]{0x0000410000040000UL});
		public static readonly BitSet _LT_in_formalParameterList192 = new BitSet(new ulong[]{0x0000010000040000UL});
		public static readonly BitSet _40_in_formalParameterList196 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _101_in_functionBody207 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _LT_in_functionBody209 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _sourceElements_in_functionBody213 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000020000000000UL});
		public static readonly BitSet _LT_in_functionBody215 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000020000000000UL});
		public static readonly BitSet _105_in_functionBody219 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _statementBlock_in_statement231 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _variableStatement_in_statement236 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _emptyStatement_in_statement241 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _expressionStatement_in_statement246 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _ifStatement_in_statement251 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _iterationStatement_in_statement256 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _continueStatement_in_statement261 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _breakStatement_in_statement266 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _returnStatement_in_statement271 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _withStatement_in_statement276 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _labelledStatement_in_statement281 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _switchStatement_in_statement286 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _throwStatement_in_statement291 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _tryStatement_in_statement296 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _101_in_statementBlock308 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000063FFF3AD220UL});
		public static readonly BitSet _LT_in_statementBlock310 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000063FFF3AD220UL});
		public static readonly BitSet _statementList_in_statementBlock314 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000020000000000UL});
		public static readonly BitSet _LT_in_statementBlock317 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000020000000000UL});
		public static readonly BitSet _105_in_statementBlock321 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _statement_in_statementList333 = new BitSet(new ulong[]{0x0041988081248002UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _LT_in_statementList336 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _statement_in_statementList340 = new BitSet(new ulong[]{0x0041988081248002UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _97_in_variableStatement354 = new BitSet(new ulong[]{0x0000000000048000UL});
		public static readonly BitSet _LT_in_variableStatement356 = new BitSet(new ulong[]{0x0000000000048000UL});
		public static readonly BitSet _variableDeclarationList_in_variableStatement360 = new BitSet(new ulong[]{0x0040000000040000UL});
		public static readonly BitSet _set_in_variableStatement362 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _variableDeclaration_in_variableDeclarationList381 = new BitSet(new ulong[]{0x0000400000040002UL});
		public static readonly BitSet _LT_in_variableDeclarationList384 = new BitSet(new ulong[]{0x0000400000040000UL});
		public static readonly BitSet _46_in_variableDeclarationList388 = new BitSet(new ulong[]{0x0000000000048000UL});
		public static readonly BitSet _LT_in_variableDeclarationList390 = new BitSet(new ulong[]{0x0000000000048000UL});
		public static readonly BitSet _variableDeclaration_in_variableDeclarationList394 = new BitSet(new ulong[]{0x0000400000040002UL});
		public static readonly BitSet _variableDeclarationNoIn_in_variableDeclarationListNoIn408 = new BitSet(new ulong[]{0x0000400000040002UL});
		public static readonly BitSet _LT_in_variableDeclarationListNoIn411 = new BitSet(new ulong[]{0x0000400000040000UL});
		public static readonly BitSet _46_in_variableDeclarationListNoIn415 = new BitSet(new ulong[]{0x0000000000048000UL});
		public static readonly BitSet _LT_in_variableDeclarationListNoIn417 = new BitSet(new ulong[]{0x0000000000048000UL});
		public static readonly BitSet _variableDeclarationNoIn_in_variableDeclarationListNoIn421 = new BitSet(new ulong[]{0x0000400000040002UL});
		public static readonly BitSet _Identifier_in_variableDeclaration435 = new BitSet(new ulong[]{0x0800000000040002UL});
		public static readonly BitSet _LT_in_variableDeclaration437 = new BitSet(new ulong[]{0x0800000000040002UL});
		public static readonly BitSet _initialiser_in_variableDeclaration441 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _Identifier_in_variableDeclarationNoIn454 = new BitSet(new ulong[]{0x0800000000040002UL});
		public static readonly BitSet _LT_in_variableDeclarationNoIn456 = new BitSet(new ulong[]{0x0800000000040002UL});
		public static readonly BitSet _initialiserNoIn_in_variableDeclarationNoIn460 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _59_in_initialiser473 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_initialiser475 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _assignmentExpression_in_initialiser479 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _59_in_initialiserNoIn491 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_initialiserNoIn493 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_initialiserNoIn497 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _54_in_emptyStatement509 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _expression_in_expressionStatement521 = new BitSet(new ulong[]{0x0040000000040000UL});
		public static readonly BitSet _set_in_expressionStatement523 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _85_in_ifStatement542 = new BitSet(new ulong[]{0x0000008000040000UL});
		public static readonly BitSet _LT_in_ifStatement544 = new BitSet(new ulong[]{0x0000008000040000UL});
		public static readonly BitSet _39_in_ifStatement548 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_ifStatement550 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _expression_in_ifStatement554 = new BitSet(new ulong[]{0x0000010000040000UL});
		public static readonly BitSet _LT_in_ifStatement556 = new BitSet(new ulong[]{0x0000010000040000UL});
		public static readonly BitSet _40_in_ifStatement560 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _LT_in_ifStatement562 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _statement_in_ifStatement566 = new BitSet(new ulong[]{0x0000000000040002UL,0x0000000000010000UL});
		public static readonly BitSet _LT_in_ifStatement569 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000000000010000UL});
		public static readonly BitSet _80_in_ifStatement573 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _LT_in_ifStatement575 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _statement_in_ifStatement579 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _doWhileStatement_in_iterationStatement593 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _whileStatement_in_iterationStatement598 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _forStatement_in_iterationStatement603 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _forInStatement_in_iterationStatement608 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _79_in_doWhileStatement620 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _LT_in_doWhileStatement622 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _statement_in_doWhileStatement626 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000000800000000UL});
		public static readonly BitSet _LT_in_doWhileStatement628 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000000800000000UL});
		public static readonly BitSet _99_in_doWhileStatement632 = new BitSet(new ulong[]{0x0000008000040000UL});
		public static readonly BitSet _LT_in_doWhileStatement634 = new BitSet(new ulong[]{0x0000008000040000UL});
		public static readonly BitSet _39_in_doWhileStatement638 = new BitSet(new ulong[]{0x0001988081208000UL,0x0000042553124020UL});
		public static readonly BitSet _expression_in_doWhileStatement640 = new BitSet(new ulong[]{0x0000010000000000UL});
		public static readonly BitSet _40_in_doWhileStatement642 = new BitSet(new ulong[]{0x0040000000040000UL});
		public static readonly BitSet _set_in_doWhileStatement644 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _99_in_whileStatement663 = new BitSet(new ulong[]{0x0000008000040000UL});
		public static readonly BitSet _LT_in_whileStatement665 = new BitSet(new ulong[]{0x0000008000040000UL});
		public static readonly BitSet _39_in_whileStatement669 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_whileStatement671 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _expression_in_whileStatement675 = new BitSet(new ulong[]{0x0000010000040000UL});
		public static readonly BitSet _LT_in_whileStatement677 = new BitSet(new ulong[]{0x0000010000040000UL});
		public static readonly BitSet _40_in_whileStatement681 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _LT_in_whileStatement683 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _statement_in_whileStatement687 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _83_in_forStatement699 = new BitSet(new ulong[]{0x0000008000040000UL});
		public static readonly BitSet _LT_in_forStatement701 = new BitSet(new ulong[]{0x0000008000040000UL});
		public static readonly BitSet _39_in_forStatement705 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000042753124020UL});
		public static readonly BitSet _LT_in_forStatement708 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042753124020UL});
		public static readonly BitSet _forStatementInitialiserPart_in_forStatement712 = new BitSet(new ulong[]{0x0040000000040000UL});
		public static readonly BitSet _LT_in_forStatement716 = new BitSet(new ulong[]{0x0040000000040000UL});
		public static readonly BitSet _54_in_forStatement720 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_forStatement723 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _expression_in_forStatement727 = new BitSet(new ulong[]{0x0040000000040000UL});
		public static readonly BitSet _LT_in_forStatement731 = new BitSet(new ulong[]{0x0040000000040000UL});
		public static readonly BitSet _54_in_forStatement735 = new BitSet(new ulong[]{0x0001998081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_forStatement738 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _expression_in_forStatement742 = new BitSet(new ulong[]{0x0000010000040000UL});
		public static readonly BitSet _LT_in_forStatement746 = new BitSet(new ulong[]{0x0000010000040000UL});
		public static readonly BitSet _40_in_forStatement750 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _LT_in_forStatement752 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _statement_in_forStatement756 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _expressionNoIn_in_forStatementInitialiserPart768 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _97_in_forStatementInitialiserPart773 = new BitSet(new ulong[]{0x0000000000048000UL});
		public static readonly BitSet _LT_in_forStatementInitialiserPart775 = new BitSet(new ulong[]{0x0000000000048000UL});
		public static readonly BitSet _variableDeclarationListNoIn_in_forStatementInitialiserPart779 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _83_in_forInStatement791 = new BitSet(new ulong[]{0x0000008000040000UL});
		public static readonly BitSet _LT_in_forInStatement793 = new BitSet(new ulong[]{0x0000008000040000UL});
		public static readonly BitSet _39_in_forInStatement797 = new BitSet(new ulong[]{0x0000008001248000UL,0x0000002253120020UL});
		public static readonly BitSet _LT_in_forInStatement799 = new BitSet(new ulong[]{0x0000008001248000UL,0x0000002253120020UL});
		public static readonly BitSet _forInStatementInitialiserPart_in_forInStatement803 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000000000400000UL});
		public static readonly BitSet _LT_in_forInStatement805 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000000000400000UL});
		public static readonly BitSet _86_in_forInStatement809 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_forInStatement811 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _expression_in_forInStatement815 = new BitSet(new ulong[]{0x0000010000040000UL});
		public static readonly BitSet _LT_in_forInStatement817 = new BitSet(new ulong[]{0x0000010000040000UL});
		public static readonly BitSet _40_in_forInStatement821 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _LT_in_forInStatement823 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _statement_in_forInStatement827 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _leftHandSideExpression_in_forInStatementInitialiserPart839 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _97_in_forInStatementInitialiserPart844 = new BitSet(new ulong[]{0x0000000000048000UL});
		public static readonly BitSet _LT_in_forInStatementInitialiserPart846 = new BitSet(new ulong[]{0x0000000000048000UL});
		public static readonly BitSet _variableDeclarationNoIn_in_forInStatementInitialiserPart850 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _76_in_continueStatement861 = new BitSet(new ulong[]{0x0040000000048000UL});
		public static readonly BitSet _Identifier_in_continueStatement863 = new BitSet(new ulong[]{0x0040000000040000UL});
		public static readonly BitSet _set_in_continueStatement866 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _73_in_breakStatement884 = new BitSet(new ulong[]{0x0040000000048000UL});
		public static readonly BitSet _Identifier_in_breakStatement886 = new BitSet(new ulong[]{0x0040000000040000UL});
		public static readonly BitSet _set_in_breakStatement889 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _90_in_returnStatement907 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _expression_in_returnStatement909 = new BitSet(new ulong[]{0x0040000000040000UL});
		public static readonly BitSet _set_in_returnStatement912 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _100_in_withStatement931 = new BitSet(new ulong[]{0x0000008000040000UL});
		public static readonly BitSet _LT_in_withStatement933 = new BitSet(new ulong[]{0x0000008000040000UL});
		public static readonly BitSet _39_in_withStatement937 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_withStatement939 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _expression_in_withStatement943 = new BitSet(new ulong[]{0x0000010000040000UL});
		public static readonly BitSet _LT_in_withStatement945 = new BitSet(new ulong[]{0x0000010000040000UL});
		public static readonly BitSet _40_in_withStatement949 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _LT_in_withStatement951 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _statement_in_withStatement955 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _Identifier_in_labelledStatement966 = new BitSet(new ulong[]{0x0020000000040000UL});
		public static readonly BitSet _LT_in_labelledStatement968 = new BitSet(new ulong[]{0x0020000000040000UL});
		public static readonly BitSet _53_in_labelledStatement972 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _LT_in_labelledStatement974 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _statement_in_labelledStatement978 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _91_in_switchStatement990 = new BitSet(new ulong[]{0x0000008000040000UL});
		public static readonly BitSet _LT_in_switchStatement992 = new BitSet(new ulong[]{0x0000008000040000UL});
		public static readonly BitSet _39_in_switchStatement996 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_switchStatement998 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _expression_in_switchStatement1002 = new BitSet(new ulong[]{0x0000010000040000UL});
		public static readonly BitSet _LT_in_switchStatement1004 = new BitSet(new ulong[]{0x0000010000040000UL});
		public static readonly BitSet _40_in_switchStatement1008 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000002000000000UL});
		public static readonly BitSet _LT_in_switchStatement1010 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000002000000000UL});
		public static readonly BitSet _caseBlock_in_switchStatement1014 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _101_in_caseBlock1026 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000020000002400UL});
		public static readonly BitSet _LT_in_caseBlock1029 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000000000000400UL});
		public static readonly BitSet _caseClause_in_caseBlock1033 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000020000002400UL});
		public static readonly BitSet _LT_in_caseBlock1038 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000000000002000UL});
		public static readonly BitSet _defaultClause_in_caseBlock1042 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000020000000400UL});
		public static readonly BitSet _LT_in_caseBlock1045 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000000000000400UL});
		public static readonly BitSet _caseClause_in_caseBlock1049 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000020000000400UL});
		public static readonly BitSet _LT_in_caseBlock1055 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000020000000000UL});
		public static readonly BitSet _105_in_caseBlock1059 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _74_in_caseClause1070 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_caseClause1072 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _expression_in_caseClause1076 = new BitSet(new ulong[]{0x0020000000040000UL});
		public static readonly BitSet _LT_in_caseClause1078 = new BitSet(new ulong[]{0x0020000000040000UL});
		public static readonly BitSet _53_in_caseClause1082 = new BitSet(new ulong[]{0x0041988081248002UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _LT_in_caseClause1084 = new BitSet(new ulong[]{0x0041988081248002UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _statementList_in_caseClause1088 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _77_in_defaultClause1101 = new BitSet(new ulong[]{0x0020000000040000UL});
		public static readonly BitSet _LT_in_defaultClause1103 = new BitSet(new ulong[]{0x0020000000040000UL});
		public static readonly BitSet _53_in_defaultClause1107 = new BitSet(new ulong[]{0x0041988081248002UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _LT_in_defaultClause1109 = new BitSet(new ulong[]{0x0041988081248002UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _statementList_in_defaultClause1113 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _93_in_throwStatement1126 = new BitSet(new ulong[]{0x0001988081208000UL,0x0000042553124020UL});
		public static readonly BitSet _expression_in_throwStatement1128 = new BitSet(new ulong[]{0x0040000000040000UL});
		public static readonly BitSet _set_in_throwStatement1130 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _95_in_tryStatement1148 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000002000000000UL});
		public static readonly BitSet _LT_in_tryStatement1150 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000002000000000UL});
		public static readonly BitSet _statementBlock_in_tryStatement1154 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000000000040800UL});
		public static readonly BitSet _LT_in_tryStatement1156 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000000000040800UL});
		public static readonly BitSet _finallyClause_in_tryStatement1161 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _catchClause_in_tryStatement1165 = new BitSet(new ulong[]{0x0000000000040002UL,0x0000000000040000UL});
		public static readonly BitSet _LT_in_tryStatement1168 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000000000040000UL});
		public static readonly BitSet _finallyClause_in_tryStatement1172 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _75_in_catchClause1193 = new BitSet(new ulong[]{0x0000008000040000UL});
		public static readonly BitSet _LT_in_catchClause1195 = new BitSet(new ulong[]{0x0000008000040000UL});
		public static readonly BitSet _39_in_catchClause1199 = new BitSet(new ulong[]{0x0000000000048000UL});
		public static readonly BitSet _LT_in_catchClause1201 = new BitSet(new ulong[]{0x0000000000048000UL});
		public static readonly BitSet _Identifier_in_catchClause1205 = new BitSet(new ulong[]{0x0000010000040000UL});
		public static readonly BitSet _LT_in_catchClause1207 = new BitSet(new ulong[]{0x0000010000040000UL});
		public static readonly BitSet _40_in_catchClause1211 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000002000000000UL});
		public static readonly BitSet _LT_in_catchClause1213 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000002000000000UL});
		public static readonly BitSet _statementBlock_in_catchClause1217 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _82_in_finallyClause1229 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000002000000000UL});
		public static readonly BitSet _LT_in_finallyClause1231 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000002000000000UL});
		public static readonly BitSet _statementBlock_in_finallyClause1235 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _assignmentExpression_in_expression1247 = new BitSet(new ulong[]{0x0000400000040002UL});
		public static readonly BitSet _LT_in_expression1250 = new BitSet(new ulong[]{0x0000400000040000UL});
		public static readonly BitSet _46_in_expression1254 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_expression1256 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _assignmentExpression_in_expression1260 = new BitSet(new ulong[]{0x0000400000040002UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_expressionNoIn1274 = new BitSet(new ulong[]{0x0000400000040002UL});
		public static readonly BitSet _LT_in_expressionNoIn1277 = new BitSet(new ulong[]{0x0000400000040000UL});
		public static readonly BitSet _46_in_expressionNoIn1281 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_expressionNoIn1283 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_expressionNoIn1287 = new BitSet(new ulong[]{0x0000400000040002UL});
		public static readonly BitSet _conditionalExpression_in_assignmentExpression1301 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _leftHandSideExpression_in_assignmentExpression1306 = new BitSet(new ulong[]{0x0A12244800040000UL,0x000000800000010AUL});
		public static readonly BitSet _LT_in_assignmentExpression1308 = new BitSet(new ulong[]{0x0A12244800040000UL,0x000000800000010AUL});
		public static readonly BitSet _assignmentOperator_in_assignmentExpression1312 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_assignmentExpression1314 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _assignmentExpression_in_assignmentExpression1318 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _conditionalExpressionNoIn_in_assignmentExpressionNoIn1330 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _leftHandSideExpression_in_assignmentExpressionNoIn1335 = new BitSet(new ulong[]{0x0A12244800040000UL,0x000000800000010AUL});
		public static readonly BitSet _LT_in_assignmentExpressionNoIn1337 = new BitSet(new ulong[]{0x0A12244800040000UL,0x000000800000010AUL});
		public static readonly BitSet _assignmentOperator_in_assignmentExpressionNoIn1341 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_assignmentExpressionNoIn1343 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_assignmentExpressionNoIn1347 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _callExpression_in_leftHandSideExpression1359 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _newExpression_in_leftHandSideExpression1364 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _memberExpression_in_newExpression1376 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _88_in_newExpression1381 = new BitSet(new ulong[]{0x0000008001248000UL,0x0000002053120020UL});
		public static readonly BitSet _LT_in_newExpression1383 = new BitSet(new ulong[]{0x0000008001248000UL,0x0000002053120020UL});
		public static readonly BitSet _newExpression_in_newExpression1387 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _primaryExpression_in_memberExpression1400 = new BitSet(new ulong[]{0x0004000000040002UL,0x0000000000000020UL});
		public static readonly BitSet _functionExpression_in_memberExpression1404 = new BitSet(new ulong[]{0x0004000000040002UL,0x0000000000000020UL});
		public static readonly BitSet _88_in_memberExpression1408 = new BitSet(new ulong[]{0x0000008001248000UL,0x0000002053120020UL});
		public static readonly BitSet _LT_in_memberExpression1410 = new BitSet(new ulong[]{0x0000008001248000UL,0x0000002053120020UL});
		public static readonly BitSet _memberExpression_in_memberExpression1414 = new BitSet(new ulong[]{0x0000008000040000UL});
		public static readonly BitSet _LT_in_memberExpression1416 = new BitSet(new ulong[]{0x0000008000040000UL});
		public static readonly BitSet _arguments_in_memberExpression1420 = new BitSet(new ulong[]{0x0004000000040002UL,0x0000000000000020UL});
		public static readonly BitSet _LT_in_memberExpression1424 = new BitSet(new ulong[]{0x0004000000040000UL,0x0000000000000020UL});
		public static readonly BitSet _memberExpressionSuffix_in_memberExpression1428 = new BitSet(new ulong[]{0x0004000000040002UL,0x0000000000000020UL});
		public static readonly BitSet _indexSuffix_in_memberExpressionSuffix1442 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _propertyReferenceSuffix_in_memberExpressionSuffix1447 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _memberExpression_in_callExpression1458 = new BitSet(new ulong[]{0x0000008000040000UL});
		public static readonly BitSet _LT_in_callExpression1460 = new BitSet(new ulong[]{0x0000008000040000UL});
		public static readonly BitSet _arguments_in_callExpression1464 = new BitSet(new ulong[]{0x0004008000040002UL,0x0000000000000020UL});
		public static readonly BitSet _LT_in_callExpression1467 = new BitSet(new ulong[]{0x0004008000040000UL,0x0000000000000020UL});
		public static readonly BitSet _callExpressionSuffix_in_callExpression1471 = new BitSet(new ulong[]{0x0004008000040002UL,0x0000000000000020UL});
		public static readonly BitSet _arguments_in_callExpressionSuffix1485 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _indexSuffix_in_callExpressionSuffix1490 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _propertyReferenceSuffix_in_callExpressionSuffix1495 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _39_in_arguments1506 = new BitSet(new ulong[]{0x0001998081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_arguments1509 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _assignmentExpression_in_arguments1513 = new BitSet(new ulong[]{0x0000410000040000UL});
		public static readonly BitSet _LT_in_arguments1516 = new BitSet(new ulong[]{0x0000400000040000UL});
		public static readonly BitSet _46_in_arguments1520 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_arguments1522 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _assignmentExpression_in_arguments1526 = new BitSet(new ulong[]{0x0000410000040000UL});
		public static readonly BitSet _LT_in_arguments1532 = new BitSet(new ulong[]{0x0000010000040000UL});
		public static readonly BitSet _40_in_arguments1536 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _69_in_indexSuffix1548 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_indexSuffix1550 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _expression_in_indexSuffix1554 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000000000000040UL});
		public static readonly BitSet _LT_in_indexSuffix1556 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000000000000040UL});
		public static readonly BitSet _70_in_indexSuffix1560 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _50_in_propertyReferenceSuffix1573 = new BitSet(new ulong[]{0x0000000000048000UL});
		public static readonly BitSet _LT_in_propertyReferenceSuffix1575 = new BitSet(new ulong[]{0x0000000000048000UL});
		public static readonly BitSet _Identifier_in_propertyReferenceSuffix1579 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _logicalORExpression_in_conditionalExpression1646 = new BitSet(new ulong[]{0x0000000000040002UL,0x0000000000000010UL});
		public static readonly BitSet _LT_in_conditionalExpression1649 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000000000000010UL});
		public static readonly BitSet _68_in_conditionalExpression1653 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_conditionalExpression1655 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _assignmentExpression_in_conditionalExpression1659 = new BitSet(new ulong[]{0x0020000000040000UL});
		public static readonly BitSet _LT_in_conditionalExpression1661 = new BitSet(new ulong[]{0x0020000000040000UL});
		public static readonly BitSet _53_in_conditionalExpression1665 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_conditionalExpression1667 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _assignmentExpression_in_conditionalExpression1671 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _logicalORExpressionNoIn_in_conditionalExpressionNoIn1684 = new BitSet(new ulong[]{0x0000000000040002UL,0x0000000000000010UL});
		public static readonly BitSet _LT_in_conditionalExpressionNoIn1687 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000000000000010UL});
		public static readonly BitSet _68_in_conditionalExpressionNoIn1691 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_conditionalExpressionNoIn1693 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_conditionalExpressionNoIn1697 = new BitSet(new ulong[]{0x0020000000040000UL});
		public static readonly BitSet _LT_in_conditionalExpressionNoIn1699 = new BitSet(new ulong[]{0x0020000000040000UL});
		public static readonly BitSet _53_in_conditionalExpressionNoIn1703 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_conditionalExpressionNoIn1705 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_conditionalExpressionNoIn1709 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _logicalANDExpression_in_logicalORExpression1722 = new BitSet(new ulong[]{0x0000000000040002UL,0x0000010000000000UL});
		public static readonly BitSet _LT_in_logicalORExpression1725 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000010000000000UL});
		public static readonly BitSet _104_in_logicalORExpression1729 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_logicalORExpression1731 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _logicalANDExpression_in_logicalORExpression1735 = new BitSet(new ulong[]{0x0000000000040002UL,0x0000010000000000UL});
		public static readonly BitSet _logicalANDExpressionNoIn_in_logicalORExpressionNoIn1749 = new BitSet(new ulong[]{0x0000000000040002UL,0x0000010000000000UL});
		public static readonly BitSet _LT_in_logicalORExpressionNoIn1752 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000010000000000UL});
		public static readonly BitSet _104_in_logicalORExpressionNoIn1756 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_logicalORExpressionNoIn1758 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _logicalANDExpressionNoIn_in_logicalORExpressionNoIn1762 = new BitSet(new ulong[]{0x0000000000040002UL,0x0000010000000000UL});
		public static readonly BitSet _bitwiseORExpression_in_logicalANDExpression1776 = new BitSet(new ulong[]{0x0000001000040002UL});
		public static readonly BitSet _LT_in_logicalANDExpression1779 = new BitSet(new ulong[]{0x0000001000040000UL});
		public static readonly BitSet _36_in_logicalANDExpression1783 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_logicalANDExpression1785 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _bitwiseORExpression_in_logicalANDExpression1789 = new BitSet(new ulong[]{0x0000001000040002UL});
		public static readonly BitSet _bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn1803 = new BitSet(new ulong[]{0x0000001000040002UL});
		public static readonly BitSet _LT_in_logicalANDExpressionNoIn1806 = new BitSet(new ulong[]{0x0000001000040000UL});
		public static readonly BitSet _36_in_logicalANDExpressionNoIn1810 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_logicalANDExpressionNoIn1812 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn1816 = new BitSet(new ulong[]{0x0000001000040002UL});
		public static readonly BitSet _bitwiseXORExpression_in_bitwiseORExpression1830 = new BitSet(new ulong[]{0x0000000000040002UL,0x0000004000000000UL});
		public static readonly BitSet _LT_in_bitwiseORExpression1833 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000004000000000UL});
		public static readonly BitSet _102_in_bitwiseORExpression1837 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_bitwiseORExpression1839 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _bitwiseXORExpression_in_bitwiseORExpression1843 = new BitSet(new ulong[]{0x0000000000040002UL,0x0000004000000000UL});
		public static readonly BitSet _bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn1857 = new BitSet(new ulong[]{0x0000000000040002UL,0x0000004000000000UL});
		public static readonly BitSet _LT_in_bitwiseORExpressionNoIn1860 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000004000000000UL});
		public static readonly BitSet _102_in_bitwiseORExpressionNoIn1864 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_bitwiseORExpressionNoIn1866 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn1870 = new BitSet(new ulong[]{0x0000000000040002UL,0x0000004000000000UL});
		public static readonly BitSet _bitwiseANDExpression_in_bitwiseXORExpression1884 = new BitSet(new ulong[]{0x0000000000040002UL,0x0000000000000080UL});
		public static readonly BitSet _LT_in_bitwiseXORExpression1887 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000000000000080UL});
		public static readonly BitSet _71_in_bitwiseXORExpression1891 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_bitwiseXORExpression1893 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _bitwiseANDExpression_in_bitwiseXORExpression1897 = new BitSet(new ulong[]{0x0000000000040002UL,0x0000000000000080UL});
		public static readonly BitSet _bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn1911 = new BitSet(new ulong[]{0x0000000000040002UL,0x0000000000000080UL});
		public static readonly BitSet _LT_in_bitwiseXORExpressionNoIn1914 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000000000000080UL});
		public static readonly BitSet _71_in_bitwiseXORExpressionNoIn1918 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_bitwiseXORExpressionNoIn1920 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn1924 = new BitSet(new ulong[]{0x0000000000040002UL,0x0000000000000080UL});
		public static readonly BitSet _equalityExpression_in_bitwiseANDExpression1938 = new BitSet(new ulong[]{0x0000002000040002UL});
		public static readonly BitSet _LT_in_bitwiseANDExpression1941 = new BitSet(new ulong[]{0x0000002000040000UL});
		public static readonly BitSet _37_in_bitwiseANDExpression1945 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_bitwiseANDExpression1947 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _equalityExpression_in_bitwiseANDExpression1951 = new BitSet(new ulong[]{0x0000002000040002UL});
		public static readonly BitSet _equalityExpressionNoIn_in_bitwiseANDExpressionNoIn1965 = new BitSet(new ulong[]{0x0000002000040002UL});
		public static readonly BitSet _LT_in_bitwiseANDExpressionNoIn1968 = new BitSet(new ulong[]{0x0000002000040000UL});
		public static readonly BitSet _37_in_bitwiseANDExpressionNoIn1972 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_bitwiseANDExpressionNoIn1974 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _equalityExpressionNoIn_in_bitwiseANDExpressionNoIn1978 = new BitSet(new ulong[]{0x0000002000040002UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression1992 = new BitSet(new ulong[]{0x3000000300040002UL});
		public static readonly BitSet _LT_in_equalityExpression1995 = new BitSet(new ulong[]{0x3000000300040000UL});
		public static readonly BitSet _set_in_equalityExpression1999 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_equalityExpression2015 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression2019 = new BitSet(new ulong[]{0x3000000300040002UL});
		public static readonly BitSet _relationalExpressionNoIn_in_equalityExpressionNoIn2032 = new BitSet(new ulong[]{0x3000000300040002UL});
		public static readonly BitSet _LT_in_equalityExpressionNoIn2035 = new BitSet(new ulong[]{0x3000000300040000UL});
		public static readonly BitSet _set_in_equalityExpressionNoIn2039 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_equalityExpressionNoIn2055 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _relationalExpressionNoIn_in_equalityExpressionNoIn2059 = new BitSet(new ulong[]{0x3000000300040002UL});
		public static readonly BitSet _shiftExpression_in_relationalExpression2073 = new BitSet(new ulong[]{0xC480000000040002UL,0x0000000000C00000UL});
		public static readonly BitSet _LT_in_relationalExpression2076 = new BitSet(new ulong[]{0xC480000000040000UL,0x0000000000C00000UL});
		public static readonly BitSet _set_in_relationalExpression2080 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_relationalExpression2104 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _shiftExpression_in_relationalExpression2108 = new BitSet(new ulong[]{0xC480000000040002UL,0x0000000000C00000UL});
		public static readonly BitSet _shiftExpression_in_relationalExpressionNoIn2121 = new BitSet(new ulong[]{0xC480000000040002UL,0x0000000000800000UL});
		public static readonly BitSet _LT_in_relationalExpressionNoIn2124 = new BitSet(new ulong[]{0xC480000000040000UL,0x0000000000800000UL});
		public static readonly BitSet _set_in_relationalExpressionNoIn2128 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_relationalExpressionNoIn2148 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _shiftExpression_in_relationalExpressionNoIn2152 = new BitSet(new ulong[]{0xC480000000040002UL,0x0000000000800000UL});
		public static readonly BitSet _additiveExpression_in_shiftExpression2165 = new BitSet(new ulong[]{0x0100000000040002UL,0x0000000000000005UL});
		public static readonly BitSet _LT_in_shiftExpression2168 = new BitSet(new ulong[]{0x0100000000040000UL,0x0000000000000005UL});
		public static readonly BitSet _set_in_shiftExpression2172 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_shiftExpression2184 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _additiveExpression_in_shiftExpression2188 = new BitSet(new ulong[]{0x0100000000040002UL,0x0000000000000005UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression2201 = new BitSet(new ulong[]{0x0000880000040002UL});
		public static readonly BitSet _LT_in_additiveExpression2204 = new BitSet(new ulong[]{0x0000880000040000UL});
		public static readonly BitSet _set_in_additiveExpression2208 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_additiveExpression2216 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression2220 = new BitSet(new ulong[]{0x0000880000040002UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression2233 = new BitSet(new ulong[]{0x0008020400040002UL});
		public static readonly BitSet _LT_in_multiplicativeExpression2236 = new BitSet(new ulong[]{0x0008020400040000UL});
		public static readonly BitSet _set_in_multiplicativeExpression2240 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_multiplicativeExpression2252 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression2256 = new BitSet(new ulong[]{0x0008020400040002UL});
		public static readonly BitSet _postfixExpression_in_unaryExpression2269 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _set_in_unaryExpression2274 = new BitSet(new ulong[]{0x0001988081208000UL,0x0000042553124020UL});
		public static readonly BitSet _unaryExpression_in_unaryExpression2310 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _leftHandSideExpression_in_postfixExpression2322 = new BitSet(new ulong[]{0x0001100000000002UL});
		public static readonly BitSet _92_in_primaryExpression2342 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _Identifier_in_primaryExpression2347 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _literal_in_primaryExpression2352 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _arrayLiteral_in_primaryExpression2357 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _objectLiteral_in_primaryExpression2362 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _39_in_primaryExpression2367 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_primaryExpression2369 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _expression_in_primaryExpression2373 = new BitSet(new ulong[]{0x0000010000040000UL});
		public static readonly BitSet _LT_in_primaryExpression2375 = new BitSet(new ulong[]{0x0000010000040000UL});
		public static readonly BitSet _40_in_primaryExpression2379 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _69_in_arrayLiteral2392 = new BitSet(new ulong[]{0x0001D88081248000UL,0x0000042553124060UL});
		public static readonly BitSet _LT_in_arrayLiteral2394 = new BitSet(new ulong[]{0x0001D88081248000UL,0x0000042553124060UL});
		public static readonly BitSet _assignmentExpression_in_arrayLiteral2398 = new BitSet(new ulong[]{0x0000400000040000UL,0x0000000000000040UL});
		public static readonly BitSet _LT_in_arrayLiteral2402 = new BitSet(new ulong[]{0x0000400000040000UL});
		public static readonly BitSet _46_in_arrayLiteral2406 = new BitSet(new ulong[]{0x0001D88081248000UL,0x0000042553124060UL});
		public static readonly BitSet _LT_in_arrayLiteral2409 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _assignmentExpression_in_arrayLiteral2413 = new BitSet(new ulong[]{0x0000400000040000UL,0x0000000000000040UL});
		public static readonly BitSet _LT_in_arrayLiteral2419 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000000000000040UL});
		public static readonly BitSet _70_in_arrayLiteral2423 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _101_in_objectLiteral2442 = new BitSet(new ulong[]{0x0000000001248000UL});
		public static readonly BitSet _LT_in_objectLiteral2444 = new BitSet(new ulong[]{0x0000000001248000UL});
		public static readonly BitSet _propertyNameAndValue_in_objectLiteral2448 = new BitSet(new ulong[]{0x0000400000040000UL,0x0000020000000000UL});
		public static readonly BitSet _LT_in_objectLiteral2451 = new BitSet(new ulong[]{0x0000400000040000UL});
		public static readonly BitSet _46_in_objectLiteral2455 = new BitSet(new ulong[]{0x0000000001248000UL});
		public static readonly BitSet _LT_in_objectLiteral2457 = new BitSet(new ulong[]{0x0000000001248000UL});
		public static readonly BitSet _propertyNameAndValue_in_objectLiteral2461 = new BitSet(new ulong[]{0x0000400000040000UL,0x0000020000000000UL});
		public static readonly BitSet _LT_in_objectLiteral2465 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000020000000000UL});
		public static readonly BitSet _105_in_objectLiteral2469 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _propertyName_in_propertyNameAndValue2481 = new BitSet(new ulong[]{0x0020000000040000UL});
		public static readonly BitSet _LT_in_propertyNameAndValue2483 = new BitSet(new ulong[]{0x0020000000040000UL});
		public static readonly BitSet _53_in_propertyNameAndValue2487 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_propertyNameAndValue2489 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _assignmentExpression_in_propertyNameAndValue2493 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _functionDeclaration_in_synpred5_TypeScript87 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _LT_in_synpred9_TypeScript137 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _statementBlock_in_synpred21_TypeScript231 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _expressionStatement_in_synpred24_TypeScript246 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _labelledStatement_in_synpred31_TypeScript281 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _LT_in_synpred34_TypeScript310 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _LT_in_synpred47_TypeScript437 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _LT_in_synpred49_TypeScript456 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _LT_in_synpred60_TypeScript569 = new BitSet(new ulong[]{0x0000000000040000UL,0x0000000000010000UL});
		public static readonly BitSet _80_in_synpred60_TypeScript573 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _LT_in_synpred60_TypeScript575 = new BitSet(new ulong[]{0x0041988081248000UL,0x0000043FFF3AD220UL});
		public static readonly BitSet _statement_in_synpred60_TypeScript579 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _forStatement_in_synpred63_TypeScript603 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _LT_in_synpred118_TypeScript1084 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _LT_in_synpred121_TypeScript1109 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _conditionalExpression_in_synpred140_TypeScript1301 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _conditionalExpressionNoIn_in_synpred143_TypeScript1330 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _callExpression_in_synpred146_TypeScript1359 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _memberExpression_in_synpred147_TypeScript1376 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _LT_in_synpred154_TypeScript1424 = new BitSet(new ulong[]{0x0004000000040000UL,0x0000000000000020UL});
		public static readonly BitSet _memberExpressionSuffix_in_synpred154_TypeScript1428 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _LT_in_synpred158_TypeScript1467 = new BitSet(new ulong[]{0x0004008000040000UL,0x0000000000000020UL});
		public static readonly BitSet _callExpressionSuffix_in_synpred158_TypeScript1471 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _LT_in_synpred256_TypeScript2204 = new BitSet(new ulong[]{0x0000880000040000UL});
		public static readonly BitSet _set_in_synpred256_TypeScript2208 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _LT_in_synpred256_TypeScript2216 = new BitSet(new ulong[]{0x0001988081248000UL,0x0000042553124020UL});
		public static readonly BitSet _multiplicativeExpression_in_synpred256_TypeScript2220 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _LT_in_synpred280_TypeScript2394 = new BitSet(new ulong[]{0x0000000000000002UL});
	}
	#endregion Follow sets
}
